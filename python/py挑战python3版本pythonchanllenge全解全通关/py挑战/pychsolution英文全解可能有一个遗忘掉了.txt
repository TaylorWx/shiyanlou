Level1:Main Page
Challenge info
Title	What about making trans?
URL	http://www.pythonchallenge.com/pc/def/map.html
Prev	 <restrlink>
Next	 <restrlink>
The picture and the hint imply that the encryption was done by replacing each letter by the the letter two places after it.


First, we load the text and create a translation table

>>> import string
>>> text = """g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr
... amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q
 ... ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb.
... lmu ynnjw ml rfc spj."""
>>> table = string.maketrans(
...   string.ascii_lowercase,
...   string.ascii_lowercase[2:]+string.ascii_lowercase[:2])
Now we apply the translation table on the string:

>>> string.translate(text,table) 
"i hope you didnt translate it by hand. thats what computers are for. 
doing it in by hand is inefficient and that's why this text is so long. 
using string.maketrans() is recommended. now apply on the url."
Alternatively, just use the translate on the "text" variable:

>>> text.translate(table)
"i hope you didnt translate it by hand. thats what computers are for. 
doing it in by hand is inefficient and that's why this text is so long. 
using string.maketrans() is recommended. now apply on the url."
scholi: Solved without translate

s="g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb.  lmu ynnjw ml rfc spj."
o=""
for x in s:
	if ord(x)>=ord('a') and ord(x)<=ord('z'):
		o+=chr((ord(x)+2-ord('a'))%26+ord('a'))
	else:
		o+=x
print o
The hint suggests to change the URL from map.html to ocr.jvon, but since there is no such thing as a .jvon file, try ocr.html.

Similar to above but with some of 2.5's nested ternary operators

for x in s:
    print  chr(ord(x) if ord(x)+2 < ord('a') else  ord(x)+2 if ord(x)+2 < ord('z') else ord(x)-24 ),
Foobat 09:00, 18 Jan 2008 (PST)


Additional:

If you are living in a *nix shell, this will do it in one shot.

$ curl http://www.pythonchallenge.com/pc/def/map.html | tr a-z c-za-b
dfs

I didn't want to type all the stuff necessary to make string.translate work, so I did this instead:

.join([chr(ord(x)+2) for x in 'map'])
Which was good enough (but incorrectly maps some characters). Kragen 18:48, 22 Sep 2005 (MDT)

With a dictionary:

import string
cypher = dict(zip(string.lowercase,string.lowercase[2:]+string.lowercase[:2]))
codedmessage="g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
print "".join(cypher.get(c,c) for c in codedmessage)
With comprehensions:

data.translate(string.maketrans("".join([chr(x) for x in range(97,123)]),"".join([chr(97+(x+2)%26) for x in range(26)])))
My solution:

>>>table = maketrans('abcdefghijklmnopqrstuvwxyz','cdefghijklmnopqrstuvwxyzab')

>>>'text to be translated'.translate(table)

--Kirkpj 16:27, 6 May 2006 (MDT)

Contents [hide]
1 List comprehension with ord/chr
2 With an auxiliary function in a closure
3 Without using translate functions
4 code like this.py
5 Python not previously posted
6 A more general solution
7 Using a generator (just because)
8 Another Python solution
9 Powershell
10 Ruby solution
11 Lua Solution
12 Perl Solution
13 PHP Solution
14 Shell Solution
15 Java Solution
16 Complete Haskell Solution
17 Haskell Solution
18 Newbie Haskell Solution
19 Erlang Solution
20 C++ Solution
21 C++11 Solution
22 C Solution
23 C solution in Unix/Linux --Sgxiao 01:06, 28 Jan 2010 (PST)
24 YetAnotherPython
25 ActionScript solution
26 FORTRAN 77 solution
27 Groovy Solution
28 Before I knew maketrans() existed
29 Another approach without maketrans
30 A Python-inspired C++ Implementation
31 Beginner Python go
32 Should C# go here?
33 A sed implementation
34 Tcl Solution
35 Javascript solution
36 Nestor Velazquez solution
37 A couple of lambdas
38 Not using maketrans
38.1 Being a complete Newbie
39 MATLAB Solution
40 J Solution
41 Racket Solution
42 Python 3 ord() and maketrans() solution
43 Another Python 3 maketrans solution
44 ECMAScript 5 solution
List comprehension with ord/chr

I have to admit, it was easier to write than to read ;)

 "".join(map(lambda x: x.isalpha() and chr((ord(x)+2-ord("a"))%26 + ord("a")) or x, input))
the first try was more obvious, although not perfect:

"".join(map(lambda x: chr(ord(x)+2), input)

damonmc: using list comprehensions rather than lambda shortens the above solution slightly:

"".join([(c.isalpha() and chr(ord('a') + (ord(c)-ord('a')+2)%26) or c) for c in "map"])
damonmc: hard-coding ascii values generates the very smallest (if least readable) solution:

"".join([c.isalpha() and chr(97+(ord(c)-95)%26) or c for c in "map"])
bwmetz; Similar to damonrc - Simple ordinal arithmetic translation using both ordinal & regex ternary comparisons inside of a list comprehension

import re
"".join([((chr(ord(x)+2 if ord(x) < 120 else 97+ord(x)%121)) if re.match('[a-z]', x) else x) for x in msg])
bwmetz; Similar to damonrc - List comprehension based ordinal arithmetic translation using an ordinal range ternary comparison

"".join([(chr(ord(x) / 121 * 95 + ord(x) % 121 + 2) if ord(x) in range(97,123) else x) for x in msg])
bwmetz; Similar to damonrc - map() based ordinal arithmetic translation using an ordinal range ternary comparison inside a lambda function

"".join(map(lambda x: chr(ord(x) / 121 * 95 + ord(x) % 121 + 2) if ord(x) in range(97,123) else x, msg))
damonmc: importing "string" takes characters, so the smallest that can be done with maketrans is the following:

from string import *
a=ascii_lowercase
"map".translate(maketrans(a,a[2:]+a[:2]))
damonmc: the length is easier to compare if it's all on one line:

from string import *;a=ascii_lowercase;"map".translate(maketrans(a,a[2:]+a[:2]))
damonmc: finally, here's one more interesting approach (not quite as small as the others) that I didn't see listed above:

"".join([c.isalpha() and "abcdefghijklmnopqrstuvwxyz"[(ord(c)+2)%26] or c for c in "map"])
damonmc: however, in my opinion, the best non-maketrans way would be something extremely readable, more like:

def decodeChar (c):
    if not c.isalpha(): return c
    index = (ord(c) - ord('a') + 2) % 26
    return chr(ord('a') + index) 
"".join([decodeChar(c) for c in s])
wgsohne: I came to a solution similar to damonmc's ... somehow I find this more readable

def rotate(character):
 output = "cdefghijklmnopqrstuvwxyzab"
 position = "abcdefghijklmnopqrstuvwxyz".find(character)
 if(position == -1):
   return character
 else:
   return output[position]
 
string = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
print "".join([rotate(character) for character in string])
bytemangler: as above, I'm using the recommended string functions and written to be readable and reusable

"""simple caesar cyphers. Usage: python caesarcypher.py <string to translate> <shift (right positive, left negative)> """
import sys
import string
message = ""
shiftval = 1
alph = string.ascii_lowercase 
def shift(msg, val=1 ):
    trans = string.maketrans(alph,alph[val:] + alph[:val])
    return string.translate(msg,trans)
if __name__=="__main__":
    args = sys.argv
    if args > 1:
        message = args[1].lower()
        shiftval = int(args[2])
        print shift(message,shiftval)

odwl: What about this:

from operator  import concat
str = """g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."""
def charplus2(s):
 if s.isalpha()::
  s = chr((ord(s) - ord('a')+2)%26+ord('a'))
 return s
print str2 = reduce(concat,[charplus2(s) for s in str])

and since i was new to python and i searched and i searched for what i now know is the ord() command(but in vain), i simply used C :P Gx 03:32, 9 Jan 2007 (MST)

jxb : similar but use deque/rotate (just cos it's there!)

import string, collections as c
input =  "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
t=c.deque(string.ascii_lowercase)
t.rotate(-2)
ascii_lowercase_shifted="".join(t)
tran_table = string.maketrans(string.ascii_lowercase,ascii_lowercase_shifted)
print input.translate(tran_table)


a="""g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.""" for t in a: print chr(ord(t)+2),

which was a fast and dirty solution. But enough to make me see how to proceed

david seres:

i know this is supposed to be solved with python, but here is how you would solve it with R:

x <- "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr
      amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q
      ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb.
      lmu ynnjw ml rfc spj."
chartr(paste(letters, collapse = ""), paste(c(letters[-(1:2)], letters[1:2]), collapse = ""), x)


fossilmold:

Two easy to understand methods that allow you to input your own data.

VER 1:

alphabet="abcdefghijklmnopqrstuvwxyzab"
encrypted=raw_input("Enter encrypted data: ")
decrypted=""
for character in encrypted:
   if character in alphabet:
       new_letter_location=alphabet.find(character)+2
       decrypted=decrypted + alphabet[new_letter_location]
   else:
       decrypted=decrypted + character
print decrypted
VER 2:

from string import maketrans #needed to call the function maketrans ()
alphabet="abcdefghijklmnopqrstuvwxyz"
key="cdefghijklmnopqrstuvwxyzab"
translator=maketrans(alphabet,key)
code=raw_input("Enter data here: ")
print code.translate(translator)
With an auxiliary function in a closure

Xtian: Building a generic ROT (Caesar cypher) function:

import string

crypted = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj"

def make_rot(n):
    """ builds a rot<n> function. """

    return (lambda e: e.translate(string.maketrans("abcdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz"[n:] + "abcdefghijklmnopqrstuvwxyz"[0:n])))

rot2 = make_rot(2)
print rot2(crypted)
print "http://www.pythonchallenge.com/pc/def/" + rot2("map") + ".html"
Without using translate functions

i,j,s = 2,0,''
lookup = {}
while j <= 25:
    lookup["%c" % (0x61 + j)] = "%c" % (0x61 + i)
    if i == 25: i = 0
    else: i += 1
    j += 1

string = '''g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.
http://www.pythonchallenge.com/pc/def/map.html'''

for char in string:
    if lookup.has_key(char):
        s += lookup[char]
    else:
        s += char
print s
code like this.py

s = """g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."""

d = {}
for c in (65, 97):
    for i in range(26):
        d[chr(i+c)] = chr((i+2) % 26 + c)

print "".join([d.get(c, c) for c in s])
Python not previously posted

I didn't see a solution like this posted but it worked.

# Level 1 solution for the pychallenge

#define the alphabet
alphabet = 'abcdefghijklmnopqrstuvwxyz'

#read cipher text file into ctext as string
ctext = open('level1_ctext.txt').read()

# define our plaintext var
ptext = ''

#loop through cipher text and convert
for c in ctext:
    if alphabet.find(c) != -1:
        i = alphabet.index(c)+2
        if i  > len(alphabet)-1: 
            p = alphabet[i-26]
        else:
            p = alphabet[i]
    else:
        p = c
        
    ptext = ptext+p

#output our plaintext to the screen
print ptext
The output then tells you what to do...just run the appropriate part of the url "map" through the decoder and off you go.

I'm new to python and haven't programmed in many years...if this is a generally accepted "wrong" way to code someone please let me know!

A more general solution

Another beginner here; probably why I made this do more than it needed to (and half as well!):

import re
import string

l = string.lowercase
u = string.uppercase

def fun(delta, s):
    r = re.compile(':(.{%s})(.*?):' % delta)
    p = r.sub(r'\2\1', ':%s::%s:' % (l, u))
    m = string.maketrans(l + u, p)
    print s.translate(m)
    
s = raw_input('What is the string? ')
delta = raw_input('And by how many places do we change it? ')

fun(delta, s)
--George 00:42, 20 May 2008 (PDT)

Using a generator (just because)

def map_it(s, r):
  for c in s:
    o = ord(c)
    if o in range(97, 123):
      c = chr((o - 97 + r) % 26 + 97)
    yield c

"".join(c for c in map_it(text, 2))
-- PEZ 12:33, 16 Jan 2009 (PST)

Another Python solution

This is a simple solution.

   # the puzzle string
   ps = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq"\
        +" glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb."\
        +" lmu ynnjw ml rfc spj."
   
   # the reference dictionary
   d = {'a':'c', 'b':'d', 'c':'e', 'd':'f', 'e':'g', 'f':'h', 'g':'i', 'h':'j', 'i':'k', 'j':'l',\
        'k':'m', 'l':'n', 'm':'o', 'n':'p', 'o':'q', 'p':'r', 'q':'s', 'r':'t', 's':'u', 't':'v',\
        'u':'w', 'v':'x', 'w':'y', 'x':'z', 'y':'a','z':'b', ' ':' ', '.':'.', "'":"'", '(':'(', ')':')'}
   
   # the code
   def main():
       ans = ""
       for c in ps:
           ans += d[c]
       print ans
   
   main()
The symbol '\' at the end of the first two lines in the initialization of ps and d is the multi-line character.

It is used to limit the length of a line so that the actual written code looks readable.

--Ejhari 23:37, 17 Dec 2010 (PST)

Powershell

  ##$Q = "map"
  $Q = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
  $OFS=""; [string] [char[]] ( [int[]] [char[]] $Q |foreach {$_+2} )

Because you did not account for non-alpha characters and characters near the end of the alphabet that need to wrap around to the beginning, the output of the basic text is:

    i"hope"you"didnt"tr{nsl{te"it"|y"h{nd0"th{ts"wh{t"computers"{re"for0"doing"it"in"|y"h{nd"is"inefficient"{nd"th{t)s"why"this"text"is"so"long0"using"string0m{ketr{ns*+"is"recommended0"now"{pply"on"the"url0

Try this instead:

    #old school using for/next loop and ascii conversion and translation, character by character
    $txtInput = get-content "input.txt"
    #$txtInput = "map"
    $intLength = $txtInput.Length
    $txtOutput = 
    for ($i=0; $i -lt $intLength; $i++){
        $intCode = [int][char]$txtInput.substring($i,1)
        if ( $intCode -lt 97 ) { $intCode = $intCode -2 }
        elseif ($intCode -gt 120) { $intCode = $intCode - 26 }
        $txtOutput = $txtOutput + [char]($intCode + 2)
        }
    $txtOutput
Or using casting and collections, as you have:

   #using collections and casting
   $txtInput = get-content "input.txt"
   #$txtInput = "map"
   $txtOutput = @()
   $colCode = [int[]][char[]]$txtInput
   foreach ($intCode in $colCode) {
       if ( $intCode -lt 97 ) { 
           $intCode = $intCode -2 
           }
       elseif ($intCode -gt 120) { 
           $intCode = $intCode - 26 
           }
       $txtOutput += ($intCode + 2)
       }
   [string][char[]]$txtOutput
Either way, the result is more readable (CR's added for readability):

    i hope you didnt translate it by hand. thats what computers are for. doing it in by 
    hand is inefficient and that's why this text is so long. using string.maketrans() is 
    recommended. now apply on the url.
I think I'm hooked now:

   #using substring, collections and casting
   $txtInput = get-content "input.txt"
   $txtOutput = @()
   #$txtInput = "map"
   $txtTrans = "cdefghijklmnopqrstuvwxyzab" #translation string, use ascii code-97 as index for string
   $colCode = [int[]][char[]]$txtInput
   # Translate letters, pass other characters unchanged.
   foreach ($intCode in $colCode) {
       if ($intCode -ge 97) {
           $intCode -= 97
       $txtOutput += $txtTrans.substring($intCode,1)
           }
       else {
           $txtOutput += [char]$intCode
           }
       }
   [string]$txtOutput
Ruby solution

gets.tr "a-z","c-zab"
asenchi: I did something similar to some of the above examples, figured I'd share. The whole exercise made me think of rot13 thus the function name. (28 Jan 2008)

 def rot(text):
     alpha = 'abcdefghijklmnopqrstuvwxyz'
     bzaro = 'yzabcdefghijklmnopqrstuvwx'
     a,b = list(alpha),tuple(bzaro)
     abdict = dict(zip(b,a))
     newmsg = []
     for c in list(text):
	 if c.isalpha():
	     newmsg.append(abdict[str(c)])
	 else:
	     newmsg.append(c)
     return ''.join(newmsg)
Lua Solution

 local str = [[
 g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.]]
 
 local a = string.byte("a")
 local z = string.byte("z")
 
 print((str:gsub("%a", function (c)
     local t = (c:byte()-a+2) % 26 + a
     return string.char(t)
 end)))
Perl Solution

$_=shift;y/a-z/c-zab/;print
PHP Solution

$Str = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.";
$Str2 = "map";
$From = "abcdefghijklmnopqrstuvwxyz";
$To = "cdefghijklmnopqrstuvwxyzab";
echo strtr($Str, $From, $To)."\n\n";
echo strtr($Str2, $From, $To)."\n";
Leper421 18:10, 20 Feb 2008 (PST)

Shell Solution

$ tr [a-z] [c-za-b] --Tianyi 07:54, 5 Apr 2008 (PDT)


Java Solution

public class Shift {

	public static void main(String [] args)
	{
		char c;
		String s = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.";
		for (int i=0; i<s.length(); i++){
			c = s.charAt(i);
			if (c>='a' && c<='x')
				c = (char)((int)c+2);
				else if (c=='y') c = 'a';
				else if (c=='z') c = 'b';
		         System.out.print(c);
                }
	}
}
Complete Haskell Solution

maps each character correctly

import Data.Char

string = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
string2 = "map"

convert ' ' = ' '
convert '.' = '.'
convert '\'' = '\''
convert ')' = ')'
convert '(' = '('
convert x = chr $ let originalNum = (ord x) + 2 in
    let num = originalNum `mod` 122 in
        case (num == originalNum) of
            True -> num
            False -> num + 96


main = print $ map convert string2

Haskell Solution

Without chr and ord:

rot2 x = head [snd p | p <- zip (['a'..'z'] ++ " .()'") (['c'..'z'] ++ "ab" ++ " .()'"), fst p == x]
map rot2 "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb.  lmu ynnjw ml rfc spj."
With chr and ord:

import Data.Char
rot2' a = if isAlpha a
    then chr $ ord 'a' + (ord a + 2 - ord 'a') `mod` 26
    else a
rot2 = map rot2'
Or in point-free style:

import Data.Char
import Control.Monad

bool f t b = if b then t else f
rot2 = map ((flip flip id . liftM2) (bool id (chr.(+ ord 'a').(`mod` 26).(flip (-) (ord 'a')).(+2).ord)) isAlpha)
(bool should be added to the Prelude :)

---

Or one can take

rot2 = map $ \x ->
    lookup x $ maybe x id $ zip ['a'..'z'] (['c'..'z']++['a'..'b'])
what is more readable and (should be?) more advanced like.

Newbie Haskell Solution

import Data.Char

main :: IO ()
main = putStrLn (decode gibberish)
    where gibberish = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."

decode :: String ->  String
decode [] = ""
decode (char:trail) = [convert char] ++ decode trail

convert :: Char -> Char
convert x
    | 'a' <= x && x <= 'z' = chr(ord 'a' + (ord x + 2 - ord 'a') `mod` 26)
    | otherwise = x
Actually it is

decode = map convert
and one can replace convert by

convert = rot . rot where
    rot 'z' = 'a'
    rot x | isAlpha x = succ x
          | otherwise = x
what is more readable and (should be?) more newbie like.

Erlang Solution

One straight forward, no-library, no fun solution:

rot2([]) -> [];
rot2([Char|T]) when Char >= $a, Char =< $z -> 
  [$a + (Char - $a + 2) rem ($z - $a + 1)] ++ rot2(T);
rot2([Char|T]) -> 
  [Char] ++ rot2(T).

> rot2("map").
--akafred 02:26, 23 May 2008 (PDT)

Or quick and dirty in the erlang shell, replaces spaces with Vs

> [ $a + (Char - $a + 2) rem ($z-$a+1) || Char <- "g fmnc wms bgblr rpylqjyr..." ].
with preserving spaces

> [ if Char == $\s -> $\s; true -> $a + (Char - $a + 2) rem ($z-$a+1) end || Char <- "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj." ].
--Slobo 02:11, 21 Aug 2009 (PDT)

C++ Solution

#include <iostream>
#include <string>

void main()
{
	std::string mystring="g fmnc wms bgblr rpylqjyrc gr zw fylb. \nrfyrq ufyr amknsrcpq ypc dmp. \nbmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. \nsqgle qrpgle.kyicrpylq() gq pcamkkclbcb. \nlmu ynnjw ml rfc spj.";
	/*I added a '\n' character after each '.' so that the lines would break.*/

	int i=0;
	
	for (i=0; i<mystring.length(); i++)
	{
		if(mystring[i]=='y'||mystring[i]=='z') mystring[i]-=26;
		if('a'-2 <= mystring[i] && mystring[i] <= 'z'-2) mystring[i]+=2;
	}
	std::cout<<mystring<<"\n";  

	std::cin>>i;
	/*this is here so the program doesn't close before I can read the solution.
	I'm new to Visual C++ 2008 Express Edition, and I haven't done any programming in a few years -
	there must be a better way to make sure I can see the output.*/
	
	return;
}
chaitov 18:40, 21 May 2008 (PDT)

C++11 Solution

#include <algorithm>
#include <functional>
#include <iostream>
#include <string>

using namespace std;
using namespace std::placeholders;

char translate(char c, const string& from, const string& to)
{
	string::size_type i = from.find (c);
	if (i == string::npos) return c;
	return to[i];
}

string rotated(string s, size_t n)
{
	n %= s.length ();
	rotate (begin (s), begin (s) + n, end (s));
	return s;
}

int main()
{
	string data = 
		"g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. "
		"bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm "
		"jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.";

	string letters = "abcdefghijklmnopqrstuvwxyz";	
	string rotated_letters = rotated (letters, 2);
	auto rot2 = bind (translate, _1, cref (letters), cref (rotated_letters));
	
	transform (begin (data), end (data), begin (data), rot2);
	cout << data << endl;
}
C Solution

#include <stdio.h>
#include <string.h>

int main(void) {
    int i;
    int shiftAmount = 5;

    char theString[206] = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpy lq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.";

  for (i = 0; i < 206; i++) {
    theString[i] += (isalpha(theString[i]) ? shiftAmount : 0);
    theString[i] = (((theString[i] - 96) > 26) ? ((theString[i] - 96) % 26 + 96) : theString[i]);
  }

  printf("%s\n", theString);

  return 0;
}
jfasi 8:14, 20 September 2008 (PDT)

C solution in Unix/Linux --Sgxiao 01:06, 28 Jan 2010 (PST)

1. copy the text into a file named testtext(or whatever you like.)

2. code as below save as map.c (or whatever)

#include<stdio.h>

int map(char c)
{
        if ( c - 'a' >= 0 && c - 'a' < 26 )
                return 'a' + ((c - 'a' +  2) % 26);
        else
                return c;
}

int main(void)
{
        int c;
        while( scanf("%c", &c) != EOF ) {
                printf("%c", map(c));
        }
        return 0;
}
3. compile it

$ gcc map.c -o map.out
4. run it

$ ./map.out < testtext
YetAnotherPython

Similar to one above but in a function:

# Python challenge 1
# ras0806060305
# file: pc1.py
import string

def doTranslate():

    wordlist = ['g', 'fmnc', 'wms', 'bgblr', 'rpylqjyrc', 'gr', 'zw',
    'fylb', 'rfyrq', 'ufyr', 'amknsrcpq', 'ypc', 'dmp', 'bmgle','gr', 
    'gl', 'zw', 'fylb', 'gq', 'glcddgagclr', 'ylb', "rfyr'q", 'ufw', 
    'rfgq', 'rcvr', 'gq', 'qm', 'jmle', 'sqgle', 'qrpgle.kyicrpylq()', 
    'gq', 'pcamkkclbcb', 'lmu', 'ynnjw', 'ml', 'rfc', 'spj']

    newlist = []
    for word in wordlist:
        newlist.append(string.translate(word,
                 string.maketrans('abcdefghijklmnopqrstuvwxyz.()',
                                  'cdefghijklmnopqrstuvwxyzab.()'

                                 )
                                        )
                       )

    print newlist
ActionScript solution

var crypt:String = "map"
var solved:String = "";

for (var i = 0; i < crypt.length; i++){
	var begin:int = crypt.charCodeAt(i);
	var char = crypt.charAt(i);
	switch (char){
		case " ":
		case ".":
		case "'":
		case "(":
		case ")":
		case "/":
			solved += char;
			break;
		case "y":
			solved += "a";
			break;
		case "z":
			solved += "b";
			break;
		default:
			begin++;
			begin++;
			solved += String.fromCharCode(begin);
			break;
	}
}
trace(solved);
FORTRAN 77 solution

      CHARACTER(LEN=250) CRYPTO, URL
      DATA CRYPTO /'g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr am
     *knsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr''q uf
     *w rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. l
     *mu ynnjw ml rfc spj.'/
      DATA URL/'http://www.pythonchallenge.com/pc/def/map.html'/
      NCHAR = 26
      NSHIFT = 2
      IA = ICHAR('a')
      IZ = ICHAR('z')
      N = LEN_TRIM(CRYPTO)
      DO 10 I = 1, N
         J = ICHAR(CRYPTO(I:I))
         IF ((J.GE.IA).AND.(J.LE.IZ)) THEN
            J = J + NSHIFT
            IF (J.GT.IZ) J = J - NCHAR
            CRYPTO(I:I) = ACHAR(J)
         ENDIF
   10 CONTINUE
      WRITE (*,*) CRYPTO(1:N)
      N = LEN_TRIM(URL)
      DO 20 I = 1, N
         J = ICHAR(URL(I:I))
         IF ((J.GE.IA).AND.(J.LE.IZ)) THEN
            J = J + NSHIFT
            IF (J.GT.IZ) J = J - NCHAR
            URL(I:I) = ACHAR(J)
         ENDIF
   20 CONTINUE
      WRITE(*,*) URL(1:N)
      END
Holst Mon, 27 Oct 2008 19:36:59 +0100

Groovy Solution

#!/usr/bin/env groovy
# code by 7ek
cipherText = """g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp.
 bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle.
 sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. http://www.pythonchallenge.com/pc/def/map.html"""

rangoLetras = "a".."z"
delta = +2

plainText = cipherText.collect {letra ->
	if(letra in rangoLetras){
		letra = cambiar(letra, rangoLetras, delta)
	}
	letra
}
plainText.each{
	print it
}

def cambiar(letra, rangoLetras, delta){
	MIN = (byte)rangoLetras.min()
	MAX = (byte)rangoLetras.max() - MIN
	LETRA = (byte)letra - MIN
	l =  (LETRA+delta)%(MAX+1) + MIN
	l as char
}
Before I knew maketrans() existed

Did a good enough job

# chal2.py
import string

def process(x):
	
	#string = 'g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr\'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.' 
	
        stringList =[]
	
	for letter in string:
		mo = alpha().find(letter)
		new = mo + 2
		if new == 1:
			stringList.append(' ')
		elif new == 26:
			stringList.append('a')
		elif new == 27:
			stringList.append('b')
		else:
			stringList.append(alpha()[new])
	print ''.join(stringList)
	
def alpha():
	
	return string.letters[:26]
	

process(string)

code by dads

Another approach without maketrans

txt = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
after = "".join([c.isalpha() and chr( ord('a') + ((ord(c)+2) - ord('a'))%26 ) or c for c in txt])
after
"i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that's why this text is so long. using string.maketrans() is recommended. now apply on the url."
code by tiezhen

A Python-inspired C++ Implementation

This is based on Python's maketrans(), which I didn't know about.

#include <string>
#include <algorithm>
#include <iostream>

struct Form
{
    // Convert from and to.
    std::string from;
    std::string to;

    std::string translate( std::string str )
    {
        typedef std::string::size_type Pos; // Position

        Pos i = 0;
        Pos end = str.size();

        while( i = str.find_first_of( from, i ),
                i != std::string::npos )
        {
            Pos i2 = from.find( str[i] );
            str[i] = to[i2];
            i++;
        }

        return str;
    }
};

int main()
{
    std::string s = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. "
                    "bmgle gr zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. "
                    "sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.";
    
    Form form = { "abcdefghijklmnopqrstuvwxyz", "cdefghijklmnopqrstuvwxyzab" };
    s = form.translate(s);

    std::cout << s << std::endl;

    return 0;
}
--SplinterOfChaos 22:21, 31 Dec 2008 (PST)

Beginner Python go

I had a go at this despite being completely new to Python and having never heard of maketrans before!

inputfile = open('./level1', 'r')
inputstring = inputfile.read()
a = ''
for i in inputstring:
	if ord(i) >= 97 and ord(i) <= 120:
		i = chr(ord(i) + 2)
	elif ord(i) == 121 or ord(i) == 122:
		i = chr(ord(i) - 24)
	a = a[:] + i
print a	





Worked fine! Surprising really.

my first program ever :)
'''python challange riddle 1'''
def trans(text):
	text=text.replace('k', 'm')
	text=text.replace('o', 'q')
	text=text.replace('e', 'g')
	return ord(text) +2
def to_text(ords):
	return chr(ords)
not_trans=map(trans,"map")
text=map(to_text, not_trans)
x=''
for each in text:
	x=x+each
print x
I'm in the same situation as the unsigned posters, new to python... had yet to discover string.maketrans. Code follows. Lashni 08:26, 1 Nov 2009 (PST)

for c in cryptstring:
	decode = chr(ord(c) + 2)
	if ord(decode) > 122:
		decode = chr(ord(decode) - 26)
	if ord(c) < 97:
		sys.stdout.write(c)
	else:
		sys.stdout.write(decode)
print
Should C# go here?

Did you play with mono csharp shell? Mono provide good way to use C# and I find it very funny when using this shell. Here is the code

using System;
string cString="g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. ".ToUpper();
char[] chArray=cString.ToCharArray();
for(int i=0;i<chArray.Length;i++)
{
	if(chArray[i]>=65&&chArray[i]<=90)
		chArray[i]=(char)((int)chArray[i]+2);
	if((int)chArray[i]>90)
		chArray[i]=(char)((int)chArray[i]-26);
}
Console.WriteLine(chArray);
Sorry for only printing the decrypted string, but as you can easily pull out the solution from this string, I just leave the sample code here in order to... solve other riddles :D.
Code by Namdx1987, 11:50PM (Bankok Time) Aug, 7th 2009

A sed implementation

As run under Win*

echo g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.|sed -e "y/abcdefghijklmnopqrstuvwxyz/cdefghijklmnopqrstuvwxyzab/"
LiHu 2009/09/08

Tcl Solution

set input "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. \
bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. \
sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
set str "abcdefghijklmnopqrstuvwxyz"
set map {}

for {set i 0} {$i < [string length $str]} { incr i} { 
    set map_char [string index $str [expr ($i + 2) % [string length $str]]]
    append map [string index $str $i] " " $map_char " "
}
set out [string map $map $input]
puts $out
Imad Sep, 30th 2009

Javascript solution

function translate(){
  var s = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. ";
  var a = "";
  for(var i = 0; i < s.length; i++){
    if ((s[i] != ' ') && (s[i] != '.')){
      if(s[i] == 'y'){
        a += 'a';
      } else if (s[i] == 'z'){
        a += 'b';
      }else{
        a += String.fromCharCode(s.charCodeAt(i)+2);
      }
    } else {
      a += s[i];
    }
  }
  alert(a);
}
Bolke 13th of October 2009

Netovs 12th of November 2009

Nestor Velazquez solution

message = "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
                       
def chars2bytes (string):
    return map(ord, string)

def bytes2chars (bytes):
    return "".join(map(chr, bytes))

def ccsubs (character):
    if ord(character) >= ord('a') and ord(character) <= ord('z'):
        return chr(((ord(character) - ord('a') + 2) % 26) + ord('a'))
    elif ord(character) >= ord('A') and ord(character) <= ord('Z'):
        return chr(((ord(character) - ord('A') + 2) % 26) + ord('A'))
    else:
        return character
              
def reemplaza(message):
    return "".join(map(ccsubs, message))

print reemplaza(message)
Netovs 12th of November 2009


A couple of lambdas

import string
lcase=string.lowercase

st1="g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."
st2='map'

decode_ch=lambda ch: lcase[(lcase.index(ch)+2) % 26] if (ch in lcase) else ch
decode_st=lambda st: "".join(decode_ch(ch) for ch in st)

print decode_st(st1)
print
print decode_st(st2)
symmetry 09th of January 2010


Not using maketrans

I am a newer,didn't know string.maketrans(),even chr and ord,so this is my solution

a="abcdefghijklmnopqrstuvwxyzab"
b="g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. "
c=""
for i in b:
    if i in a:
        c=c+a[a.index(i)+2]
    else:
        c=c+i
print c
--Caocaoyeah 09:54, 9 May 2010 (PDT)

Being a complete Newbie
a = 'c'
b = 'd'
c = 'e'
d = 'f'
e = 'g'
f = 'h'
g = 'i'
h = 'j'
i = 'k'
j = 'l'
k = 'm'
l = 'n'
m = 'o'
n = 'p'
o = 'q'
p = 'r'
q = 's'
r = 't'
s = 'u'
t = 'v'
u = 'w'
v = 'x'
w = 'y'
x = 'z'
y = 'a'
z = 'b'
print g+ f+ m+ n+ c+ w+ m+ s+ b+ g+ b+ l+ r+ r+ p+ y+ l+ q+ j+ y+ r+ c+ g+ r+ z+ w+ f+ y+ l+ b+ r+ f+ y+ r+ q+ u+ f+ y+ r+ a+ m+ k+ n+ s +r+ c+ p+ q+ y+ p+ c+ d+ m+ p+ b+ m+ g+ l+ e+ g+ r+ g+ l+ z+ w+ f+ y+ l+ b+ g+ q+ g+ l+ c+ d+ d+ g+ a+ g+ c+ l+ r+ y+ l+ b+ r+ f+ y+ r+ q+ u+ f+ w+ r+ f+ g+ q+ r+ c+ v+ r+ g+ q+ q+ m+ j+ m+ l+ e+ s +q + g + l+ e+ q +r +p+ g+ l+ e+ k +y +i +c +r +p +y +l +q +g +q +p +c +a +m +k +k +c +l +b +c +b +l +m +u +y +n +n +j +w +m +l +r +f +c +s +p +j
>>> ihopeyoudidnttranslateitbyhandthatswhatcomputersarefordoingitinbyhandisinefficientandthatswhythistextissolongusingstringmaketransisrecommendednowapplyontheurl

Not recommended... at all, but next level here i come. --TLopes 11:29, 21 Nov 2010 (PST)


My solution (C. Rodriguez):

def map2(s):
   def mp(c):
       letters=[chr(i) for i in range(97,123)]
       if c in letters:
           n = letters.index(c)+2-len(letters)
           return letters[n]
       else:
           return c
       
   return "".join([mp(i) for i in s])

MATLAB Solution

a='g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyrq ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq gq pcamkkclbcb. lmu ynnjw ml rfc spj. ';
letters='abcdefghijklmnopqrstuvwxyz';
for i=1:length(a)
    idx=find(a(i)==letters);
    if idx>=25
        idx=idx-26;
    end
    if isempty(idx)
        b(i)=a(i);
    else
        b(i)=letters(idx+2);
    end
end
b
J Solution

   data =. 0 : 0
g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. 
lmu ynnjw ml rfc spj.
)

   rot=. 4 : '{&((65 97+/~i.26)x&|.@[}i.256)&.(a.&i.)y'

   _2 rot data
i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that's why this text is so long. using string.maketrans() is recommended. 
now apply on the url. 

  _2 rot map
ocr

Racket Solution

#lang racket
(require srfi/13)

(define (translate str)
  (define A (char->integer #\a))
  (define (rotate x) (+ A (modulo (- x A -2) 26)))
  (regexp-replace* #rx#"[a-z]" str (ฆห (m) (bytes (rotate (bytes-ref m 0))))))

(translate " g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.")

(translate "map")
Python 3 ord() and maketrans() solution

There are probably better ways of doing this, but here is my solution two ways


def map_puzzle(a):
    ord_list = []
    answer = ''

    # populate ord_list with ord() values
    for i in a:
        # we don't want to translate the symbols
        if ord(i) < 65 or ord(i) > 122:
            ord_list.append(ord(i))
        else: # I know we don't have any UPPER case letters, but I'm translating them out anyways.
            if ord(i) == 89:
                ord_list.append(65)
            elif ord(i) == 90:
                ord_list.append(66)
            elif ord(i) == 121:
                ord_list.append(97)
            elif ord(i) == 122:
                ord_list.append(98)
            else:
                ord_list.append(ord(i)+2)

    for i in ord_list:
        answer += chr(i)

    return answer

def trans(a):
    # using the translated text, it recommends using maketrans()  this is my attempt at that.
    # I had to research string operations for python 3
    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    trans_alphabet = 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZAB'

    return a.translate(a.maketrans(alphabet, trans_alphabet))
    

test = '''g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.'''
print(map_puzzle(test))
print("ok, now for the url...Currently its 'map' translated it becomes: {0}".format(map_puzzle('map')))

print()
print("And now to try out the trans function...")
print(trans(test))
print(trans('map'))
Another Python 3 maketrans solution

Pretty simple and easy to read. Can read all inserted strings of said format.


#ROT2

#a > c
#b > d
#etc...

user_input = input("Enter a string to un-ROT2.")

i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
e = "CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab"

t = str.maketrans(i, e)

print (user_input.translate(t))

input("\n\nPress enter to continue.")

ECMAScript 5 solution

var key_one = 'abcdefghijklmnopqrstuvwxyz';
var key_two = 'cdefghijklmnopqrstuvwxyzab';
var key_obj = {};
for (var i = 0; i < 26; i += 1) {
    key_obj[key_one[i]] = key_two[i];
}
var coded_solution = "\
g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr \
amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr \
ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle \
qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.\
";
var solution = '';
for (var i = 0; i < coded_solution.length; i += 1) {
    if (key_obj[coded_solution[i]]) {
        solution = solution + key_obj[coded_solution[i]];
    }
    else {
        solution = solution + coded_solution[i];
    }
}
console.log(solution);
// Andy Short 2012
24.18.219.105 01:28, 7 January 2012 (PST)

____________ตฺถนุ________________________________________
Level2:Main Page
Challenge info
Title	ocr
URL	http://www.pythonchallenge.com/pc/def/ocr.html
Prev	 <restrlink>
Next	 <restrlink>
Contents [hide]
1 Rare characters = less frequent than average
1.1 One Pass Modification
2 other solutions...
3 Full solution, get source & open answer page
4 Rare character counts
5 An efficient and readable Python solution
6 Hmm
7 A complete solution without foreknowledge of the input data
8 Another way
9 Another very lucky way
10 Yet another way
11 Yet another another way
12 Yet another another another way
13 Yet another another another another way
14 Using Nested For Loops
15 Without Using Nested For Loops
16 Using sets
17 And once again using a shell on *nix
18 Another *nix version
19 Yet another *nix version
20 One-pass solution
21 The Dumb Luck Solution
22 A solution using ord and the ascii table, that does not use any of pythons string functions
23 The shortest way
24 Leal's solution
25 More generic solution
26 Who says python has only one way to do things?
27 Another solution
28 And again, another solution
29 A one-pass method
30 A VB.Net solution
31 a straightforward one
32 The Nested Loop Solution
33 A Haskell solution
34 Simple
35 Powershell
36 Yet ANOTHER Way, albeit very slow, it is very easy to understand
37 A shorter solution using filter()
38 A hacked-to-hell Ruby solution
39 Ruby solution
40 A legible Ruby solution (Analogue to first python solution)
41 Permutations: Yet Another Turn
42 Leaning on frequencies
43 Lambda solution the hard way
44 Simpler Regex
45 PHP Solution
46 Another PHP Solution
47 COMPLETE SOLUTION (IN PERL)
48 Erlang Solutions
49 ActionScript solution
50 Python List Comprehension One Liner
51 Python List Comprehension One Liner, without knowledge of characters
52 Groovy Solution
53 Groovy Alternate Solution
54 Complete Python solution without foreknowledge of the input data in one line
55 Simple solution using python
56 Complete solution in ruby
57 Solution in Scala (frequency based, with tests)
58 Accidentally cheated with emacs
59 Having fun with Mono C# in mono csharp shell
60 Dummy solution in python
61 A C solution
62 Let's not assume anything! (Python)
63 Another method (Python)
64 Method & Process
65 My method(Python)
66 Tree Lines Python Solution
67 A Python one
68 Python 3 methods
69 Another Python Regex
70 Direct URL access approach
71 Pythonic simplicity
72 Scala, but briefly
73 Using Beautiful Soup
74 Simple Extraction
75 Alphanumeric Characters Only (very simple)
76 Racket solution
77 Factor solution
78 PHP Solution
79 yap, yap, Yet Another Python, You Always Prefer
80 Yet another solution with filter
81 Another solution with list and dict
82 Very Easy Method
83 Just Plug In the URL
84 ECMAScript 5 solution
85 C# solution
86 Java solution
Rare characters = less frequent than average

We must look for rare characters hidden among a mess (copy-paste from web page source to file ocr.txt). The trick is to consider "rare characters" as those whose number of occurrences is below average in this particular text. No assumptions should be made about the nature of these characters other than that they must be "infrequent" and url-compliant (that is, spaces and carriage returns should be discarded).

The algorithm: slurp text, loop over it using a dictionary to count the occurrences of each character, compute global average of occurrences (i.e. total chars / distinct chars), loop again printing just those characters whose frequency is below average. Python allows for a very compact but quite readable implementation:

s = ''.join([line.rstrip() for line in open('ocr.txt')])    
OCCURRENCES = {}
for c in s: OCCURRENCES[c] = OCCURRENCES.get(c, 0) + 1
avgOC = len(s) // len(OCCURRENCES)
print ''.join([c for c in s if OCCURRENCES[c] < avgOC])                # equality
One Pass Modification
We pass data first to find the letters, and pass ALL data again just to print them in the right order. Using OrderedDict, we can avoid going through the data while printing: note we go over OCCURENCES, not s Here is a One pass modification.

    data = ''.join([line.rstrip() for line in open('ocr.txt')])    
    OCCURRENCES = collections.OrderedDict()
    for c in data: OCCURRENCES[c] = OCCURRENCES.get(c, 0) + 1
    avgOC = len(data) // len(OCCURRENCES)
    print ''.join([c for c in OCCURRENCES if OCCURRENCES[c] < avgOC]) 
Don't forget to import.collections ;-)

other solutions...

The hint tells us to look at the page source for rare characters. Load the text into a variable named text.

>>> import string
>>> filter(lambda x: x in string.letters, text)
'equality'
So the next url is equality.html

How do you find "rare characters" to begin with? Here's one way:

guts = open("data.txt").read()
d = {}
for ch in guts:
    d[ch] = d.get(ch, 0) + 1
Now d maps each character to a count of the number of times it appears. Looking at that makes it clear that some characters appear thousands of times, but some appear only once. The ones that appear only once can be extracted, in the order they appear, and joined into a string like so:

print "".join(ch for ch in guts if d[ch] == 1) # requires Python 2.4
I just repeated what I did in the previous challenge

trans = string.maketrans(string.printable,string.printable) result=string.translate(text,trans,string.punctuation+'\n') 'equality'

Full solution, get source & open answer page

from string import ascii_letters
import re, urllib2, webbrowser as wb
wb.open('http://www.pythonchallenge.com/pc/def/%s.html' %
        .join(chr for chr in
        re.findall(,
        urllib2.urlopen('http://www.pythonchallenge.com/pc/def/ocr.html')
        .read(), re.S)[1] if chr in ascii_letters))
Rare character counts

Assuming that a character could be anything, not just alphanumeric, I used the Python .count member, and printed characters that were rare (less than 20 occurrences).

>>> for a in text:
...    l = text.count(a)
...    if l < 20:
...       print a, ":", l
...
e : 1
q : 1
u : 1
a : 1
l : 1
i : 1
t : 1
y : 1
>>>
Voila!

MarkW ---

Your solution seems to be O(n^2), which is not very efficient. I still prefer to avoid calling .count() for every character, as it won't be very fast. --CrazyTerabyte 18:00, 3 Dec 2008 (PST)
I also used this method. The fact that my six year old laptop runs this code runs in the blink of an eye seems to suggest that speed isn't a massive issue here. Readability counts! --Jiub

I did something similar except I made a "counted" list that recorded all the characters I had already counted and only performed .count() if a wasn't in that list. That way it only ran .count() once for each unique character instead of each character period. --Chad

Chad, that works in this case, but only because there were no repeats for the characters in equality. If there were, your program would disregard the second occurance of that character. For example, if the word were "book", it would see b and add it, and then see o and add it. However, when it saw the second o, it would see that it had already counted the Os and move on. You would get bok instead of book. That being said, in this case it would serve to maximize efficiency. I would suggest modifying it to add to the "counted" list only the characters which were deemed not rare. --bMacSwigg

bMacSwigg: It is supposed to work that way. Once a character has been counted, it shouldn't be counted again.

An efficient and readable Python solution

text = ...   # the long string found in the source code of the page
output = "" # empty string
counts = {}
for c in text:
  if counts.has_key(c):
    continue
  counts[c] = text.count(c)
  if counts[c] < 100:  # guess that rare characters will occur less than 100 times
    output += c

print output
RaphaelK - Raphael Krausz

Hmm

I used the following method to generalize the problem of finding rare characters:

CharDict = {}
for i in text:
    if CharDict.has_key(i):
        CharDict[i] = (CharDict.get(i) + 1)
    else:
        CharDict[i] = 1
UncleTimmy sez: How does this differ from the method already presented above, except in being longer?

At this point visual examination of CharDict gives me:

>>> CharDict
{'\n': 1219, '!': 6079, '#': 6115, '%': 6104, '$': 6046, '&': 6043,
 ')': 6186, '(': 6154, '+': 6066, '*': 6034, '@': 6157, '[': 6108, ']': 6152,
 '_': 6112, '^': 6030, 'a': 1, 'e': 1, 'i': 1, 'l': 1, 'q': 1, 'u': 1,
 't': 1, 'y': 1, '{': 6046, '}': 6105}
Here I simply did a cut and paste (blush), but there must be a more elegant way of extracting a string of values present less than n times:

low = ['a', 'e', 'i', 'l', 'q', 'u', 't', 'y']
Actually, this would be an easy way to create the list 'low':

>>> for (char,value) in CharDict.items():
...    if value < 10:   #  where 10 is an arbitrarily chosen 'low'limit
...        low.append(char)
And there definitely must be a better way of using the string:

>>> for i in text:
...    if i in low:
...        print i
e
q
u
a
l
i
t
y
UncleTimmy sez: A one-line method to use a character->count dict was also given above.

A complete solution without foreknowledge of the input data

filename = "level2.txt"
charlist = [chr(x) for x in range(1,256)] 
# list of all possible ASCII characters.  This is a 'list comprehension', 
# a fast and easy way to make lists in Python.  It's sort of an embedded for loop.  
# You'll see this a lot. It's one of Python's core workhorses.
# note: you can improve the runtime a LOT if you use the 'set' function right below this one; 
# 26 loops instead of 255 is a big win.
rarelevel =  5 
# the 'rare' characters are actually unique, so '1' would work, 
# but you couldn't know that ahead of time
data = open(filename).read()
# load the whole file into data
uniques = []
# now: loop through charlist, and count how many times each character appears.  
# Python is fairly slow with strings, so reducing the number of searches will
# improve runtime a lot.  The other major approach is to loop through the characters of 
# data, but that would require 100,000ish loops instead of 255.
for item in charlist:
    count = data.count(item)
    if (count <= rarelevel and count > 0):
    # you could also just use == 1 instead, but you can't know the data is 
    # unique ahead of time, just 'rare'. 
         uniques.append((data.find(item),item)) 
         # make a list of tuples, with position first, followed by the character.  
         # This makes it easy to sort... the list sort function sorts on the first
         # value in tuples.  
         # Storing as (string, location) makes more human sense, but then you have 
         # to write a custom function to sort the list. 
uniques.sort()  
# sorts the list in place
print "".join( [ x[1] for x in uniques ] ) 
# another list comprehension to extract the character values from uniques. 
# That gets dumped into the 'join' method of an empty string, gluing the 
# list members together with nothing in between them.
# This would be much longer in most other languages; that line packs a punch.

Another way

Just for the record, here's my idea:

>>> mess = open("data.txt").read()
>>> mess.translate(string.maketrans("",""),"[]{}()#$%^@+!*&_").replace("\n","")
'equality'
Yes, I know it's ugly.

Or even smaller :

>>> mess.translate (None, '%$()[]{}+_@^!*&#\n')

Another very lucky way

data=open(pathfile,"r").read()
tab=[]
for car in data:
    if tab.count(car)==0:
        tab.append(car)
print tab
ahaha !!!

  ['%', '$', '@', '_', '^', '#', ')', '&', '!', '+', ']', '*', '}', '[', '(', '{', '\n', 
  'e', 'q', 'u', 'a', 'l', 'i', 't', 'y']
Yet another way

Instead of focusing on the word "rare" I went with the word "characters", and came up with this simple script:

print "".join([char for char in text if char.isalpha()])
Where text holds the data from the page

Yet another another way

>>> import re
>>> str2 = open("text").read()
>>> print re.findall(r'[a-z]', str2)
['e', 'q', 'u', 'a', 'l', 'i', 't', 'y']
Yet another another another way

>>> import re
>>> str = open("challenge2.txt").read()
>>> print re.sub('[^a-z]', '', str)
equality
Yet another another another another way

>>> from string import letters
>>> ''.join([x for x in s if x in letters])
'equality'
Using Nested For Loops

>>>slop = """ *^%^%$& gibberish ^%*&^(^&*%# """
>>>for x in slop:
        for y in "abcdefghijklmnopqrstuv":
             if x == y:
                  print x,
Without Using Nested For Loops

>>> text = """
             <copy and paste>
"""
>>> import string
>>> for i in text:
        if i in string.ascii_letters:
        print i,

Using sets

>>> text = open("text").read()
>>> checklist = set(text)
>>> for i in checklist:
>>>     print i, text.count(i)
>>> #Common sense starts here
And once again using a shell on *nix

get the source file

pipe it through tr -d (delete) with the first line (duplicates should be in it..) and a line break (\n)

curl http://www.pythonchallenge.com/pc/def/ocr.html | tr -d '%%$@_$^__#)^)&!_+]!*@&^}@[@%]()%+$&[(_@%+%$*^@$^!+]!&_#)_*}{}}!}_]$[%}@[{_@#_^{*\n'
-> garbage [..] <--equality-->
or

curl http://www.pythonchallenge.com/pc/def/ocr.html | tr -dc 'a-zA-Z'
Another *nix version

curl http://www.pythonchallenge.com/pc/def/ocr.html | grep -o [a-z]
Output is vertical, but still reasonably easy to read

Yet another *nix version

curl http://www.pythonchallenge.com/pc/def/ocr.html |sed '/html/,/below/d'| sed 's/[^a-z]//g; s/^[\t]*//;s/[ \t]*$//' | sed ':a;N;$!ba;s/\n/ /g' | sed 's/ //g'
Ignore everything between html and below.
Get rid of all the non-letters.
Get rid of all those new lines, blank lines, and spaces.
Donnied 11:18, 27 Jun 2008 (PDT)

One-pass solution

There is a finite number of character, but potentialy large input. Note that this only works if each rare character appears exactly once.

data = open('data.txt').read()

o = {}
chars = []
for ch in data:
  try:
    o[ch] += 1
  except KeyError:
    o[ch] = 1
    chars.append(ch)

treshhold = 5
print ''.join([ch for ch in chars if o[ch] <= treshhold])
The Dumb Luck Solution

Disclaimer: I didn't do this in Python, but I'm sure it would be easy.

I'd planned on going through and doing character counts and such, but figured I'd have a quick look for alphanumeric characters before I went through all the trouble. Using a simple regular expression, I threw away everything that matched [^a-zA-Z0-9], and the solution popped right up. Perhaps it would be more difficult if there was some alphanumeric white noise with high character counts. This is very similar to the "Another *nix version" above.

A solution using ord and the ascii table, that does not use any of pythons string functions

   file = open('text', 'r')
   text = file.read()
   file.close()
   output = 
   for char in text:
       if (ord(char) > 64 and ord(char) < 91) or (ord(char) > 96 and ord(char) < 123 ):
           output += char
   print output
The shortest way

I solved this by piping the page comment to:

 perl -pe 's/[^a-z]//g'
or possibly even:

 tr -cd a-z
Leal's solution

 ocr = """ THOSE UNREADABLE NOTIONS FROM HTML SOURCE """
 
 for x in ocr:
   if x.isalpha():
     print x,

More generic solution

Keeps rare characters ordering, doesn't rely on them being letters. Making the threshold (10) generic as well is still a problem though ...

 s = file('ocr').read()
 d = []
 
 while s != "":
     d.append((s[0], s.count(s[0])))
     s = s.replace(s[0], "")
 
 print "".join([t[0] for t in d if t[1] < 10])

Vazovsky

To calculate threshold value depending on the context you can make following modifications to the program.

Add a new variable. This variable will store original text length.

 text_len = len(s)
And modify print statement.

 print "".join([t[0] for t in d if t[1] <  text_len // len(d)])
In this case threshold value will be equal to the average of occurrence frequency of all characters in the text. The modified check in print statement assumes that "rare" mean - with occurrence frequency below average.

Who says python has only one way to do things?

 fd = open('ocr.txt', 'r')
 s = fd.read()
 fd.close()
Count the printable characters:

 l = [ s.count(chr(i)) for i in range(33,128) ]
That count() method is really fast! I hadn't realized it was there, but it goes back to 1.5.2, at least.
By inspection, it's clear that the counts are zero, one, or >6000. Pull out the single counts:

 >>> ll = []
 >>> for i in range(len(l)):
 ...  if l[i] == 1:
 ...   ll.append( ( chr(i+33), s.index( chr(i+33) ) ) )
I got snagged here for a bit. I didn't realize I had the single count letters out of order. So sort them according to occurrance in the original string:
It helps a lot that the "rare" characters only show up once!

 ll.sort(lambda a,b: cmp(a[1], b[1]))
Finally, inspect the result:

 "".join( [ i[0] for i in ll ])
 'equality'
This isn't the simplest or shortest method, and it's actually slower, too. But it seems more natural to me, and demonstrates some language features to boot. Go Python!
If the input had contained something approximating every printable character, then this approach would be faster.

Another solution

Import a module: import string

Firstly you need to save the relevant part of the page source to a file, in this case we used ocr.txt. We then passed the file into a variable:

 ocr = file("ocr.txt").read()
String.punctuation has all the characters that you need bar the '\n', so you just need to add that at the end.

 punc = string.punctuation+"\n"
A blank translation table to keep things happy.

 tr = string.maketrans("","")
The line that does all the work. Pass the table and the variable with all the unwanted characters through translate.

 ocr.translate(tr, punc)
--Matt 15:00, 23 Mar 2006 (MST)

And again, another solution

Set the text variable to the text in the source page and:

 import string
 while text != "" :
 	print(text[0], string.count(text, text[0]))
 	text = string.replace(text, text[0], "")
In each iteraction, there will be less characters to find and replace. The return of this will be tuples with all the characters and number of ocurrences. The non rare characters will show up first, followed by the answer, in correct order. :-)

A one-pass method

 ocr = """cut-n-paste"""
 freq = {}          # frequency of each character
 chars = ""         # order each char is encountered in the ocr text
 for i in ocr:
   if i in freq:
     freq[i] += 1
   else:
     freq[i] = 1
     chars += i
 print freq
 print chars
I then planned to go through chars and pull only those with frequency 1, but as soon as I printed it the answer jumped right out. I didn't see the trick of recording each char only the first time it occurred, combined with the frequency table to be sure it only occurred once, in any of the solutions above (there's a "one-pass solution" above, but it doesn't check the frequency)

A VB.Net solution

Don't laugh, I'm feeding my family using VB.Net/ASP.Net.

Test.txt contains the text from the HTML source. 'equality' would be displayed on the console after running the program below.

 Sub Main()
     Dim fileContents As String
     fileContents = My.Computer.FileSystem.ReadAllText("C:\Documents and Settings\Andy\Desktop\Test.txt")
     For Each c As Char In fileContents.ToCharArray
         If Char.IsLetter(c) Then
             Console.WriteLine(c)
         End If
     Next
     Console.ReadLine()
 End Sub
'A solution with Visual Studio 2008 (using LINQ)

   Function Problema(ByVal Caracteres As String) As String
       Dim VAR As IEnumerable(Of Char) = From X In Caracteres Join ar In "abcdefghijklmnopqrstuwxyzABCDEFGHIJKLMNOPQRSTUWXYZ" On ar Equals X Select X
       For Each i As Char In VAR
           Problema += i
       Next
       Return Problema
   End Function
a straightforward one

 import urllib
 f=urllib.urlopen('http://www.pythonchallenge.com/pc/def/ocr.html')
 txt=f.read()
 for c in '!@#$%^&*()+_-{}[]\n':
   txt = txt.replace(c,"")
 print txt

The Nested Loop Solution

This looks through and counts the number of time each of the characters appear in the string. First,it checks if it's the first time it encounters the particular character.It adds the character to the list,w on its first encounter so that it won't have to count it again the next pass. Taking the character,the inner for loop checks for the number of time the character appears. The results are then printed out.

 for chc in list(q):                   #q is the large string that contains all the characters
        if chc not in w:               #w starts as an empty list.checks if character has been counted
                 i = 0
                 w.append(chc)         #adds the character to list w to avoid repetition
                 for ch in list(q):
                         if chc == ch:
                                i += 1
                 print chc, '=', i
        else:
             pass

david seres:

here again the solution for R:

ocr <- url("http://www.pythonchallenge.com/pc/def/ocr.html")
open(ocr)
readLines(ocr, 36)                      # this is necessary to remove the html coding
x<-readLines(ocr)                       # now it will only read the "mess"

ocr <- gsub ("[ [:punct:] ]", "", x)    # this replaces every punctuation into an empty chain (i.e. only the alphabetic
                                          characters will stay)

paste (ocr, sep = "", collapse = "")    # now i paste the rest together and voila, the word we're looking for is:
[1] "equality"
A Haskell solution

   Prelude Data.Char> (\fp->readFile fp >>=  (\x->return $ filter  isLetter  x)) "/Users/Phas/clob"
   "equality""
--Phas 11:15, 31 Mar 2007 (MDT)

A better haskell solution, with respect to the clue:

import qualified Data.Map as M

ocr = do
    s <- readFile "ocr.txt"
    let f = filter (`elem` (M.keys $ M.filter (== 1) $ foldl (\m c -> M.alter (\m -> case m of {Just x -> Just (x + 1); Nothing -> Just 1}) c m) M.empty s)) s
    return f
--Povman 02:07, 6 Apr 2008 (PDT)

Simple

A simple and fast way to find unique characters:

 >>> print set("""<- lots of text ->""")
 set(['\n', '!', '#', '%', '$', '&', ')', '(', '+', '*', '@', '[', ']', '_', '^', 'a', 'e', 'i', 'l', 'q', 'u', 't', 'y', '{', '}'])
Masterdriverz 07:34, 14 May 2007 (MDT)

Why stop there? You don't even know the answer at this point!

>>> d = dict() # Every unique character and how often they appear.
>>> for c in set( s ): # s = the text
	d[c] = s.count(c)

>>> d # Spaces added.
{'\n': 1219, '!': 6079, '#': 6115, '%': 6104, '$': 6046, '&': 6043, ')': 6186, '(': 6154, '+': 6066, '*': 6034, 
'@': 6157, '[': 6108, ']': 6152, '_': 6112, '^': 6030, 
'a': 1, 'e': 1, 'i': 1, 'l': 1, 'q': 1, 'u': 1, 't': 1, 'y': 1, '{': 6046, '}': 6105}

>>> # It is now obvious how often the rare ones pop up.
>>> rareCount = 1

>>> # (mostly) copied from the solution "Leaning on frequencies":
>>> ''.join( [c for c in s if d[c] == rareCount ] )
Powershell

An One-liner in powershell

   [string] [char[]] ($( [char[]] [string] $(get-Content -path c:\ocr.txt) )|?{$_ -like "[a-z]"})
Yet ANOTHER Way, albeit very slow, it is very easy to understand

characterset = <jumbled HTML mess> print characterset.count("a")

print characterset.count("b")

...

print characterset.count("z") Now you have the letters:

aeilquty

Now you have to arrange them...I don't really know how to get the computer to do that. (I'm still new at all this!)

n.b. it may be more fun to use pencil&paper and tally each character.

A shorter solution using filter()

filter(str.isalpha, data)
A hacked-to-hell Ruby solution

 IO.read(filename).split(//).uniq.delete_if { |ch| ch !~ /[a-z]/ }.to_s
Ruby solution

 ARGF.read.scan(/[a-z]/).join
Works, but makes a lot of assumptions

A legible Ruby solution (Analogue to first python solution)

 text = ARGF.read # ARGF.read reads from stdin until eof
 char_freq = Hash.new(0) # create a hash with zeros
 text.each_char {|char| char_freq[char.to_sym] += 1 unless char == "\n" } # using symbols because it is cheaper (memory wise)
 average = text.size / char_freq.size                                                                                                                                 
 puts char_freq.select{|char,freq| freq < average}.keys.join #=> equality
This version does not make any consideration about character types, and gets its input from STDIN, whatever it may be (file or direct input). The letters may not appear in a correct order on versions prior to Ruby 1.9, since before 1.9 hashes weren't ordered.

--Teonimesic 12:42, 13 Jul 2010 (PDT)

Permutations: Yet Another Turn

The challenge is about finding "rare CHARACTERS", and all we know is that they must be url-compatible. I think that many of the solutions listed in this page are not actually solving this challenge as stated in the page: this is NOT about the shortest way of finding [a-z] in a text, instead we were challenged to reconstruct a hidden message according to the number of occurrences of ANY CHARACTER in the text (be it a letter, a number or any other bizarre ascii character that is url-compatible and infrequent enough); let's see, what is it that makes a character "rare"? in this case any character with a frequency below the AVERAGE number of appearances of the characters that form the given text should be considered. The average is the total number of characters divided by the number of different characters.

A dictionary seems the most natural Python construct to compute the frequency of appearance but a second problem arises because the original ORDER of characters is lost when traversing it. The required word wasn't clear from the first result set (see listing), so after some unsuccessful trial and error by hand I found and used a cool short recursive function (unfortunately obscure to me as only recursive functions can get) borrowed from http://www.daniweb.com/code/snippet459.html (thanks Google) to calculate all the possible permutations of those characters and then had Python look for a valid (non-404) url among them (uff!)

All this can be expressed in just a few lines of Python code (great proof of its expressive power), but it's quite a heavy task since the count for permutations of 8 different characters turns out to be 8! = 40320 urls... sorry for my small abuse on your server's bandwidth guys but maybe you shoud have given a more detailed hint about the nature of the hidden message... and hey, you deserve it for forcing me into unpaid-late-night-programming. Thanks for the fun!!

import string
from urllib import urlopen

s = open('mess.txt').read()

# '\n' is infrequent but not acceptable for urls, must be "chomped"
s = s.replace('\n','')   

chars = {}  # one dictionary to rule them all...
for c in s:
  chars[c] = chars.get(c, 0) + 1

# compute average
average = len(s) / len(chars)

# filter "rare" characters
r = [c for c in chars.keys() if chars[c] < average]

# r = ['a', 'e', 'i', 'l', 'q', 'u', 't', 'y']; let's permutate...

def permutate(seq):
    if not seq:
        return [seq]  # is an empty sequence
    else:
        temp = []
        for k in range(len(seq)):
            part = seq[:k] + seq[k+1:]
            for m in permutate(part):
                temp.append(seq[k:k+1] + m)
        return temp
    
for d in permutate(r):
  url = "http://www.pythonchallenge.com/pc/def/%s.html" % string.join(d,'')
  # probably some exception handling would be more adequate here than a simple text search...
  s = urlopen(url).read()
  if s.find('404 Not Found')>=0:   
    print url + " NO-NO..."
  else:
    print "YESSS!!!: " + url
    break


Leaning on frequencies

I agree with the previous suggestion, the clue was about frequency, not the fact that the characters are letters.

So, I wrote a function to calculate the frequency of letters in a string (or elements of a sequence):

 from collections import defaultdict
 def freq(sequence):
   d = defaultdict(int)
   for element in sequence: d[element] += 1
   return d
 
Then I just cut and pasted the content into a file called "text.txt" and did:

 text = open('text.txt').read()
Now we look at the frequency of the letters:

 fq = freq(text)
 
So, what kind of stuff do we have in the keys? Let's just see what we're dealing with...

 >>> set(fq.keys())
 set(['\n', '!', '#', '%', '$', '&', ')', '(', '+', '*', '@', '[', ']', '_', '^', 'a', 'e', 'i', 'l', 'q', 'u', 't', 'y', '{', '}'])
But order is lost. What kind of frequencies are we looking at?

 >>> set(fq.values())
 set([6112, 1, 6115, 1221, 6152, 6186, 6034, 6030, 6157, 6066, 6104, 6105, 6043, 6108, 6154, 6046, 6079])
Hmm, it's either 1 or 6000+. So, let's go through the original text looking for letters with a frequency of 1:

 >>> [c for c in text if fq[c] == 1 ]  
 ['e', 'q', 'u', 'a', 'l', 'i', 't', 'y']
Rah!

Lambda solution the hard way

Not quite as easy as the first lambda solution but it worked.

    >>>infile = open('r:\challenge.txt', "r")
    content = infile.read()
    content = filter(lambda c: c not in "@&#][+%^()_!$*{}", content)
    print content
I went through and slowly added the characters that repeated. You can obviously pick out a few at the start that you see repeating right away then add as you go and rerun.


Simpler Regex

The simplest regex I could think of was:

 >>> print re.sub( "[^\w]|_", "", data )
Or:

 >>> print re.sub('[^a-z]', , data)
PHP Solution

I saved the data in a file named "r2.txt", then ran the following code on it to determine the what the rare characters were:

$Str = file_get_contents("r2.txt");
$Counts = count_chars($Str);
foreach ($Counts as $Char => $Count)
    if ($Count > 0)
        echo chr($Char)."=$Count\n";
After I found the characters I ran:

$Str = file_get_contents("r2.txt");
$Str = preg_replace("/[^aeilqtuy]/", "", $Str);
echo "$Str\n";
Leper421 18:27, 20 Feb 2008 (PST)

Simple PHP solution with RegX:-

$str='THE STRING FROM SOURCECODE';
$new_string = ereg_replace("[^A-Za-z]", "", $str); 
echo $new_string;
--Naresh 23:58, 19 Jan 2011 (PST)

Another PHP Solution

$text = "PUT THE TEXT HERE";
$answer = strtr($text,"$()@[]{}^&%#_!*+","                ");
echo trim($answer);
This will replace all those characters with spaces and then clean whitespaces using trim().

--Mert Yaz?c?o?lu

COMPLETE SOLUTION (IN PERL)

#!/usr/bin/perl -w
use LWP::Simple;
$input = get "http://www.pythonchallenge.com/pc/def/ocr.html";
$intag = !1;
$incomment = !1;
$inmess = !1;
@inputchars = split(//, $input);
foreach(@inputchars)
{
   if ($incomment)
   {
      if ($_ eq ">")
      {
         $incomment = !1;
      } elsif ($inmess) {
         if (m/[a-zA-Z0-9]/)
         {
            print $_;
         }
      } else {
         if ($_ eq ":") {
            $inmess = 1;
         }
      }
   } elsif ($intag) {
      if ($_ eq "!")
      {
         $incomment = 1;
      } else {
         $intag = !1;
      }
   } else {
      if ($_ eq "<")
      {
         $intag = 1;
      }
   }
}
print "\n";
This is once again an entire solution that works from the page source so there is no need to give any input or do anything at all for that matter - just copy, paste and run! This is not a general solution but it fully works for this particular challenge!

Erlang Solutions

First a solution based on rare characters (v3):

c2_rare() ->
  {ok, Binary} = file:read_file("ocr.txt"),
  lists:map(fun ({K, _}) -> K end, 
    lists:filter(fun ({_,Freq}) -> Freq == 1 end, 
      lists:foldl(fun counter/2, [], binary_to_list(Binary)))).

counter(Key, KeyList) ->
  case lists:keysearch(Key, 1, KeyList) of
    false -> NewFreq = 1;
    {value, {Key, Freq}} -> NewFreq = Freq + 1
  end,
  lists:keystore(Key, 1, KeyList, {Key, NewFreq}).
After seeing the first solution here I did one based on alpha characters (v2):

c2_char() ->
  {ok, Binary} = file:read_file("ocr.txt"),
  lists:filter(fun (Char) -> (Char >= $a) and (Char =< $z) end, binary_to_list(Binary)).
-- akafred 14:15, 23 May 2008 (PDT)

ActionScript solution

var crypt = //insert puzzle here
var solved:String = "";

for (var i = 0; i <= crypt.length; i++){
	var thisChar:int = crypt.charCodeAt(i);
	if ((thisChar >= 97 && thisChar <= 122) || (thisChar <=90 && thisChar >= 65)) // if thisChar is a letter
		solved += crypt.charAt(i);
}
trace(solved);
Python List Comprehension One Liner

>>> str = """Long String of Characters"""
>>> [x for x in str if x.isalpha()]
['e', 'q', 'u', 'a', 'l', 'i', 't', 'y']
Python List Comprehension One Liner, without knowledge of characters

>>> string = """Long String of Characters"""
>>> "".join[x for x in string if string.count(x) < 5]
Groovy Solution

#!/usr/bin/env groovy
#Code by tek
map = [:]
new File("in").eachLine{ linea->
	linea.each{ caracter->
		if(map[caracter] == null)
			map[caracter] = 0 
		else
			map[caracter] += 1
	}
}
println map
Groovy Alternate Solution

new File("solutionTwo.txt").getText().each {
    if(Character.isLetter(it.toCharacter())) {
        print it
    }
}
return
Complete Python solution without foreknowledge of the input data in one line

(lambda text, treshhold :"".join([c[0] for c in sorted([c for c in [  (x.setdefault(c, [0, x[0]]), x.update({c: [x.setdefault(c, [0, x[0]])[0]+1, x[0]] }), x, x.update({0:x[0]+1}))[2] for x in ({0:0},) for c in text][0].items()[1:] if c[1][0]<treshhold], lambda x,y: cmp(x[1][1], y[1][1]))]))("""put the mess here""", 5)

Simple solution using python

#!/usr/bin/env python
# First you have to copy all the messy text from the web page 
# source code and put it in a new file 'ch2.txt'.

f = open('ch2.txt', 'r')
result = ''

a = f.read()

for i in a:
    res = i.isalpha()
    if res == True:
        result += i

print result

Complete solution in ruby

#!/usr/bin/env ruby

char_dict = {}
char_dict.default=0

texts = File.open("data02.txt").read.split(//)

texts.each {|c| char_dict[c]+=1}

rare_list = char_dict.sort_by { |p| p[1] } \
                .select {|(k,v)| v==1} \
                .collect {|(k,v)| k}

puts texts.select {|c| rare_list.include? c}.join
Solution in Scala (frequency based, with tests)

  test("character frequencies are returned in lowest to highest order") {
    val rarestChars = getRarestChars("AAAABBBCCD")

    rarestChars(0) should equal ('D' -> 1)
    rarestChars(1) should equal ('C' -> 2)
    rarestChars(2) should equal ('B' -> 3)
    rarestChars(3) should equal ('A' -> 4)
  }

  test("for same frequencies, output order is dependent on input order") {
    val rarestChars = getRarestChars("abcd")

    rarestChars(0) should equal ('a' -> 1)
    rarestChars(1) should equal ('b' -> 1)
    rarestChars(2) should equal ('c' -> 1)
    rarestChars(3) should equal ('d' -> 1)
  }

   def getRarestChars(charInput: String) = {
		   def getRarestCharsHelper(inputChars:List[Char], mapOfCounts: Map[Char, Int]): Map[Char, Int] = {
				   
				   if (inputChars.isEmpty) {
					   return mapOfCounts
				   }
				   
				   val charVal = inputChars.head
				   val charCount:Int = mapOfCounts.getOrElse(charVal, 0)
				   val newMap = mapOfCounts + (charVal -> (charCount + 1))
				   getRarestCharsHelper(inputChars.tail, newMap)
		   }
     
	 val rarestCharMap = getRarestCharsHelper(charInput.toList, LinkedHashMap[Char, Int]())
         rarestCharMap.toList.filter(_._2 < 5)
   }
Accidentally cheated with emacs

I put the text into emacs, then used ctrl + [right arrow] to navigate, which took me right to the next letter without another letter in front of it each time I used it.

Having fun with Mono C# in mono csharp shell

Alright, using List<char> then we have these code:


using System;
using System.Collections.Generic;

string mess=@"
<Just copy and pass the mess here>
";

char[] arr=mess.ToCharArray();

List<char> allChars=new List<char>();
List<char> filteredChars=new List<char>();


foreach(char c in arr)
{
	if(allChars.Contains(c))
	{
		if(filteredChars.Contains(c))
			filteredChars.Remove(c);
	}
	else
	{
		allChars.Add(c);
		filteredChars.Add(c);
	}
}

Console.WriteLine(new string(filteredChars.ToArray()));
Code by Namdx1987

Dummy solution in python

import urllib
import string

#You should see the source code to realize that you get an array of 3 elements if you make split('<!--') 
s = urllib.urlopen('http://www.pythonchallenge.com/pc/def/ocr.html').read().split('<!--')[2] 

print ''.join([x for x in s if x in string.letters])
A C solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
	int i=0;
	int j=0;
	char* result;
	char* p;
	char* m;
	int a=0;
	int c=0;
	result=malloc(100000*sizeof(char));
	m=malloc(256*sizeof(char));
	FILE *fichier;
	fichier=fopen("enigme3.txt","r"); //enigme3.txt is the file containing the sequence of characters
	if (fichier != NULL)
	{
		p=result;
		while (!feof (fichier))
			fscanf(fichier,"%c",p++);
		fclose(fichier);
	}
	for (i=0;i<100000;i++)
	{
		a=0;
		for (j=0;j<256;j++)
		{
			if (result[i]!=m[j])
			{
				a++;
			}
			if (a==256)
			{
				m[c]=result[i];
				c++;
			}
		}
	}
	printf("%s",m);
	return 0;
}
Code by GoorhT

Let's not assume anything! (Python)

A lot of the solutions here assume several things (or stop short of making the code generalized enough to always work).

1) As several have mentioned before: We don't really know if the caharacters are only alpahbet letters. We only know they are rare and they are URL compliant.

2) As was mentioned earlier, we don't know really what 'rare' means. We are left to make the definition up. I chose to use 'less than average.'

3) Every solution in Python which relied on frequencies rather than just alphabet characters has assumed the characters are found in the word only once. What if the word was 'area' where the 'a' is used twice? You would need to capture that fact and put the characters back in their proper order and frequency.

4) Some of the solutions which thought about some of these concepts stopped thinking at the end, relying on failed page requests to un-mix the word or manually reviewing the results.

So here is my code, which takes all that into account, I think it would be generic enough to work in most cases... It is a single pass over the source string, generating a character -> location map. The map doubles as both a location map and a frequency map. The locations are used later to re-map the characters to their original order, while the count of locations is used to filter out high-frequency characters. After finding rare characters they are passed through a filter which removes non-url-compliant characters, keeping ascii letters, numbers, and a few puntuation parks that are allowed.

import string

def make_location_map(input_string):
#Provides a mapping of characters to a list of their location in the input
	loc_map = {}
	for index in xrange(len(input_string)):
		char = input_string[index]
		loc_list = loc_map.get(char, [])
		loc_list.append(index)== Another method (Python) ==

This program has one assumption, that the number of occurence of rare characters is same. 
<pre>
min_occur = ''
char = []        # to hold the unique variables in the multiline text
char_count = []  # to hold the count of those variables)
ind = 0
with open('E:/Documents/Python/Challenge_third.txt', 'r') as mess:
    for line in mess:
        for letter in range(0,len(line)):
            if line[letter] in char:
                j = char.index(line[letter])
                char_count[j] = char_count[j] + 1
            else:
                char.append(line[letter])    
                char_count.append(1)
mess.closed
min_value = min(char_count)
for i in char_count:
    if i == min_value:
        min_occur = min_occur + char[ind]
    ind = ind + 1
print min_occur
Any improvement for the above program is welcome. loc_map[char] = loc_list return loc_map

def find_rare_characters(rare_cutoff, character_locations):

Returns only characters which pass the 'rareness' threshold passed in
rare_characters = [char for char in iter(character_locations) if len(character_locations[char]) < rare_cutoff] return rare_characters

def filter_unsafe_chars(characters): safe_characters = string.ascii_letters+string.digits+"-_!*'()" return [char for char in characters if char in safe_characters]

def create_string_from_indeces(characters, character_locations):

Generates a result String from the characters passed in. The characters will
be in the same order as when in the source String.
locations = [character_locations[char] for char in characters] #Next line flattens the location list locations = [index for sublist in locations for index in sublist] #Then sorts the indeces so we go in original character order locations.sort() #Character locations are in order. Collect the characters for each location output_characters = [mapping[0] for index in locations for mapping in character_locations.items() if index in mapping[1]] return .join(output_characters)

This is how the code gets run
>>> input_string = """ Copy and Pasted from Source """ >>> location_map = make_location_map(input_string) >>> rare = find_rare_characters(len(input_string) / len(location_map), location_map) >>> rare = filter_unsafe_chars(rare) >>> create_string_from_indeces(rare, location_map) 'equality' </pre>

SJL

Another method (Python)

This program has one assumption, that the number of occurence of rare characters is same.

min_occur = ''
char = []        # to hold the unique variables in the multiline text
char_count = []  # to hold the count of those variables)
ind = 0
with open('E:/Documents/Python/Challenge_third.txt', 'r') as mess:
    for line in mess:
        for letter in range(0,len(line)):
            if line[letter] in char:
                j = char.index(line[letter])
                char_count[j] = char_count[j] + 1
            else:
                char.append(line[letter])    
                char_count.append(1)
mess.closed
min_value = min(char_count)
for i in char_count:
    if i == min_value:
        min_occur = min_occur + char[ind]
    ind = ind + 1
print min_occur
Any improvement for the above program is welcome.

Method & Process

outlines the full deductive process, using only what information is given and not making any extra assumptions about the rare characters:

# find the rare characters using a dictionary, then sort
import sys
import string
f = open(sys.argv[1])
str = ''.join(f.readlines())
dict = {}
for i in str: 
    #UNCOMMENT FOR FULL CODE: if i in string.letters: print i
    count = dict.get(i)
    if count:
        dict[i] = count + 1
    else:
        dict[i] = 1
lst = dict.items()
def s(t): return t[1]
lst.sort(key=s)
print lst

#this gives the output:
[('a', 1), ('e', 1), ('i', 1), ('l', 1), ('q', 1), ('u', 1), ('t', 1), ('y', 1), ('\n', 1219), ('^', 6030), ...]

so clearly, our rarely occurring letters are alphabets. therefore, we go back to our code, 
and add the line that is commented out, which prints "equality" vertically
My method(Python)

data=""" all the string copied from page source  """
nd=''
for a in data:
	if (ord(a) > 65 and ord(a) < 91) or (ord(a) > 96 and ord(a) < 122):
		nd+=a	
print nd

#respuesta
#equality

Tree Lines Python Solution

Assuming the text is in text variable

import string
for c in text:
	if not ((c in string.punctuation ) or (	c=="\n")): print c

A Python one

#Please be lenient, Iam young


#Function rank_wrt_order_in_text(list,text) ranks list items w.r.t. their order of first occurence in text

#I am not assuming that rare things in mess are alpha characters, except when returning rare characters in their order
#of occurrence in original mess (not mandatory)

def rank_wrt_order_in_text(alist,atext):
    print "".join([alist[x] for x in map(lambda y:y[0], sorted(enumerate([atext.find(alist[i]) for i in range(len(alist))]),key=operator.itemgetter(1)))])

#Function find_rare_things(mess) finds rare character in a mess, those occurring less than average character frequency

def find_rare_things(mess):
    txt=mess.read()
    amap=map(lambda y: ord(y), txt)
    cardinal=[(float(amap.count(i))/len(amap)) for i in sorted(set(amap))]
    res=[chr(sorted(set(amap))[x]) for x in map(lambda y: y[0] if (y[1]<(float(sum(cardinal))/len(cardinal))) else '', sorted(enumerate(cardinal),key=operator.itemgetter(1))) if x!=''] 
    return rank_wrt_order_in_text([x for x in res if x.isalpha()],txt)



Python 3 methods

puz_text = """
      #the mess of stuff from the page source of ocr.html...
""" 
#straight forward with no imports, set() is Python 2 and 3
#the set() function removes all duplicates from a collection

print(set(puz_text))
>>>{'\n', '!', '#', '%', '$', '&', ')', '(', '+', '*', '@', '[', ']', '_', '^', 'a', 'e', 'i', 'l', 'q', 'u', 't', 'y', '{', '}'}

#The alphabetic characters form an obvious anagram for 'equality'.


#Another way uses a method from the collections module in Python 3, collections.Counter which counts occurrences of members in a collection

from collections import Counter
print(Counter(puz_text))
>>>Counter({')': 6186, '@': 6157, '(': 6154, ']': 6152, '#': 6115, '_': 6112, '[': 6108, '}': 6105, '%': 6104, '!': 6079, '+': 6066, '$': 6046, 
'{': 6046, '&': 6043, '*': 6034, '^': 6030, '\n': 1221, 'a': 1, 'e': 1, 'i': 1, 'l': 1, 'q': 1, 'u': 1, 't': 1, 'y': 1})

#Yet again, the rare characters having a frequency of 1 form an obvious anagram for 'equality'.
#Since I solved the anagram in my head quickly and moved to the next level successfully, I consider it a reasonable solution.
#--Bill Allen
Another Python Regex

#Regex, the Python way, works out very well!
#I was actually trying to work this one out with a regex, but hit on the prior solution I posted first.

import re

puz_text = """
      #the mess of stuff from the page source of ocr.html...
""" 

rx = re.compile("[a-zA-Z]")
rx.findall(puz_text)
['e', 'q', 'u', 'a', 'l', 'i', 't', 'y']
>>> 
#--Bill Allen
Direct URL access approach

outlines the full process of getting the answer directly from the web page's html:

import urllib

i = 0
prepare = 0
inProgress = 0
chars = []
uniqueCharsIndex = []

# get a handle to the html page, read it and split it into the respective lines
urlHandle = urllib.urlopen('http://www.pythonchallenge.com/pc/def/ocr.html','r')
lines = (urlHandle.read()).splitlines()
urlHandle.close()

# look for the string "find rare characters in the mess below", as this string
# is found just before the start of the "mess"
# once the earlier mentioned string is found, look for the "<!--" string, which
# marks the start of the "mess"
# when the "-->" string is seen, consider the "mess" completed
for line in lines:
    if "find rare characters in the mess below" in line:
        prepare = 1
        continue
        
    if prepare == 1 and inProgress == 0:
        if "<!--" in line:
            inProgress = 1
            prepare = 0
            continue

    if inProgress == 1:
        if "-->" in line:
            inProgress = 0
            break
        chars += list(line)

# copy the list of characters
# then sort the copied list by value so that all the characters are "grouped" together
charList = list(chars)
charList.sort()

# iterate through the list and the assumption made here is that rare characters are those
# which occur only once. the index of each character which occurs only once is put into a
# separate list
# note: the character index for each rare occurrence has to be taken from the original list,
# i.e. the chars variable, because the charsList variable has already been sorted and so the
# order of the characters has been lost (mixed up during the sort process)
while i < len(charList):
    char = charList[i]
    charCount = charList.count(char)
    if charCount == 1:
        uniqueCharsIndex.append(chars.index(char))

    i += charCount

# finally sort the index as this will sort it according to the original order of occurrence
# of each character in the "mess"
uniqueCharsIndex.sort()

# iterate through the index list and get the actual characters in the correct order and put
# them into a string
uniqueChars = []
for i in uniqueCharsIndex:
    uniqueChars.append(chars[i])
uniqueCharStr = "".join(uniqueChars)
print uniqueCharStr
Pythonic simplicity

-Inspired by the original freq solution, and the simplicity of the 'Python List Comprehension One Liner, without knowledge of characters' (but wanted to improve the speed)

-Used collections.Counter in Python 2.7

# when "rare" means less than average
from collections import Counter
text = open('ocr.html').read().replace('\n','')
freq = Counter(text)
avg_freq = sum(freq.values()) // len(freq)
print ''.join([c for c in text if freq[c] < avg_freq ])

# when "rare" means less than 5
from collections import Counter
text = open('ocr.html').read()
freq = Counter(text)
print ''.join([c for c in text if freq[c] < 5 ])
Code by Deiva 23:30, 21 Dec 2010, +0800 (Malaysia)


Scala, but briefly

    // loads data string to List[Char]
    val data = PcLib.loadData( 2 ).flatten
		
    // count occurences, keep just the counts, then sort
    val counts = data.groupBy{ c => c }.mapValues{ list => list.size }.toList.sortBy{ _._2 }.reverse

    // spits characters out in wrong order, but easy to unscramble		
    counts.foreach( println )

Using Beautiful Soup

Get BeautifulSoap from http://www.crummy.com/software/BeautifulSoup/
>>> import urllib
>>> import BeautifulSoup as bs
>>> churl = "http://www.pythonchallenge.com/pc/def/ocr.html"
>>> full = urllib.urlopen(churl).read()
>>> src = bs.BeautifulSoup(full)
>>> comments = src.findAll(text=lambda text:isinstance(text, bs.Comment))
>>> clue = comments[1]
>>> for l in clue:
...          c = clue.count(l)
...          if c < 5: print l, "(", c, ")", 
... 
e ( 1 ) q ( 1 ) u ( 1 ) a ( 1 ) l ( 1 ) i ( 1 ) t ( 1 ) y ( 1 )
>>>
Simple Extraction

fp = open("mess.txt","r")
mess = fp.read()

chars = "!@#$%^&*()_+{}[]\n"
for i in mess:
    if i not in chars:
        new += i

print new
Alphanumeric Characters Only (very simple)

def findchar():
    fo = open("level2challeng.txt", "r")
    texto = fo.read()
    for i in texto:
        if i.isalpha():
            print i,
        else:
            continue

findchar()
Racket solution

Note that the text is actually parsed from the html online. Once loaded, we compute a histogram and the average frequency to filter out frequent chars.

#lang racket
(require net/url)
(define text (list-ref
              (regexp-split #rx"(\n-->)|(<!--\n)"
                            (port->string
                             (get-pure-port (string->url "http://www.pythonchallenge.com/pc/def/ocr.html"))))
              3))

(let ([histo (make-hash)])
  (for ([c (in-string text)])
       (hash-set! histo c (+ (hash-ref histo c 0) 1))) ; Compute histogram
                                       
  (let ([average-frequency (/ (apply + (hash-values histo)) ; Compute average frequency
                               (hash-count histo))])

    (list->string
     (reverse
      (for/fold ([acum '()]) ([c (in-string text)]) ; Filter anything above or equal to the frequency
        (if (and (not (equal? c #\newline))
                 (< (hash-ref histo c 0) average-frequency))
            (cons c acum)
            acum))))))
Factor solution

"ocr.txt" utf8 file-contents [ alpha? ] filter

PHP Solution

This solution makes only one assumption: That any character occurring less often than average is to be considered rare.

function ocr($str) {
	$counts = array_filter(count_chars($str)); // count_chars gets the number of occurrences of EVERY ascii character, array_filter removes the zero values

	// Length of string divided by length of character count array 
	// gives us the average occurences of each character
	$avg_occurences = strlen($str) / count($counts); 

	foreach($counts as $char => $count) { 
		// If the character occurs less often than average, 
		// it is considered rare and added to our string
		if($count < $avg_occurences)
			$rarechars .= chr($char);
	}

	return(preg_replace('/([\s]|[^'.$rarechars.'])/',"",$str)); // Strip all non-rare characters and whitespace
}

print(ocr(file_get_contents("ocr.html"));
Xlator 19:04, 19 January 2012 (PST)


yap, yap, Yet Another Python, You Always Prefer

counts = [0] * 256       # Assumes 8-bit charset
for c in data:
    counts[ord(c)] += 1
for d in range(256):
    if counts[d] == 1:   # Human unit recognised the limit of rarity == 1 on 1st pass
        print chr(d),
# Human unit recognised anagram of 'equality' and applied it to next URL.
I love the range of solutions... --Gingko 18:59, 20 January 2012 (PST)

Yet another solution with filter

import urllib
# I'm sorry PEP8
s = urllib.urlopen('http://www.pythonchallenge.com/pc/def/ocr.html').read().split('<!--')[-1].replace('-->', '')
''.join(filter(lambda x: x.isalnum(), s))
--Snahor 18:18, 22 January 2012 (PST)

Another solution with list and dict

record = dict()
record2 = list()
for l in text:
    if l in record.keys(): record[l] = record[l] + 1
    else:
        record[l] = 1
        record2.append(l)

print ''.join([y for y in record2 if y in [x for x in record if record[x] == 1]])
--Sean qu 19:24, 29 January 2012 (PST)

Very Easy Method

string = 'The long text' 
count_list = []
char_list = []
def count_char(char):
    return string.count(char)
    
for char in string:
    if char not in char_list:
        char_list.append(char)
        count_list.append(count_char(char))
    

print char_list
print count_list
Result:

['%', '$', '@', '_', '^', '#', ')', '&', '!', '+', ']', '*', '}', '[', '(', '{', '\n', 'e', 'q', 'u', 'a', 'l', 'i', 't', 'y']
[6104, 6046, 6157, 6112, 6030, 6115, 6186, 6043, 6079, 6066, 6152, 6034, 6105, 6108, 6154, 6046, 1219, 1, 1, 1, 1, 1, 1, 1, 1]
--Etcher 0:54, 26 March 2012 (PST)

Just Plug In the URL

import urllib

inchar = "abcdefghijklmnopqrstuvwxyz"
remaining = []

def pleasework(url):
    doclocation = urllib.urlopen(url)
    openfile = doclocation.read()
    comment = openfile.split('<!--')[2]
    for s in comment:
        if s in inchar:
            remaining.append(s)
    print remaining
Result:

>>>pleasework('http://www.pythonchallenge.com/pc/def/ocr.html')
['e', 'q', 'u', 'a', 'l', 'i', 't', 'y']
--browncarpet 17:08, 26 June 2012 (PST)

ECMAScript 5 solution

Assumes the existence of a file named 'level_02.txt' containing the string of characters we are searching through. Uses the fs library included with node.

var fs = require('fs');
var character_soup = fs.readFileSync('level_02.txt').toString();
var solution = ''
for (var i = 0; i < character_soup.length; i += 1) {
    if ("abcdefghijklmnopqrstuvwxyz".indexOf(character_soup[i]) !== -1) {
        solution = solution + character_soup[i];
    }
}
console.log(solution);
// Andy Short 2012
C# solution

Print out the frequency of each character.

		public static void FindRare( string var ) {
			Hashtable hash = new Hashtable();
			ICollection keycollection = hash.Keys;
			ICollection valuecollection = hash.Values;
			
			foreach (char i in var){
				if ( hash.ContainsKey(i) ) 
				{					
					hash[i] = ++Int32.Parse(hash[i].ToString());
				}
				
				else 
					hash.Add(i,1);
				
			}
			
			char[] mykeys = new char[hash.Count];
			int[] myvalues = new int[hash.Count];
			keycollection.CopyTo(mykeys, 0);
			valuecollection.CopyTo(myvalues, 0);
			
			Console.WriteLine("index value..");
			for (int i = 0; i< hash.Count; i++)
			{
				Console.WriteLine("{0} : {1}", mykeys[i], myvalues[i]);
				
				
			}
					
			
		}
Java solution

public static void main(String[] args) {
    InputStream reader = Runtime.getRuntime().getClass().getResourceAsStream("/text.txt");
    StringBuilder sb = new StringBuilder();
    int readChar;
    try {
        while ( (readChar = reader.read()) > 0) {
            if (Character.isLetter(readChar))
                sb.append((char)readChar);
        }
    } catch (IOException ex) {}
    System.out.println(sb.toString());
}
____________________________________________________
With each loop check for the last nine characters
# dane <<-- http://www.pythonchallenge.com/pc/def/equality.html
dane = '''kAewtloYgcFQaJNhHVGxXDiQmzjfcpYbzxlWrVcqsmUbCunkfxZWDZjUZMiGqhRRiUvGmYmvnJIHEmbT
          MUKLECKdCthezSYBpIElRnZugFAxDRtQPpyeCBgBfaRVvvguRXLvkAdLOeCKxsDUvBBCwdpMMWmuELeG
          (...)'''
znaki = [""] * 9
znalezione = ""
for znak in dane:
    del znaki[0]
    znaki.append(znak)
    if \
        not znaki[0].isupper() and\
            znaki[1].isupper() and\
            znaki[2].isupper() and\
            znaki[3].isupper() and\
            znaki[4].islower() and\
            znaki[5].isupper() and\
            znaki[6].isupper() and\
            znaki[7].isupper() and\
        not znaki[8].isupper()    \
    :
        znalezione += znaki[4]
print(znalezione) # -->> "linkedlist"
Concise, recursive and with list comprehension
# text is in t2
markers = ''.join( [ '0' if c in string.lowercase else '1' for c in t2 ] )
def f( res, t2, markers ):
    n = len(markers.partition('011101110')[0])
    return f( res+t2[n+4], t2[n+9:], markers[n+9:] ) if n != len(markers) else res
print f( '', t2, markers )
Consise, recursive and with list comprehension (improved version)
I like the solution above very much, but although it works in this context it needs some refining, as it fails for some edge cases:
e.g. "HHHoHHHoHHHoHHHoHHH". In this string the 4 o's should match. But the solution above will only match the second one.

the first o will fail because 011101110 doesn't take into account matches that occur at string boundaries (^ and $).
the second o will match.
the third will fail because it overlaps with the second. Having t2[n+9:] and markers[n+9:] does not take this case into consideration.
the fourth o might fail for two possible reasons:
the same reason the first did.
we could pad the string so that it ended like "...oHHHoHHHo", it would palliate to the first reason, but the condition if n != len(markers) else res doesn't take nto account that, the current value of markers itself might actually match the pattern '011101110'; so that last o won't get matched.
Taking these points into consideration, here are some refined versions:

First, a solution using a lambda to handle situations where the last bit of the string is an actual match. i.e. markers == "011101110". Also note that when creating the markers, we rather check for uppercase letters rather than lowercase ones. The string might contain some inner newlines characters (\n). We can afford to have them mistaken for lowercase characters, but the same isn't true for uppercase characters.

import string
def level_3(t1):
    # since we're not using regex to match we need to pad the string with some pseudo line boundaries
    pad = "x"
    t1 = pad + t1 + pad
    # checking for uppercase rather than lowercase
    markers = "".join([ '1' if c in string.uppercase else '0' for c in t1])
    pattern = "011101110"
    def f(res, t2, markers):
        n = len(markers.partition(pattern)[0])
        # We could have placed this lambda outside the nested function for a slight bit of performance, 
        # but for contextual and readability reasons, I think it belongs here.
        end_of_string = lambda res, t2, markers: markers == pattern and res+t2[4] or res
        return f(res+t2[n+4], t2[n+4:], markers[n+4:]) if n != len(markers) else end_of_string(res, t2, markers)
    return f('', t1, markers)
or an alternative without a lambda

import string
def level_3(t1):
    # the second x ensures that the last match will never be in the last portion of the split after calling string.partition
    pad = "xx"
    t1 = pad + t1 + pad
    markers = "".join([ '1' if c in string.uppercase else '0' for c in t1])
    pattern = "011101110"
    def f(res, t2, markers):
        n = len(markers.partition(pattern)[0]
        return f(res+t2[n+4], t2[n+4:], markers[n+4:]) if n != len(markers) else res
    return f('', t1, markers)
Mekoka 19:17, 4 Mar 2011 (PST)

reduce, no regex, clear and works for edge cases
def f(state, c):
	if not c.isalpha():
		return state
	
	if state:
		chars_found, state_lower, upper_count = state
	else:
		state_lower = ""
		upper_count = 0
		chars_found = ""

	if c.islower():
		if upper_count == 3:
			if state_lower:
				chars_found += state_lower

			state_lower = c
		else:
			state_lower = ""

		upper_count = 0

	else:
		upper_count += 1

	return chars_found, state_lower, upper_count

str = #assigned to the challenge string
str += "x" #right padded with one lowercase char
print reduce(f, str, ())[0]
--Brucel 05:02, 6 November 2011 (PST)

Simple
>>> import string
>>> code = """
...            <copy and paste>
...                             """.replace("\n", "")
>>> word = ""
>>> for i in range(len(code) - 8):
...     if [c for c in code[i:i+9] if c in string.lowercase] == [code[i], code[i+4], code[i+8]]:
...         word += code[i+4]
...
>>> word
'linkedlist'
Pseudo-Recursive Method - simple one

binstring=[1 if i in string.uppercase else 0 for i in inputstring]
sourcestring=[i if i in string.letters else '' for i in inputstring]
def analyze(sourcelist):
	if len(sourcelist)<7:
		print "End reached"
	else:
		ex=sourcelist[len(sourcelist)-9:]
		stringex=''.join(['1' if i==1 else '0' for i in ex])
		if stringex=='011101110':
			print sourcestring[len(sourcelist)-5]
	return sourcelist
		
for i in range(len(binstring)-9):			
	binstring=analyze(binstring)
	binstring.pop()
Memory Intensive and prints in a poor format, upside down. But gets the work done, nonetheless.

Using re (Regular Expressions module)

A simple re solution
The hint tells us to look for small letters surrounded by EXACTLY 3 capital letters. The title implies to use the re module, so this is what we are going to do.

(we assume that the text is loaded into the variable named text)

>>> import re
>>> "".join(re.findall('[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]', text))
'linkedlist'
[A-Z]{3} means exactly 3 capital letters. The brackets () are used to define groups. For each matching pattern, only the group is returned. Putting "".join() around it changes it from a list of letters to a continuous string, just for clarity.

And the next url will be linkedlist.html, which shows a manual redirect to linkedlist.php

A better re method
A better method is

>>> import re
>>> "".join(re.findall('[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]', text))
'linkedlist'
because when it says EXACTLY, there could be special characters that still solve the problem (eg. "?ABCdEFG#").

Another re solution
I used

>>> import re
>>> .join(x[1] for x in re.findall('(^|[^A-Z])[A-Z]{3}([a-z])[A-Z]{3}([^A-Z]|$)', text))
because the text could theoretically start or end with 3 capital letters. Though it doesn't ;-)'


The same, only using (?: ) to exclude parenthesis from showing up in the result list (instead of picking the middle one specifically as above):

>>> .join(re.findall('(?:^|[^A-Z])[A-Z]{3}([a-z])[A-Z]{3}(?:[^A-Z]|$)',text))

comment: I like your solution. Very skilled!

An alternate regex using lookahead and lookbehind
   .join(re.findall("(?<=[^A-Z][A-Z]{3})[a-z](?=[A-Z]{3}[^A-Z])",text))
And a winner is you. กช Fatalis 05:43, 28 Dec 2006 (MST)
And to make things even more painfully obvious...
   import re, string
   
   file = open('3.txt', 'r')
   rawtext = "".join(map(string.rstrip, file.readlines()))
   file.close()
   
   pattern = re.compile('[a-z][A-Z]{3}[a-z][A-Z]{3}[a-z]')
   matches = re.findall(pattern, rawtext)
   
   # ansi escape sequences -- run this example on a proper terminal (cygwin or xterm-color)
   normal = '\033[0m'
   black  = '\033[30;1m'
   white  = '\033[37;1m'    
   
   for match in matches:
       print black + match[1:4] + white + match[4] + black + match[5:8] + normal
ord() solution
far from being the simplest solution, but using simple concepts.

       #!/usr/bin/env python
       f=open("source", "r")
       n=open("dest", "a")
       list=f.read()
       def capital(a):
               number=ord(list[a])
               if number < 91 and number > 64:
                       return 1
               else:
                       return 0
       def small(a):
               number=ord(list[a])
               if number < 123 and number > 96:
                       return 1
               else:
                       return 0
       x=0
       while True:
               if small(x) and capital(x-1) and capital(x-2) and capital(x-3) and capital(x+1) and capital(x+2) and capital(x+3)\
               and not capital(x+4) and not capital(x-4):
                       n.write(list[x])
               x=x+1
       n.close()
       f.close()
islower() and isupper() solution (looking left and right)
My two cents. Hope I'm doin' right cause this wiki's help is full of adverts.

#!/usr/bin/python3.2
# -*-coding:Utf-8 -*

with open('lv_3_datas.txt', 'r') as file:
    # Need extra lower case at each end to avoid IndexError
    coded_message = 'a' + file.read() + 'a'
    # To get rid of line jumps
    coded_message = coded_message.replace('\n','')
    #print(coded_message)

def checkleft(i):
    if coded_message[i-4].islower() and coded_message[i-3:i].isupper():
        return True
    else:
        return False

def checkright(i):
    if coded_message[i+1:i+4].isupper() and coded_message[i+4].islower():
        return True
    else:
        return False   

for i in range(4, len(coded_message) -4):
    # May be done with single loop but two is easier for debugging and learning
    if coded_message[i].islower():
        # To help debugging...
        #print(i, coded_message[i-4] + coded_message[i-3:i], coded_message[i],\
        #coded_message[i+1:i+4] + coded_message[i+4], \
        #checkleft(i), checkright(i))

        if checkleft(i) and checkright(i):
            print("Solution :", coded_message[i])
Self-contained solution (shorter, with RE)
  import re, urllib
  text = urllib.urlopen('http://www.pythonchallenge.com/pc/def/equality.html').read().replace('\n','')
  text = re.findall('<!--(\w*)-->',text)[0]
  print ''.join(re.findall('[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]', text))
--Staz 15:14, 9 Feb 2009 (PST)

Self-contained solution (even shorter, with RE)
import urllib, re
print ''.join(re.findall(  '[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]',
  urllib.urlopen("http://www.pythonchallenge.com/pc/def/equality.html").read()))
--SimonG 10:30, 26 Apr 2010 (GMT+1)

A similar RE but need to be careful with lookahead/lookbehind
This is similar to several of the above solutions. It ensures exactly three capitals on each side using lookbehind and lookahead. But one needs to be careful with these assertions to makes sure that the pattern can match at the beginning and end of the string. Including the three caps in the assertion can match the wrong pattern, and using [^A-Z] instead can fail to match at the ends. I used the negative assertions to preclude an extra capital letter. Because these allow an empty string, they work at the ends.

   from __future__ import print_function
   import urllib2
   import re
   
   # read the string and isolate the HTML comment
   
   equality = urllib2.urlopen('http://www.pythonchallenge.com/pc/def/equality.html').read()
   equality = equality.split("<!--\n", 1)[-1]
   equality = equality.rsplit("\n-->", 1)[0]
   
   # The text suggests that the body guards are large, i.e., capital letters,
   # so look for exactly three capital letters on each side of a lower case letter.
   # And the page title is "re" after all. 
   
   r =  re.compile(r"""(?<![A-Z])              # Preclude a capital letter before the main pattern
                       [A-Z]{3}                # exactly 3 big bodyguards
                       ([a-z])                 # one small letter
                       [A-Z]{3}                # 3 more body guards
                       (?![A-Z])               # Preclude capital after the three
                       """, re.X | re.S | re.M )
   
   print("".join(r.findall(equality)))
An even better RE solution with lookbehind and lookahead
The previous RE solutions (including the ones with lookaround assertions) will fail to accurately match at least one of the following strings:

- "HHHoHHHoHHH" 2 o's should match here

- "HHHHoHHHoHHHoHHH" 2 o's should match here, the first one has 4 H's preceding it

- "HHHoHHHoHHHoHHHH" 2 o's should match here, the last one has 4 H's following it

The first one fails because, for subsequent matches, Python's regex does not revisits characters that it has already consumed. That is, if you try to match the exact pattern "HHHoHHH", in the string "HHHoHHHoHHH" with the previous regex pattern, it will match the first "HHHoHHH" and consume it along the process, leaving only the remaining "oHHH" available for a match. We need to match "HHHoHHH", without consuming anything beyond "HHHo". Lookaround assertions can help us to do this, but one needs to understand how they work.

    def level_3_regex(str):
        pattern = re.compile(r'(?<![A-Z])[A-Z]{3}([a-z])(?=[A-Z]{3}(?![A-Z]))')

        #2 (?<            
        #3    ![A-Z]      
        #4 )              
        #1 [A-Z]{3}       
        #5 ([a-z])        
        #6 (?             
        #7    =[A-Z]{3}   
        #8    (?          
        #9       ![A-Z]   
        #10    )           
        #11 )              

        return "".join(pattern.findall(str))
match 3 uppercase letters
go back temporarily, one position before the beginning of the previous match
make sure it isn't an uppercase letter
move back to your last position prior to #2
move forward and match a single lowercase letter and "remember" its value
go forward temporarily
make sure it's 3 uppercase letters
move forward temporarily
make sure it's not an uppercase letter
move back to your last position prior to #8
move back to your last position prior to #6
Note how we end up right back at #5. We were able to look at the whole "HHHoHHH", but ended up consuming only "HHHo", leaving the next "HHH" available for consumption in the next match.

An additional remark regarding the following two very similar assertions: (?<=[^A-Z])[A-Z]{3} (from a previous example) and (?<![A-Z])[A-Z]{3}. The first one can be translated to "there is something behind you that should not be an upper case letter", whereas the second one is more "you should not have an upper case letter behind you". At first they seem interchangeable, but there is a little nuance. For the first one to match, it requires something behind [A-Z]{3}, that is not an upper case letter. That is, it would fail to match the 3 H in HHHo if it was positioned at the beginning of the line. The second lookbehind assertion rather says that there shouldn't be an upper case letter behind, but it doesn't require a character in that position. Mekoka 23:52, 4 Mar 2011 (PST)

Comment:--114.250.83.17 04:10, 22 October 2011 (PDT) This is definitely the best solution I've ever seen. Learned much from the excellent explaination. Thanks a lot!

And Even More Careful-er with lookahead/lookbehind
If we want to avoid consuming the characters after our ([a-z]), why not *before* as well?

pattern = re.compile('(?<=(?<![A-Z])[A-Z]{3})[a-z](?=[A-Z]{3}(?![A-Z]))')  
(Also: kudos to whoever designed this for the previous challenge, the most elegant import method I've seen, which gives us two excellent uses of RE for our money in this challenge:)

text = urllib.urlopen('http://www.pythonchallenge.com/pc/def/equality.html').read().replace('\n','')
text = re.findall('<!--(\S*)-->',text)[0]
--Xml 11:27, 24 August 2011 (PDT)


> If we want to avoid consuming the characters after our ([a-z]), why not *before* as well?

There is no point in doing so, because when the [a-z] is consumed, anything before is also as good as consumed (i.e. the regex "parser" won't go back past the last character consumed).

Perl solution

#!/usr/bin/perl -w
use LWP::Simple;
$input = get "http://pythonchallenge.com/pc/def/equality.html";
@lines = split(/\n/, $input);
$pattern = '[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]';
foreach(@lines)
{
   if (/$pattern/o)
   {
      print $1;
   }
}
print "\n";
Takes 1.454 seconds on my computer, including downloading of page...

Tek 07:25, 1 Mar 2008 (PST)

Using grep

I'm not that sharpe ;) I used:

 grep -o "[a-z][A-Z][A-Z][A-Z][a-z][A-Z][A-Z][A-Z][a-z]" re.txt
 qIQNlQSLi
 eOEKiVEYj
 aZADnMCZq
 bZUTkLYNg
 uCNDeHSBj
 kOIXdKBFh
 dXJVlGZVm
 gZAGiLQZx
 vCJAsACFl
 qKWGtIDCj
linkedlist verticaly ;)


I like things to look nice, so I used:

grep -E -o ([a-z][A-Z]{3}){2}[a-z] re.dat | cut -c 5 | tr -d '\n'
linkedlist
Without Regular Expressions

You can do it without regular expressions

   import string
   lwr=string.lowercase
   upr=string.uppercase
   theFile=open('c3.txt','r')
   s=theFile.read()
   for n in range(1,len(s)-7):
       if (s[n-1] in lwr) and (s[n] in upr) and (s[n+1] in upr)\
          and (s[n+2] in upr) and (s[n+3] in lwr)\
          and (s[n+4] in upr) and (s[n+5] in upr)\
          and (s[n+6] in upr) and (s[n+7] in lwr):
               print s[n+3]
My solution is quite similar to the first one, but I would like to comment. Because of an ambiguity in the wording, I initially solved a rather more complicated problem--three capitals on ALL sides, including top and bottom. Suffice it to say, I did not attain the solution. Any way the wording could be cleared up? (Matching in 2 dimension==unfun.)

This confused me also. The problem said "surrounded by EXACTLY three big bodyguards on each of its sides." I think replacing "each of its sides" with "both sides" would be clearer.

(Comment: Note the visual explanation in the photo. Part of the fun of these challenges is to make sure you use all available inputs.--Xml 11:27, 24 August 2011 (PDT) )

I totally missed the reference to the re module. I have often seen various people advising avoiding the use of the RE module where it is not really needed. To be sure, it is a nice power tool to have and be able to apply well but its not really needed here. In the interest of learning, here is yet another solution (very similar to above) without *any* modules (perhaps a little cleaner). I took the data to be all one string, though I guess that's not really needed. It would deal with matches that wrapped around lines if that was the author's intent but would fail on matches at the ends of the string. (Also shows how to easily slap some data into your program without reading files.) HTH! :)

   DATA = """\
   kAewtloYgcFQaJNhHVGxXDiQmzjfcpYbzxlWrVcqsmUbCunkfxZWDZjUZMiGqhRRiUvGmYmvnJIHEmbT
   ...
   PBuijeoTSpsVLaOGuLVjMZXkBvVXwUuHfBihziiavGSYofPNeKsTXruMUumRRPQJzvSzJkKbtSipiqBd
   """
   s = "".join(DATA.split('\n'))
   def check(i):
       for offset in [-3, -2, -1, 1, 2, 3]:
           if not s[i + offset].isupper():
               return False
       for offset in [-4, 4]:
           if s[i + offset].isupper():
               return False
       return s[i].islower()
   found = []
   for i in xrange(4, len(s) - 5):
       if check(i):
           found.append(s[i])
   print "".join(found)
Another solution without using re

I've also missed the reference to the re module, but it is not needed to solve this problem. Since I am a python learner, I decided to read the tutorial and try the challenges while learning. I've used only loops, conditions, and the string module to solve the problem:

 import string
 
 text = "a" + text + "a"
 
 x = 0
 
 while x <= len(text) - 9:
 	text1 = text[x:x+9]
 	if text1[0] not in string.uppercase:
 		for y in range(1, 4):
 			if text1[y] not in string.uppercase:
 				x = x+y
 				break
 		else:
 			if text1[4] in string.lowercase:
 				for z in range(5,8):
 					if text1[z] not in string.uppercase:
 						x = x+4
 						break
 				else:
 					if text1[8] not in string.uppercase:
 						print text1[4],
 					x = x+8
 			else:
 				x = x+4
 	else:
 		x = x+1
To verify always nine characters, I've inserted a small letter on each extreme of the text. I think (almost sure) it is not as fast as re, but it really worked fine for me. :-)

Additionally, it's not needed to import string as every string object features the methods isupper() and islower(). I took a similar aproach: --MKesper 15:10, 10 Jun 2007 (PDT)

   last_char_lower = False
   result = ['foo']
   def change_case(char):
       global result
       if len(result) > 4:
           del result[0]
       result.append(char)
       if len(result) == 5:
           if len(result[1]) == 3\
           and len(result[2]) == 1\
           and len(result[3]) == 3\
           and result[1].isupper():
               print "" + str(result[1]) + str(result[2]) \
                             + str(result[3])
   for char in open("equality.html", "r").read():
       if char <> '\n':
           if (last_char_lower and char.isupper())\
               or (not last_char_lower and char.islower()):
               change_case(char)
           else:
               result[len(result) - 1] += char
           last_char_lower = char.islower()

Ya.. here is my solution without using re. It's a very naive approach and I feel a bit foolish after looking at some of the other solutions, but I think at least mine looks pretty and easy to understand:

   #!/usr/bin/env python
   
   STRING = "".join([LINE.strip() for LINE in open("jibberish")])
   
   # we are looking for a sequence of lUUUlUUUl
   LITTLE_GUYS = 
   COUNT = 1
   REMEMBER = {1:"", 2:"", 3:"", 4:"", 5:"", 6:"", 7:"", 8:"", 9:""}
   for LETTER in STRING:
       if COUNT == 1 and LETTER.islower():
           REMEMBER[COUNT] = LETTER
           COUNT = 2
       elif COUNT == 2 and LETTER.isupper():
           REMEMBER[COUNT] = LETTER
           COUNT = 3
       elif COUNT == 3 and LETTER.isupper():
           REMEMBER[COUNT] = LETTER
           COUNT = 4
       elif COUNT == 4 and LETTER.isupper():
           REMEMBER[COUNT] = LETTER
           COUNT = 5
       elif COUNT == 5 and LETTER.islower():
           REMEMBER[COUNT] = LETTER
           COUNT = 6
       elif COUNT == 6 and LETTER.isupper():
           REMEMBER[COUNT] = LETTER
           COUNT = 7
       elif COUNT == 7 and LETTER.isupper():
           REMEMBER[COUNT] = LETTER
           COUNT = 8
       elif COUNT == 8 and LETTER.isupper():
           REMEMBER[COUNT] = LETTER
           COUNT = 9
       elif COUNT == 9 and LETTER.islower():
           REMEMBER[COUNT] = LETTER
           COUNT = 1
           LITTLE_GUYS = LITTLE_GUYS + REMEMBER[5]
       else:
           COUNT = 1
           if LETTER.islower():
               REMEMBER[COUNT] = LETTER
               COUNT = 2
   
   print LITTLE_GUYS
I came back to play the game to get a python refresh on my skills.. completely forgot about my previous solution. Here is it the second time I played:

  data_s = "".join(open('data.txt','r').read().split('\n'))
  
  char_count = 0
  significant_l = []
  heir_apparent = ""
  
  # we want aAAAuAAAa with u being the char we want...
  
  for i in data_s:
      if char_count > 0 and char_count < 4 and i.isupper():
          char_count = char_count + 1
      elif char_count == 4 and i.islower():
          heir_apparent = i
          char_count = char_count + 1
      elif char_count > 4 and char_count < 8 and i.isupper():
          char_count = char_count + 1
      elif char_count == 8 and i.islower():
          significant_l.append(heir_apparent)
          # are back to aAAAa, ergo:
          heir_apparent = i
          char_count = 5
      else:
          if i.islower():
              char_count = 1
          else:
              char_count = 0
  
  print "".join(significant_l)


-- drag

Self-contained solution (without RE)

I'm making self-contained solutions for each puzzle, that is, it downloads the page, parses the text and applies my solution:

   import urllib
   url = "http://www.pythonchallenge.com/pc/def/%s.html"
   s = urllib.urlopen(url % "equality").read()
   s = "".join(s.splitlines())
   s1 = s.find("<!--") + 1
   s2 = s.find("-->", s1)
   s = s[s1:s2]
   r = ""
   for i in range(4, len(s) - 4):
       if (s[i]+s[i-4]+s[i+4]).islower() and (s[i-3:i]+s[i+1:i+4]).isupper():
           r += s[i]
   print url % r
--LKRaider 00:06, 29 Mar 2008 (PDT)


List comprehensions and no regexp

>>> "".join([clu[i+3] for i in range(len(clu)-7) if clu[i+3].islower() and False not in [clu[i].isupper(), clu[i+1].isupper(), clu[i+2].isupper(), not clu[i-1].isupper(), clu[i+4].isupper(), clu[i+5].isupper(), clu[i+6].isupper(), not clu[i+7].isupper()]])
Shorter version
>>> "".join([text[i] for i in range(len(text)) if a[i].islower() and \
                                                  a[i-3:i].isupper() and a[i+1:i+4].isupper() and \
                                                  a[i-4].islower() and a[i+4].islower()])
---

Again another way without regexp (s is the text):

   c=reduce(lambda x,y:x+y, map(lambda x:str(int(x.islower())), s))
   res=
   x=0
   while x>=0:
       res+=s[x+4]
       x=c.find('100010001', x+1)
   res=res[1:]
Another pretty short way

I split the if clause into two to get it in here ;)

   chars = ""
   i = 0
   for char in string:
       bodyguards = string[i-3:i]+string[i+1:i+4]
       if char.islower() and bodyguards.count("\n") == 0:
           if bodyguards.isupper() and not string[i-4].isupper() and not string[i+4].isupper():
              chars += char
       i += 1
Clear and easy to understand

This loop is "waiting" for a pattern. Then it prints out the right character.

file = open("/.../manychars", "r")
string = file.read()
file.close()
cycle = 0
checklist = range(9)
for i in string:
    checklist = checklist[1:9]
    if i.islower():
        checklist.append(0)
    elif i.isupper():
        checklist.append(1)
    else:
        checklist.append(2)
    if checklist == [0, 1, 1, 1, 0, 1, 1, 1, 0]:
        print string[cycle - 4],
    cycle += 1
Devo 11:07, 3 Oct 2008 (PDT)


Let Python handle the newlines

Instead of splitting on '\n',

   b = "".join(a.splitlines())
   print "".join(re.findall( etc.)

sed solution

sed -n 's/.*\([a-z][A-Z]\{3\}\([a-z]\)[A-Z]\{3\}[a-z]\).*/\2/ p' < text
It outputs "linkedlist" vertically.

perl solution

perl -we '$_=`GET http://pythonchallenge.com/pc/def/equality.html`; print $1."\n" while  /[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]/gc;'
Here's it in perl, just because. Also, prints it vertically.


Java Solution

           Pattern pattern = Pattern.compile("[^A-Z][A-Z]{3}[a-z][A-Z]{3}[^A-Z]");
           Matcher matcher = pattern.matcher(fullInput);
           StringBuffer b=new StringBuffer();
           while(matcher.find())
           {
               b.append(matcher.group().charAt(4));
           }
           System.out.println(b.toString());
PHP Solution

Save the data in "r3.txt", then run:

$Str = file_get_contents("r3.txt");
$Matches = array();
preg_match_all("/[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]/", $Str, $Matches);
echo implode("", $Matches[1])."\n";
Leper421 19:58, 20 Feb 2008 (PST)

Another PHP Solution

$text = "THAT LONG TEXT";
preg_match_all("^([a-z])([A-Z]{3})([a-z])([A-Z]{3})([a-z])^",$text,$results);
foreach($results['3'] as $value){
	echo $value;
}
Run this and it'll show you the answer.

--Mert Yaz?c?o?lu

PHP Solution, read directly from website

$url = 'http://www.pythonchallenge.com/pc/def/equality.html';
$ch = curl_init();
curl_setopt_array($ch, array(CURLOPT_URL=>$url, CURLOPT_RETURNTRANSFER=>true, CURLOPT_CONNECTTIMEOUT=>5));
$output = curl_exec($ch);
curl_close($ch);
preg_match_all('%[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]%', $output, $matches);
echo implode('', $matches[1]);
Madgeek 14:16, 22 Oct 2009 (PDT)

Ruby Solution

(the input text is in data)

p data.scan(/[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]/).join

Ruby Solution from STDIN

 p ARGF.read.scan(/[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]/).join
The same as the previous solution, but reading from STDIN (file or direct input)

--Teonimesic 13:24, 13 Jul 2010 (PDT)

ActionScript solution

var crypt:String = //paste puzzle here
var solved:String = "";

//counter for the number of uppercase letters before and after the most recent lowercase one
var oldLarge:int;
var large:int;

//the most recent lowercase letter
var little:String;

for (var i = 0; i <= crypt.length; i++){
	var thisChar:int = crypt.charCodeAt(i);

	if (thisChar >= 97 && thisChar <= 122){  //if thisChar is lowercase
		if (large == 3 && oldLarge == 3)
			solved += little;
		oldLarge = large;
		large = 0;
		little = crypt.charAt(i);
	} else if (thisChar <=90 && thisChar >= 65)  //if thisChar is uppercase
		large++;
}

trace(solved);

Using Finite State Automaton

This is a quite primitive method. Just construct a finite state automaton that recognize the pattern [^A-Z][A-Z]{3}[a-z][A-Z]{3}[^A-Z] and prints the letter in the middle on matching.

It is a Mealy machine. It has several states that could record the last few letters it has seen. It also has some actions on some transitions: when matching the [a-z] in the middle, it records it; when matching the last [^A-Z], it prints the recorded letter.

The python code is:

import re
import string

txt = open('03.txt').read()

uppercase = string.uppercase
lowercase = string.lowercase

class FSA():

    def __init__(self):
        self.states = set([0,1,2,3,4,5,6,7,8]) # not used
        self.inputs = string.letters+'\n'      # not used
        self.start_state = 0

        self.delta = {0: [ (lowercase+'\n', 0, None),
                           (uppercase, 1, None) ],
                      1: [ (uppercase, 2, None),
                           (lowercase+'\n', 0, None) ],
                      2: [ (uppercase, 3, None),
                           (lowercase+'\n', 0, None) ],
                      3: [ (lowercase, 4, self.record_letter),
                           (uppercase, 8, None),
                           ('\n', 0, None) ],
                      4: [ (uppercase, 5, None),
                           (lowercase+'\n', 0, None) ],
                      5: [ (uppercase, 6, None),
                           (lowercase+'\n', 0, None) ],
                      6: [ (uppercase, 7, None),
                           (lowercase+'\n', 0, None) ],
                      7: [ (lowercase+'\n', 0, self.print_letter),
                           (uppercase, 8, None) ],
                      8: [ (uppercase, 8, None),
                           (lowercase+'\n', 0, None) ]
                      }
        self.current_state=self.start_state

    def feed(self,ch):
        for (charset, new_state, action) in self.delta[self.current_state]:
            if ch in charset:
                self.current_state=new_state
                if action!=None:
                    action(ch)

    def record_letter(self,c):
        self.saved_letter=ch

    def print_letter(self,ch):
        print self.saved_letter

fsa = FSA()
for ch in txt:
    fsa.feed(ch)
It will print 'linkedlist' one letter per line. --Cloverprince2 11:09, 21 Jun 2008 (PDT)


C++ Solution

Using boost_regex:

#include <boost/regex.hpp>
#include <iostream>
#include <fstream>

using namespace std;
using namespace boost;

int main()
{
	regex rgx("[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]");
	string s;
	ifstream is("a.txt");
	smatch result;

	while (getline(is, s))
		if(regex_search(s, result, rgx))
			cout << result[1];
}
Groovy Solution without Regex

#!/usr/bin/env groovy
#code by 7ek
mayusc = 'A'..'Z'
new File("in").eachLine{ linea ->
	for(i in 3..<(linea.size()-3)){
		if(linea[i] in mayusc)
			continue
		cont = 0
		for(j in 1..3)
			if(linea[i+j] in mayusc && linea[i-j] in mayusc)
				cont++
		if(cont==3 && (i+4 < linea.size()) && (i-4 >= 0) &&
			!(linea[i+4] in mayusc) && !(linea[i-4] in mayusc))
			print linea[i]
	}
}
Haskell

import Text.Regex.Posix
guardedLetters s = concat $ map (!! 1) $ s =~ "[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]"
Yay common lisp

(require 'cl-ppcre)
(map 'string #'(lambda (x) (char x 4)) (cl-ppcre:all-matches-as-strings "[a-z][A-Z]{3}[a-z][A-Z]{3}[a-z]" text))
Returns "linkedlist"

Javascript this time would be better

Using RE in C# would make me sick by it's lengthy syntax. I wonder why the regex library of C# is so clumsy and so, javascript (Firefox - Firebug interactive) this time would be better.

//Modify the html structure using firebug to add a div tag with id 'rare' contains a whole string
var text=document.getElementById('rare').textContent;
text.match(/[^A-Z][A-Z]{3}[a-z][A-Z]{3}[^A-Z]/);
Code by Namdx1987

Python using slicing and scoring system

from string import *
f = open(r'c:\bigsmallbig.txt')
text = f.read()
position = 0
winners =[]
for ch in list(text):
    try:
        win = 0
        start = position
        end = position + 9
        seg = text[start:end]
        if seg[4].islower ():
            win += 1
        if seg[0].islower():
            win += 1
        for q in seg[1:4]:
            if q.isupper():
                win += 1
        for q in seg[5:-1]:
            if q.isupper():
                win += 1
        if seg[8].islower():
            win += 1
        if win == 9:
            winners.append(seg)
        position += 1
    except:
        print '######Likely that seg[x] is out of scope!!!!!!!#######'
print winners
word =[]
print
for winner in winners:
    word.append(winner[4])
print ''.join(word)
another solution
by Tlhl28

#!/bin/env python
import urllib
analyze = urllib.urlopen('http://www.pythonchallenge.com/pc/def/equality.html').read().replace('\n',"")
box = [x for x in analyze[:8]]
box.insert(0,'0')
re = ""
for s in analyze[7:]:
    box.remove(box[0])
    box.append(s)
    #print "".join(box)

    if  "".join(box[1:4]).isupper() and "".join(box[-4:-1]).isupper():
       if "".join(box[0]).islower() and "".join(box[-1:]).islower():
            if "".join(box[4]).islower():
                #print "".join(box)
                re += "".join(box[4])
print re
Simple Python solution using re

 
import urllib
analyze = urllib.urlopen('http://www.pythonchallenge.com/pc/def/equality.html').read()
text =  analyze.split('</html>')[1] # let's take only needed stuff

# according to http://docs.python.org/library/re.html#finding-all-adverbs
import re
rez = re.findall(r"[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]", text)
print ''.join(rez)
Self-contained Python solution using maketrans and find

Since I was solving the last few problems using maketrans, using str.translate appealed to me

 
import string, urllib2
 
def main() :

    page = urllib2.urlopen('http://www.pythonchallenge.com/pc/def/equality.html').read()
    junk  = page.partition('<!--')[2].partition('-->')[0].strip()

    trans = string.maketrans(string.ascii_lowercase+string.ascii_uppercase,
        '0'*len(string.ascii_lowercase)+'1'*len(string.ascii_uppercase))
    sense = junk.translate(trans)

    pointer = -1
    while True :
        pointer = sense.find('011101110',pointer+1)
        if pointer == -1 : break
        else : print junk[pointer+4]

main()

Wuelfhis style solution

data="""all data pasted here"""
rpt=''
data=data.replace("\n","")

patt=re.compile("([a-z][A-Z][A-Z][A-Z][a-z][A-Z][A-Z][A-Z][a-z])")
m=re.findall(patt,data)
print m

for h in m:
	rpt+=h[4]
print rpt

#la respuesta linkedlist
#lo colocas en el navegador y te manda a linkedlist.php pones esto y voila

C, slowly

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

enum {
        UP,
        LO
};

char getchars(int num, int fd, int ul, char ** save);

int main(void)
{
        int fd;
        int i;
        char c;                                  /* the interesting letters */
        char bsave[4], esave[4];                 /* begin, end */
        char * bsp = bsave, * esp = esave;       /* bsave, esave ptr */
        int found = 0;

        memset(&bsave, 0, sizeof(bsave));
        memset(&esave, 0, sizeof(esave));

        fd = open("3-re.txt", O_RDONLY);
        if (fd == -1) {
                fprintf(stderr, "Could not open file.\n");
                return 1;
        }

        for (i = 1; /* endless */; i++) {
                if ((getchars(1, fd, LO, NULL)) &&
                    (getchars(3, fd, UP, &bsp)) &&
                    (c = getchars(1, fd, LO, NULL)) &&
                    (getchars(3, fd, UP, &esp)) &&
                    (getchars(1, fd, LO, NULL))) {
                        /* Found a character */
                        fprintf(stderr, "%c", c);
                }
                /* Reset file position to the next place */
                lseek(fd, i, SEEK_SET);
        }

        /* Not reached */
        return 0;
}

/* Get "num" characters from file "fd" and see if they are of the case "ul"
 * (upper or lower). If they all are the correct case, save the letters into "save" 
 * and return the last letter found.
 * Otherwise return false.
 */
char getchars(int num, int fd, int ul, char ** save)
{
        int (* funcp)(int c);
        char * ptr;
        char buf[num + 1];
        int i = 0;

        memset(&buf, 0, sizeof(buf));

        switch (ul) {
                case UP:
                        funcp = isupper;
                        break;
                case LO:
                        funcp = islower;
                        break;
                default:
                        return 1;
                        break;
        }

        /* Get "num" letters from the file */
        errno = 0;
        if (read(fd, buf, num) <= 0) {
                if (errno)
                        perror("Couldn't read");
                else
                        fprintf(stderr, "\nEOF\n");
                close(fd);
                exit(1);
        }

        /* For every letter matching the case we wanted, increment i */
        for (ptr = buf; ptr <= &buf[num] && funcp((int) *ptr); ptr++)
                i++;

        /* If all letters were the correct case, copy these letters to save if
         * asked, and return the last letter we found; otherwise return false */
        if (i == num) {
                if (save)
                        strncpy(&(*save[0]), buf, 3);
                return *(ptr - 1);
        } else {
                return 0;
        }
}

Scala

Use case classes and pattern matching to find the specific combination of sBBBsBBBs.


abstract class Letter( c :Char ){ override def toString = c.toString }

case class Small( c :Char ) extends Letter( c )
case class Big( c :Char ) extends Letter( c )


object P3
{
  def main( args :Array[String] )
  {
    // this converts big string to List[Char]
    val data = PcLib.loadData( 3 ).flatten

    // check all groups of 9 (I checked manually the start and end of the string doesn't match)
    val matches = data
      .map{ c => if( c.isLowerCase ) Small( c ) else Big( c ) }
      .sliding( 9 )
      .filter{ list => 
        list match
        {
          case List( Small(_), Big(_), Big(_), Big(_), Small(_), Big(_), Big(_), Big(_), Small(_) ) => true
          case _ => false
        }
      }
      .toList
    
    matches.foreach( m => println( m.mkString ) )
    
    println( "answer: " + matches.map{ _(4) }.mkString )
  }
}
Output:

qIQNlQSLi
eOEKiVEYj
aZADnMCZq
bZUTkLYNg
uCNDeHSBj
kOIXdKBFh
dXJVlGZVm
gZAGiLQZx
vCJAsACFl
qKWGtIDCj
answer: linkedlist

Racket solution

Note that the text is parsed from the html online. Solution based on regular expressions.

#lang racket
(require net/url)

; Get the text from the html
(define text (list-ref
               (regexp-split #rx"(\n-->)|(<!--\n)"
                             (port->string
                              (get-pure-port (string->url "http://www.pythonchallenge.com/pc/def/equality.html"))))
              1))

; Actually get the answer as a string
(list->string (map (lambda (m) (string-ref m 4))
                   (regexp-match*  #px"[^A-Z]([A-Z]{3})[a-z]([A-Z]{3})[^A-Z]" text))) 

Python If statments solution


>>> import string
>>> data """ import from source page """
>>> i,a,b,c=0,'','',''
>>> for a in data:
	if data[i] in string.lowercase[:26]:
		if data[i+1] in string.uppercase[:26]:
			if data[i+2] in string.uppercase[:26]:
				if data[i+3] in string.uppercase[:26]:
					if data[i+4] in string.lowercase[:26]:
						b=b+data[i+4]
						if data[i+5] in string.uppercase[:26]:
							if data[i+6] in string.uppercase[:26]:
								if data[i+7] in string.uppercase[:26]:
									if data[i+8] in string.lowercase[:26]:
										c=c+b[-1]
	i=i+1
Python with functions without RE

On Linux systems you can check the running time with this command:

time python t.py 
linkedlist

real    0m0.067s
user    0m0.064s
sys     0m0.000s
It takes 0.067 seconds on my machine. - Diogo Kersting

def count_upper_before(index):
    count=0
    for i in xrange(index-1,-1,-1):
        if text[i].isupper():
            count+=1
        else:
            break
    return count

def count_upper_after(index):
    count=0
    for i in xrange(index+1,len(text)):
        if text[i].isupper():
            count+=1
        else:
            break
    return count

text='''kAewtl(...)SipiqBd
'''

for index in xrange(0,len(text)):
    if text[index].islower():
        if count_upper_before(index) == 3 and count_upper_after(index) == 3:
            sys.stdout.write(text[index])
print ''
gawk 4.0 solution

by derekschrock

match( $0, /(^|[^[A-Z])[A-Z]{3}[a-z][A-Z]{3}($|[^A-Z])/ ) {
    s = substr( $0, RSTART, RLENGTH )
    if( s ~ /^[A-Z]/ ) { o = 4 } else { o = 5 }
    printf substr( s, o, 1 )
}
ECMAScript 5 solution

This could be done much more easily using regular expressions, but it's fun to tamper with String.prototype.

var fs = require('fs');
var character_soup = fs.readFileSync('level_03.txt').toString();
var solution = ''

String.prototype.isUpper = function() {
    if ("ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(this[0]) !== -1) {
        return true;
    }
    else {
        return false;
    }
};
String.prototype.isLower = function() {
    if ("abcdefghijklmnopqrstuvwxyz".indexOf(this[0]) !== -1) {
        return true;
    }
    else {
        return false;
    }
};

for (var i = 0; i < character_soup.length; i += 1) {
    if (
        character_soup[i + 8] &&
        character_soup[i + 0].isLower() && 
        character_soup[i + 1].isUpper() &&
        character_soup[i + 2].isUpper() &&
        character_soup[i + 3].isUpper() &&
        character_soup[i + 4].isLower() &&
        character_soup[i + 5].isUpper() &&
        character_soup[i + 6].isUpper() &&
        character_soup[i + 7].isUpper() &&
        character_soup[i + 8].isLower()
    ) {
        solution = solution + character_soup[i + 4];
    }
}
console.log(solution);
// Andy Short 2012
Another Perl solution

This solution was moved from Level 2 to Level 3... as this actually belong here. It was originally posted in Level 2 by mistake by the original coder.

#!/usr/bin/perl
use warnings;
use strict;

use WWW::Mechanize;

my $url = q[http://www.pythonchallenge.com/pc/def/equality.html];

my $m = WWW::Mechanize->new();
$m->get($url);

my $c = $m->content;

$c =~ m/(?:\-\-)(.*)(?:\-\-)/gs;
my $chars = $1;

print find_three($chars);

sub find_three {
    my ($text) = @_;
    my @text = ($text =~ m/[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]/g);
    for my $t (@text) { print $t. "\n"; }
}
_________________________________________________
4:
Intro

The page suggests a link to linkedlist.php?nothing=12345, when you go inside you get:

and the next nothing is 92512
So you browse to linkedlist.php?nothing=92512 and see:

and the next nothing is 64505
And you browse to linkedlist.php?nothing=64505 and see:

Your hands are getting tired and the next nothing is 50010
Since your hands are tired, you start to look for someone that will do this for you:

The script

>>> import urllib, re
>>> prefix = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
>>> findnothing = re.compile(r"nothing is (\d+)").search
>>> nothing = '12345'
>>> while True:
...     text = urllib.urlopen(prefix + nothing).read()
...     print text
...     match = findnothing(text)
...     if match:
...         nothing = match.group(1)
...         print "   going to", nothing
...     else:
...         break
Simple
import urllib
import urllib2

data= {}
number = '12345'

for i in range(400):
	data['nothing'] = number
	url_values = urllib.urlencode(data)
	url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php'
	full_url = url + '?' + url_values
	
	foo = urllib2.urlopen(full_url)
	foo = foo.read()
	print foo
	foo = foo.split(" ")
	
	number = [i for i in foo if i.isdigit()][0]

How to Cheat:

import urllib


def gotonextpage():
    urltoget = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="+nextnum
    
    
nextnum = "12345"
for i in range(0,400):
    getnewnum = []
    #follow url path by inputting next number into website chain
    
    urltoget = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="+nextnum
    content_of_url = urllib.urlopen(urltoget).read()
    
    for i in range(0, len(content_of_url)):
        if content_of_url[i].isdigit():
            getnewnum.append(content_of_url[i])
    
    print content_of_url
    
    nextnum = "".join(getnewnum)
    
    gotonextpage
The function may be unnecessary. After rejoicing that it worked, I wondered WHY it worked....when it got to the "Divide by two" page it should have been stuck, since there was no number. How the hell did it advance?? Then I realized: If you put a blank nothing into the php at any time, you skip half the puzzle.

I actually re-did the problem the "right" way to see if it had a secret level....but it was just the next one after a lot more trouble. I think the blank nothing might have been a glitch.


Shell oneliner alternative

NOTHING=00000
while [ -n "$NOTHING" ] ; do 
  NOTHING=`lynx --dump "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=$NOTHING" | awk '{print $6}'`; 
  echo $NOTHING; 
done
On a given point you see `keep', so go to the previous number and look for the hint in the browser.

Shell script

#!/bin/bash

next=12345
for i in `seq 1 400`
do
    echo "the next is $next"
    wget -O nothing.txt -o log http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="$next" 
    echo "" >> nothing.txt
    next=`grep -o 'the next nothing is [0-9]*' nothing.txt | grep -o '[0-9]*'`
    hints="and the next nothing is $next"
    otherMessage=`echo "$hints" | diff - nothing.txt`
    
    if [ "$otherMessage" != "" ]
    then
        cat nothing.txt
        echo "continue?(yes/no)"
        read confirm
        if [ "$confirm" != 'no' ]
        then
            continue
        else
            exit 0
        fi
    else
        continue
    fi
done
Some parts maybe not so good. If there are other solutions with shell( sed awk ..), just put it here.

Shell script (2)

#!/bin/bash
##########################################
# Challenge 4
##########################################
# empty temporary files used
>debug                      # Wanna debug?
# Initialize variables
nothing=12345
link="http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
# Logic starts here
echo $nothing
while true
do
        rawstring=$(elinks --dump $link$nothing|tee -a debug)
        screenedstring=$(echo $rawstring|grep -o "nothing is [[:digit:]][[:digit:]]*" || { read -p "rawstring = $rawstring. Enter new nothing: " userinput ;echo "nothing is $userinput" ; } )
        nothing=$(echo $screenedstring|tee -a debug|awk '{print $3}')
        echo $nothing
done

jaY 00:46, 23 Mar 2010 (PDT)

Real oneliner solution

The whole thing may be solved using this one liner ("perl" may be replaced with "ruby" as well, PerlLover):

perl -wle '$n = 12345; print $n = $1 while `GET "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=$n"` =~ /(\d+)$/'
Only if by solved you mean print a bunch of numbers without providing the url of the next challenge. Your solution is still 11 steps away from the end.

Some interesting observations while it runs

It might take a few minutes for it to run. In the meanwhile, most people reported that they drank coffee and relaxed in front of their consoles. You won't believe how many people wrote scripts that were just trying to iterate nothing over range(100000) instead of just following the list. They had a LOT of coffee.

Also, people who wrote script that only looked for numbers, and not for "nothing is", were trapped in nothing=61066, try it.

It will also trap you if you enter a nothing beginning with a single quote, i.e. nothing='92512', which is what you get if you use backquotes on a string (it quotes it within the string). If you are so foolish as to do this, you get lost in an endless loop at nothing='72758', since any quoted nothing produces "and the next nothing is 72758". And if you get out of it, by entering nothing=72758 (note the absence of quotes), you get led on a different path than the standard one, but one that still succeeds(eventually).

--WSMcG 22:45, 18 Feb 2006 (MST) Note that if you use something like

text.strip().split()[-1] 
and simply append it to the prefix (which is what I did), you don't need to search for "nothing is". It would be trickier to put the "nothing is" before the end of the sentence when nothing=61066.

Rsplit instead of split & utf-8 decode

Instead of using:

text..split()[-1]
to create a list with n elements, I used right split:

text.rsplit(' ', 1)[1]
Also, I found out that:

resposne = urllib.request.urlopen(prefix+number)
source = resposne.read()
returns byte object, which had to be converted to string before splitting, using eather

str(source, encoding='utf-8')
or

source.decode() #defaults to utf-8 encoding 
Start to end Perl Solution

#!/usr/bin/perl -w
use LWP::Simple; # This is the WWW lib for perl - if you don't have this for some reason
#                # then simply replace the line $_ = get... with $_ = `curl "http://www.py...?nothing=$nothing`;
#                # obviously replacing the above with the full url...
$i = 0; # Current iteration
$nothing = (defined($ARGV[0]) ? $ARGV[0] : 12345); # Check if argument was given on the command line, else use
#                                                  # 12345
print "Starting with nothing: ${nothing}\n";
while($i < 400) # As per suggestion in source code, 400 iterations should be enough...
{
   $_ = get "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=$nothing";
   $pattern = "and the next nothing is ";
   chomp;
   $_ =~ s/$pattern//o;
   if (length($_) != 5)
   {
      print "Failing at: ${i}";
      print "\n";
      print $_;
      print "\n";
      if (/\D/)
      {
         if (/tired/) {
            $nothing = substr($_, -5);
            print "Found string \"tired\"! Using number ${nothing}!\n";
         } elsif (/double/) {
            $oldnothing = $nothing;
            $nothing = $nothing * 2;
            print "Found text \"double\"! Doubling from ${oldnothing} to ${nothing}\n";
         } elsif (/Divide by two/) {
            $oldnothing = $nothing;
            $nothing = $nothing / 2;
            print "Found text \"Divide by two\"! Dividing from ${oldnothing} to ${nothing}\n";
         } elsif (/misleading/) {
            $nothing = substr($_, -5);
            print "Found misleading section. Using number ${nothing}\n";
         } elsif (/html/) {
            print "Found URL!\nURL: http://www.pythonchallenge.com/pc/def/${_}\n";
            exit(0);
         } else {
            print "Failed after ${nothing}\n";
            die;
         }
      } else {
         $nothing = $_;
         print "Resolved ${_} into ${nothing}\n";
      }
   } else {
      $nothing = $_;
      $i++;
      print "Iteration: ${i}, Nothing: ${nothing}\n";
   }
}
I have commented the code where I believe it may be a bit odd looking, but otherwise it is all pretty obvious to read I think... It is definitely not the cleanest way to do this as for the misleading section and hands are tired section, it would make more sense to just look in the entire string for a five digit number but my regex was facing problems where perl was stopping at zeroes in the number and so was detecting 3 or 4 digit numbers. This solution runs straight from the beginning (nothing 12345) to the end (peak.html) in one go with no stops in one minute 10.993 seconds on my computer... I will try and write a python version of this as soon as I get around to learning it... In the meanwhile I'm just doing all of the challenges in perl...

An obstacle in the way?

The good thing about this script is that it writes what it fetches from the net, before analyzing it, so you can see what caused the loop to stop. After it runs for awhile you'll get:

...
and the next nothing is 92118
   going to 92118
Yes. Divide by two and keep going.
I've always wondered why people wrote scripts that could not handle this special case... :), so the best thing to do at the moment is to set nothing=str(92118/2) and rerun the while-loop:

...
and the next nothing is 65667
   going to 65667
peak.html
So we are heading to peak.html !

Long (and complete) Solution

#!/usr/bin/env python

import re
import urllib

url="http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
nothing = "12345"
search = re.compile(" (\d*)$")
search_html = re.compile("\.html$")

for i in xrange(300): 
    print "%s: " % nothing,

    line = urllib.urlopen( "%s%s" % (url,nothing) ).read()
    print line

    # handle the solution (last) line
    if search_html.findall (line):
        break
        
    match = search.findall (line)
    if match:
        # next nothing
        nothing = match [0]
    else:
        # handle the divide by two line
        nothing = str (int (nothing) / 2 )
Another Long (and complete) Solution - (functional-style)

I think this is a bit more readable because the required processing for each case is encapsulated in functions that are tested in the loop, which is now more abstract: apply all patterns to the text, if none matches, print the thing and die. If a new pattern is found you may simply define the new handler function, add it to the list and re-run, no need to mess with the main loop... function dispatchers are way cooler than fattening 'if's. This way we have procedural, object-oriented and "functional" solutions to the challenge listed on this page :-)

#!/usr/bin/env python

from urllib import urlopen
import re
import string

# Handlers for each pattern found so far
# IN: previous sequence and contents of new page
# OUT: a tuple, the first member indicates success or failure
#      the second member is the next sequence to apply

def h1(nseq, s):    # first pattern: nothing=x | nothing is x
    p = re.compile('nothing[^\d]+(\d+)')
    r = p.search(s)
    if r:
        return (True, r.group(1))
    else:
        return (False,)

def h2(nseq, s):  # second pattern: divide by 2
    if s.find('Yes. Divide by two and keep going.')!= -1:
        return (True, str(int(nseq) / 2))
    else:
        return (False,)

handlers = [h1, h2] # list of handlers to be tested in main loop

# MAIN LOOP
nseq = '12345'       # initial value found in hint page
for i in range(400):  # hint page again: "400 repetitions should be more than sufficient"
    url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%s, ' % nseq
    s = urlopen(url).read()
    for h in handlers:
        r = h(nseq, s)
        if r[0]:
            print '[%s]: %s' % (nseq, s)
            nseq = r[1]
            break
    
    if r[0]==False:   # if none of the patterns match, print what was found for further inspection
        print nseq, s    
        break
Complete Solution using Regex Lessons Learned in Challenge 3

import urllib
import re
import webbrowser

site = "http://www.pythonchallenge.com/pc/def/"
opt = "linkedlist.php?nothing="
nothing = "12345"

while True:
    text = urllib.urlopen(site + opt + nothing).read()
    print "Fetched text:",text
    if "next nothing is" in text:
        nothing = "".join(re.findall('nothing is ([0-9]*)', text))
        print "Opening URL:",nothing
    elif 'Divide' in text:
        nothing = str(int(nothing)/2)
        print "HA, divided URL:",nothing
    else:
        webbrowser.open(site + text)
        break
A little bit shorter (I guess)

import urllib

nothing = '12345'
while True:
    content = urllib.urlopen('http://pythonchallenge.com/pc/def/linkedlist.php?nothing=%(nothing)s' % locals()).read()
    try:
        nothing = str(int(content.split(' ')[-1]))
    except ValueError:
        if 'Divide' in content:
            nothing = str(int(nothing) / 2)
        else:
            break

print content
Mine:

i=12345 j=i for k in range(0,400):

 url = "http://pythonchallenge.com/pc/def/linkedlist.php?nothing=%d" % j
 s = urllib.urlopen(url).read()
 print "%d (%d) --> %s" % (k+1, j, s)
 j = int( s.split("and the next nothing is ")[-1] )
Once it died, simply replace '12345' with '92118/2' and restart.

Another re solution

import urllib, re

url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='
findn = re.compile(r'nothing is (\d+)').search
n = '12345'

while True:
    text = urllib.urlopen('%s%s' % (url,n)).read()
    print '%s: %s' % (n, text)
    
    try:
        n = findn(text).group(1)
    except:
        if 'Divide by two' in text:
            n = str(int(n) / 2)
        elif '.html' in text:
            print '^ Finished.'
            break
        else:
            print '\n^ unrecognised input.\n'+ url + n
            break

raw_input('press any key to exit...')
edited to use compiled regular expression

Slightly verbose object oriented solution:

#!/usr/bin/python

import curl, sys, re

class Message(Exception):
    """general message"""
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return str(self.value)

class Chaser(curl.Curl):
    def __init__(self, url):
        """establish connection with the host"""

        curl.Curl.__init__(self, url)
        self.nothing = "12345"

    def get_next_nothing(self):
        """get the next nothing"""

        # get the instructions 
        self.get("linkedlist.php", (("nothing", self.nothing), ))
        message = self.body()

        try:
            # try and extract the next nothing
            regex = re.compile(r'the next nothing is (\d+)')
            self.nothing = regex.search(message).group(1)
        except:
            # process any instructions
            if message == "Yes. Divide by two and keep going.":
                self.nothing = str(int(self.nothing)/2)
            else:
                raise Message(message)

        return self.nothing

# the main loop 
if __name__ == "__main__":

    session = Chaser("http://www.pythonchallenge.com/pc/def/")

    tries = 300
    k = 0

    while k < tries:
        try:
            print session.get_next_nothing()
        except Message, error:
            print error
            sys.exit()
        else:
            k += 1
Solution in Ruby

require 'open-uri'
nothing = "12345"
1.upto(400) do |n|
 open("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=#{nothing}") do |f| 
   str = f.read
   if str =~ / next nothing is (\d*)/ then
     newnothing = $1
     puts "#{nothing} -> #{newnothing} \t\t#{str.chomp}"
     nothing = newnothing
   elsif str =~ /Divide by two/ then
     ni = nothing.to_i / 2
     nothing = ni.to_s
   else
     puts str
     raise "Finished!"
   end
 end
end
Another solution in Ruby

 require 'net/http'
 nothing = 12345
 nothing = case( page = Net::HTTP.get(URI.parse("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=#{nothing}")) )
   when /and the next nothing is (\d+)/ then $1
   when /Divide by two/ then nothing.to_i/2
   else puts page
 end while nothing
This is the shortest yet comprehensive way i found for Ruby. I love the fact that control statements in Ruby are treated just like methods, and so i can do nothing = case(...){...} while nothing. Also, puts returns nil, which is why the while ends.

--Teonimesic 14:32, 13 Jul 2010 (PDT)

The shortest ruby solution I could think of

require "open-uri"
n=12345
loop {
    open("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=#{n}") {|f|
        s=f.read
        puts s if s=~/htm/
        n=(s=~/Div/ ? n/2 : s.split[-1].to_i)
    }
}

User-prompted alternative

 import urllib
 template = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
 a = '12345'
 value = 'fish'
 while value != 'dammit, quit':
     while True:
         insert = template + a
         f=urllib.urlopen(insert)
         txt=f.read()
         if txt[-1].isdigit() == False:
             break
         a = txt.split()[-1]
         print a
     print txt
     value = a = raw_input("what is the next value? ('dammit, quit' to quit)")
Why do people use while True?

breaks at the division and final page

 from urllib import urlopen
 import re
 
 num = '92512'
 while num:
      page = urlopen("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%s" % num).read()
      print page
      num = re.findall('\d+$', page)[0]
Complete without "while True" and re

 import urllib2
 nothing = "12345"
 
 while nothing:
     print nothing
     html = urllib2.urlopen('http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=' + nothing).read()
     if "Divide" in html:
         nothing = str(int(nothing) / 2)
     else:
         nothing = .join([item for item in html.split() if item.isdigit()])
 
 print html

 rbowlby83 16:41, 31 Oct 2009 (PST)
Not perfect, but I'm a beginner

I used webbrowser to automatically open 'interesting' pages. The commented print(source) helped me to find obstacles. This chapter was a tough one !

import urllib.request
import webbrowser

def automatic_browsing (url_complete):
    url_begin = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='
    source = 'next nothing is'

    while 'next nothing is' in source: # could find a better condition ?
        print ("Opening :", url_complete)
        source = str(urllib.request.urlopen(url_complete).read())
        # print (source)
        url_end = source.partition('and the next nothing is')[-1]
        url_end = ''.join ([c for c in url_end if c.isnumeric()])

        if url_end != '':
            url_complete = url_begin + url_end

    print (source)
    webbrowser.open (url_complete)

automatic_browsing ('http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345')
automatic_browsing ('http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=8022')
Sam 11:20, 22 May 2012


short complete solution using only re in Python

 import urllib,re
 url = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345";
 while 1:
     sock = urllib.urlopen(url)
     htmlSource = sock.read()
     print htmlSource
     if re.findall('html',htmlSource):	
         break
     match = re.findall('nothing[ a-z]*\d+',htmlSource)
     if match:
         url = re.sub('\d+',re.findall('\d+',match[0])[0],url)
     else:
         url = re.sub('\d+',str(int(re.findall('\d+',url)[0]) / 2),url)
     sock.close()
     print url
another complete solution using re

 import webbrowser
 import string
 import urllib
 import re
 
 html = ""
 s_out = "12345"
 prefix = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
 while html == "":
 	sock =  urllib.urlopen (prefix + s_out)
 	s_in = sock.read()
 	if s_in.find ("Yes. Divide by two and keep going.") > -1:
 		s_out = str (int (s_out) / 2)
 	else:
 		s_out = .join (re.findall ("\d+$", s_in))
 		html = .join (re.findall ("^(\w+).html", s_in))
 	sock.close ()
 	
 webbrowser.open ("http://www.pythonchallenge.com/pc/def/" + html + ".html")
The Moral

Look where you are walking. There may be obstacles (or hints) along the way.
Don't brute force - there is never a need to guess.
PHP Solution

This is a very inelegant solution... hit ctrl-c when you start seeing "peak.html"

$Num = "12345";
for ($i = 0; $i < 400; $i++)
{
    $Str = file_get_contents("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=$Num");
    $Match = "";
    $Ret = preg_match("/and the next nothing is ([\\d]+)$/", $Str, $Match);
    if ($Ret === 1)
    {
        $Num = $Match[1];
        echo "$i: $Num\n";
    }
    else if ($Str == "Yes. Divide by two and keep going.")
    {
        echo("$i: $Num / 2\n");
        $Num /= 2;
    }
    else
    {
        echo "$Str\n";
    }
}
Python Newbies Solution

#!/usr/bin/python
import urllib
import re
num = 27786

urlnum = str(num)
urlstr = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
url = urlstr + urlnum
count = 0
while (count < 300):
	 data = urllib.urlopen(url)
	 newurl =  data.read()
	 newnum =  newurl.split(' ')
         print newnum
if  (newnum[1] == "Divide"):
	 num3 =  int(str((num2))) / 2
	 url = urlstr + str(num3)
else:
 	 num2 = newnum[5]
	 url = urlstr + num2
	 count = count + 1
	 print num2
else:
	 print 'donzer'
Leper421 21:30, 20 Feb 2008 (PST)


Self-contained solution (Python)

This will print the peak url at the end:

   import urllib
   url='http://www.pythonchallenge.com/pc/def/%s'
   u = url % 'linkedlist.php'
   nothing = '12345'
   while nothing.isdigit():
       s = urllib.urlopen(u + '?nothing=%s' % nothing).read()
       nothing = str(int(nothing)/2) if 'Divide' in s else s.split()[-1]
   print url % s
--LKRaider 12:36, 30 Mar 2008 (PDT)

Python KISS solution

import urllib2
import re                                                                                                                                                                                       
nothing=12345                                                                                                                                                                                   
for x in xrange(0,400):                                                                                                                                                                         
    page=urllib2.urlopen('http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%s' % nothing).read()                                                                                    
    if 'Divide by two and keep going' in page:                                                                                                                                                  
        nothing=int(nothing)/2                                                                                                                                                                  
    else:                                                                                                                                                                                       
        occurences=re.findall('[0-9]+',page)
        if occurences:
            nothing=occurences[-1]
        else:
            print page
            break

Avoiding rerunning your script

This was the general solution I came up with after trying out the first couple of pages by hand. I figured that as long as the next page had the same contents as the current page (aside from the node number) it would be safe to continue. This let me solve the problem without having to modify my initial code, as opposed to the majority of the solutions posted here which have all of the special cases hard coded (which you don't know until you've run your script several times). The tradeoff with this approach is that you have to manually type in the next node number 3 times.

   import urllib
   baseUrl = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
   currNode = "12345"
   
   currLine = urllib.urlopen("".join([baseUrl, currNode])).read()
   currNode = currLine.split()[-1]
   
   while 1:
       nextLine = urllib.urlopen("".join([baseUrl, currNode])).read()
       if nextLine.split()[:-1] == currLine.split()[:-1]:
           currLine = nextLine
           currNode = currLine.split()[-1]
       else:
           print "\n", "="*20, "\nNew line found:", nextLine
           print "\nPrevious line:", currLine
           currNode = raw_input("Enter next node: ")
Bash Solution

   #!/bin/bash
   nr=12345
   TMP_FILE="/tmp/python_challenge"
   while true
         do wget -q http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=$nr -O $TMP_FILE
         if grep "and the next nothing is" $TMP_FILE >/dev/null
                 then nr=$(sed "s/and the next nothing is //" $TMP_FILE | sed "s/<\font color=red>Your hands are getting tired <\/font>//")
         elif grep "Yes. Divide by two and keep going." $TMP_FILE >/dev/null
                 then nr=$[$nr/2]
         else
                 final=$(cat $TMP_FILE) && echo $final && exit
         fi
   done
I was wondering why my script passes the 61066-trap. It shouldn't. But it appends this long string to the URL, which is obviously ignored, the next number is 72758 (the same number you get for an empty string) and has no more problems until the end.

ActionScript solution

var responses:Array = new Array();

var request:URLRequest = new URLRequest("http://www.pythonchallenge.com/pc/def/linkedlist.php");
var loader:URLLoader = new URLLoader();
var variables:URLVariables = new URLVariables();
loader.addEventListener(Event.COMPLETE, onComplete);
loadNext(92118/2);

function loadNext(nothing:int){
	variables.nothing = nothing;
	request.data = variables;
	loader.load(request);
}


function onComplete(event:Event){
	var tempArray:Array = String(event.target.data).split(" ");
	var nextToken:int = tempArray[tempArray.length-1];
	responses.push(nextToken);
	trace(event.target.data);
	
	if (responses.length <= 400)
		loadNext(nextToken);
}
The JavaScript Solution

This is a rather odd one... It uses JavaScript and Greasemonkey(which is an extension for FireFox) to automate the process of a) getting the right address and b) rerunning the script on the new location. Didn't do the special case event. It can actually be a one-liner solution if you inline it. Didn't do it for the sake of readability.

// ==UserScript==
// @name          Level4 Solver
// @namespace     http://pythonchallange.com/
// @description   Solves the 4th level
// @include       http://www.pythonchallenge.com/pc/def/linkedlist.php*
// @exclude       http://www.pythonchallenge.com/pc/def/linkedlist.php
// ==/UserScript==

str=document.firstChild.lastChild.lastChild.nodeValue;
sRet=str.match(/([\s\S]*?)(\d+)$/);
a="http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="+sRet[2];
window.location=a;
C++ Solution

Solution using C++ and libcurl. Talk about driving a screw with a hammer :-)

#include <iostream>
#include <string>
#include <sstream>
#include "curl/curl.h"

using namespace std;

static string buffer;

static size_t writer(char *data, size_t size, size_t nmemb, string *buffer)
{
	size_t realsize = size * nmemb;
	buffer->append(data, realsize);
	return realsize;
}

int main()
{
	string url("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=");
	string nothing("12345");

	int i;
	std::stringstream ss;

	CURL *curl;
	CURLcode result = CURLE_OK;

	if ((curl = curl_easy_init()) == NULL) {
		cout << "curl init failed";
	}

	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer);
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &buffer);

	while (result == CURLE_OK) {
		curl_easy_setopt(curl, CURLOPT_URL, (url + nothing).c_str());
		result = curl_easy_perform(curl);

		if (result == CURLE_OK) {
			if (buffer.find("and the next nothing is") != string::npos)
				nothing.assign(buffer.substr(buffer.find_last_of(" ") + 1));
			else if (buffer.find("Yes. Divide by two") != string::npos) {
				ss.clear();
				ss << nothing;
				ss >> i;
				ss.clear();
				ss << i / 2;
				ss >> nothing;
			} else {
				cout << buffer;
				curl_easy_cleanup(curl);
				exit(0);
			}
			buffer.clear();
		} else {
			cout << "Error: " << result;
			exit(-1);
		}
	}
}
Yet another ruby solution

#!/usr/bin/env ruby

require "open-uri"

url_pattern = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="

cur_number="12345"

while true do
    url=url_pattern+cur_number
    puts "URL: "+url
    ctx = open(url).read
    puts "CTX: "+ctx
    if ctx =~ /Divide by two/ then
        cur_number = (cur_number.to_i/2).to_s
    elsif ctx =~ /.*\.html/ then
        result = $~[0]
        puts
        break
    else
        cur_number = ctx.match(/and the next nothing is (\d+)/)[1]
    end
    puts "MAT: "+cur_number
    puts
end

puts "RESULT: "+result
Haskell

import Network.HTTP
import Text.Regex.Posix
import Array

nextNothing n = do
  let url = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=" ++ n
  response <- simpleHTTP (getRequest url)
  body <- getResponseBody response
  putStrLn body
  let nn = (! 1) (body =~ "next nothing is ([[:digit:]]+)" :: (Array Int String))
  nextNothing nn
Newbie Haskell

--Could use a lot of refinement
--Compile with -package tagsoup-[version]

import Text.HTML.Download
import Data.List

main = hop baseURL initNum
       where baseURL = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
             initNum = 12345          

hop :: String -> Integer -> IO()
hop url num = do content <-getPage url num
                 putStrLn content 
                 if "Divide by two and keep going" `isInfixOf` content 
                     then hop url (toInteger (num `div` 2))
                     else hop url (getNothing content)

getPage :: String -> Integer  -> IO String
getPage url num = openURL (url ++ show num)

getNothing :: String -> Integer
getNothing x = if trigger `isPrefixOf` x then read (maybe [] tillNewLine (stripPrefix trigger x)) else getNothing (tail x)
               where trigger = "next nothing is "

tillNewLine :: String -> String
tillNewLine [] = []
tillNewLine (x:s) = if x == '\n' then [] else [x] ++ tillNewLine s
Another Javascript solution

Ok, I'm still use Firefox - Firebug to solve this one


var url="http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=";
var currentNo=18008;//This is the number you get from the page.
var pattern=/\d+/;
var req=new XMLHttpRequest();
var result;
do{
    req.open("get", url+currentNo, false);
    req.send(null);
    console.log(req.responseText);//Must have firebug to work
    currentNo=req.responseText.match(pattern);
    if(currentNo)
        currentNo=currentNo.pop();
    else
    {
        result=req.responseText;
        break;
    }
}
while(true);
result;
Repeat this code sometime and you get the destination "kaep"
Namdx1987

Error Handling Try\Except Recursive Function

import urllib, re, webbrowser as wb
url='http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%s'
def foo(nothing):
    """Run foo(12345) to start"""
    page = urllib.urlopen(url % nothing).read()
    try:
        new = page.split('nothing is ')[1]
        print new
        foo(new)
    except:
        print 'opening webpage...'
        wb.open(url % nothing)

Run foo(12345) to start with the initial value of 'nothing'. If the program encounters exception from trying to find 'nothing' on the page, it will open the URL for your attention. Otherwise it will run itself again with the new value of 'nothing' it has obtained. --Metamemetics 21:12, 10 Dec 2009 (PST)


Another python script

from urllib import urlopen

"""
#1st run start
nothing='12345'
"""

#2nd run start at 92118/2=46059
nothing='46059'
while int(nothing)>0:
    url = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing={0}.html"
    st1 = urlopen(url.format(nothing)).read()
    nothing=st1.split()[-1]
    print nothing, st1
Start with nothing='12345' and run. It stops when nothing='92118. Message says, "Yes. Divide by two and keep going." Start again with nothing='46059'. When it stops we are given the new link.

Symmetry 03:15, 9 Jan 2010 (PST)

An F# Script

open System
open System.Net
open System.Text.RegularExpressions
  
let getNum = // Capture the re in a closure so it's not re-created on each call
  let re = new Regex("\d+$", RegexOptions.Compiled) // check for digits at end of string
  fun str -> re.Match(str).Value
  
let rec getPage num =
  let page = (new WebClient())
              .DownloadString("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=" + num)
  let num' = getNum page
  Console.WriteLine(page)  // just so we can watch the progress
  match num' with
  | s when String.IsNullOrWhiteSpace(s) -> 
    if page.StartsWith("Yes.") then
      getPage ((Int32.Parse(num) / 2).ToString())
    else
      page
  | _ -> getPage num'   // tail recursion - no stack overflow possibility
    
getPage "12345"
@Prydie's Attempt

from urllib2 import *
import re
number = 12345
while  number:
	url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%d' % number
	data = urlopen(url).read()
	try:
		number = int(re.search('[0-9]+$', data).group(0))
	except:
		if "Divide" in data:
			number = number / 2
		else: 
			print data
			break
--Efvincent 23:41, 22 Mar 2010 (PDT)


Wuelfhis Style

import urllib

start="12345"
divi="Yes. Divide by two and keep going."
nothing="and the next nothing is "

for i in range(0,401):
	data=urllib.urlopen("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="+start)
	print "url= "+"http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="+start
	text=data.read()
	print text
	if nothing in text:
		start=text[text.find(nothing)+24:len(text)]
	else:
		if divi in text:
			start=str(int(start)/2)
#
#respuesta peak.html

Newbie Java Code

I had to manually terminate the program after each run and I had to manually enter the next url a couple times, but it eventually got me where I wanted to go.

import java.net.*;
import java.io.*;
import java.util.regex.*;

class Challenge5 {
    public static void main(String args[]) throws Exception {
        String urlNumber = "12345";
        String address = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=";

        for (int j=0; j<400; j++) {
            URL pyChallenge = new URL(address + urlNumber);
            BufferedReader in = new BufferedReader(
                   new InputStreamReader(pyChallenge.openStream()));

            String inputLine;
            String webPage = "";

            while ((inputLine = in.readLine()) != null) {
                System.out.println(inputLine);
                webPage = webPage + inputLine;
            }

            in.close();

            Pattern p = Pattern.compile("the next nothing is [0-9]*");
            Matcher m = p.matcher(webPage);

            while (m.find()) {
                int numberLength = m.group().length() - 20;
                urlNumber = "";
                for (int i=0; i<numberLength; i++) {
                    urlNumber = urlNumber + webPage.charAt(m.start() + 20 + i);
                }
            }
        }
    }
}
Ellipsoid 13:24, 26 Oct 2010 (PDT)


C# newb Attempt

    The reson most of the functions return values to the calling function is that it was the easyest way to cleanup the code when I realised my
first attempt was a meandering mess. It still is :).
using System;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Net;

namespace LinkedList
{
	class MainClass
	{		
		static string Template = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=";
		static string NextNothing = "12345";
		
		static Regex NextNothingValue = new Regex(@"(\d+)$");
		
		public static void Main ()
		{
			Run();
			
		}
		static void Run()
		{
			string nothingtext;
			string oldnothing;
			string newnothing;
			
			for(int i = 0; i <= 450; i++){
				oldnothing = NextNothing;
				nothingtext = GetNextPage(NextNothing);
				
				newnothing = GetNextNothing(nothingtext);
				// if GetNextNothing() fails it returns the previous nothing
				if(oldnothing == newnothing)
					if(QueryUser(nothingtext)){
						break;
					} else {
						newnothing = GetUserNextnothing(nothingtext);
					}
				
				NextNothing = newnothing;
			}
		}
		
		static string GetNextPage(string nextnothing)
		{
			StringBuilder sb = new StringBuilder();
			byte[] buf = new byte[8192];
			
			HttpWebRequest request = (HttpWebRequest)
				HttpWebRequest.Create((Template + nextnothing));
			
			HttpWebResponse response = (HttpWebResponse)
				request.GetResponse();
			
			Stream resStream = response.GetResponseStream();
			
			string tempString = null;
			int    count      = 0;

			do
			{
				count = resStream.Read(buf, 0, buf.Length);
	
				// make sure we read some data
				if (count != 0)
				{
					tempString = Encoding.ASCII.GetString(buf, 0, count);
					sb.Append(tempString);
				}
			}
			while (count > 0); // any more data to read?
			Console.WriteLine(tempString);
			return tempString;
		}
		
		static string GetNextNothing(string nothingtext)
		{
			string nextnothing;
			
			if (NextNothingValue.IsMatch(nothingtext)){
				//seems to default to second match :)
				nextnothing = (NextNothingValue.Match(nothingtext)).ToString();
				return nextnothing;
			} else {
				nextnothing = NextNothing;
				return nextnothing;
			}
		}
		
		static bool QueryUser(string nothingtext )
		{
			Console.WriteLine("an unencounterd string has arisen");
			Console.WriteLine("The string is : " + nothingtext);
			Console.WriteLine("if Task is compleated press y");
			if (Console.ReadLine() == "y"){
				return true;
			} else {
				return false;
			}
		}
		
		static string GetUserNextnothing(string nothingtext)
		{
			string feedback;
			
			Console.WriteLine("please enter next nothing");
			feedback = Console.ReadLine();

			return feedback;
		}
	}
}
Dillor 10:16, 20 Feb 2011 (PDT)

A Python solution

Uses the re module and has unused error handling. Tab indentation instead of four spaces. Should copy and paste fine, if anyone wants to see the results be sure to import urlopen:

try:
	from urllib.request import urlopen
except ImportError:
	from urllib2 import urlopen
Source code:

import re
u.close()
u = urlopen("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345")
nothingpat = re.compile("and the next nothing is " '(\d+?){,}')
number = ""
counter = 1
for j in range(1,211):
	for i in u.readlines():
		for l in nothingpat.finditer(i):
			if nothingpat.finditer(i):
				for k in l.group():
					try:
						check = int(k) + int(1)
						number = number + k
					except ValueError:
						pass
			else:
				pass
	u.close()
	counter = counter + 1
	if counter == 199:
		number199 = number
	if counter == 200:
		number = float(number199) / float(2)
		print
		print number
		print
	u = urlopen("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=" + str(number))
	print i,
	print "|",
	print number,
	print counter,
	print "|"
	number = ""
PandemicGander 14:52, 27 Feb 2011 (PST)

Another python solution (ugly)

I just started learning Python last night, so this isn't the most elegant solution. Excuse my newbieness.

#!/usr/bin/python
import urllib.request
import re

# Space for the solution!
solution = ""

# I used this as a shortcut while working around the "divide by two" issue
nothing = input('Supply a \'nothing\' value, or press enter to start with the default\n')

if (nothing == ''):
        url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345' # The default starting URL

# Make sure the supplied value is a number
elif not (nothing.isnumeric()):
        print('Invalid value')

# Use the supplied value of 'nothing' 
else:
        url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=' + nothing
i = 1

def traverse(url):
        '''Function to find the value of the next nothing'''
       
        global i # Keep count of the iterations
        global nothing # The all-important 'nothing' :)
        global solution # Where the solution will end up
        
        # Fetch the page from the URL supplied to traverse()
        req = urllib.request.Request(url)
        f = urllib.request.urlopen(req)
        page = f.read()
        text = page.decode("utf8")
        
        print(i, ': ', text) # Print ": "
        text = text[::-1] # Reverse the text (ugly hack to get past the misleading number)
        
        pattern = re.compile("[0-9]+") # Search for the number
        m = re.search(pattern, text)   #
        
        if (m == None): # No numbers found?
                patt = re.compile("html")       # Check if we've found the solution.
                s = re.search(patt, text[::-1]) # (We have to re-reverse the text... ugly, like I said)
                if (s.group(0) == 'html'):
                        solution = text[::-1]   # Output the solution and set nothing to 0
                        del nothing             #
                        nothing = 0             #
                else:   # No solution yet. :(
                        nothing = str(int(nothing) / 2) # Divide previous nothing by 2 to continue
        else:
                nothing = m.group(0)[::-1] # Set value of nothing according to instructions on the page (not forgetting to re-reverse)
        
        i += 1 # Increment the counter
        return nothing # Output nothing value

nothing = traverse(url) # Get the value from the initial page, then enter loop.
while i < 300: # Nice long loop
        if (nothing == 0): # Solution found!
                print('Finished! The solution is:', solution.strip())
                break # Done
                
        else:  # Keep hammering the server :P
                url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=' + nothing
                nothing = traverse(url)
--Xlator 21:39, 8 Mar 2011 (PST)

Interactive python solution

    import re, urllib
    nothing =12345
    while nothing:
        page = urllib.urlopen("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="+ str(nothing))
        soub = page.read()
        a ="A".join(re.findall(r"next nothing is (\d+)", soub))
        
        print soub,"||", a,"||", i
        if (a == ""):
            a = raw_input("input a: ")
            a = eval(a)
            print soub,"||", a,"||", i
        nothing = a
The advantage of this is that you can control the flow and u dont have to rewrite program after that "divide by 2" sections appear. --Anuvin 17:11, 13 Mar 2011 (PDT)

Lua solution

Using LuaSocket

local http = require 'socket.http'

local url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='
--local num = '12345'
local num = string.format("%d", 92118/2)

for i=1,400 do
    page = http.request(url .. num)
    print(page)
    num = page:match('nothing is (%d+)')
end

Racket solution

#lang racket
(require net/url)

(define (get-url-text n) ; Gets url contents
  (call/input-url 
   (string->url
    (string-append "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=" n))
   get-pure-port
   (lambda (p)
     (port->string p))))

(let loop ([nothing "12345"] ; Loop. will compute the division and go on just fine
           [res '()])
  (let* ([answer (get-url-text nothing)]
         [next-nothing-match (regexp-match #rx"next nothing is ([0-9]+)" answer)]
         [divide-match (regexp-match #rx"Divide" answer)]
         [next-nothing (cond [next-nothing-match (cadr next-nothing-match)]
                             [divide-match (number->string (/ (string->number nothing) 2))]
                             [#t #f])]
         [next-res (cons nothing res)])
    (printf "~a: ~a~n" (length res) answer) ; log iterations
    (sleep 1) ; Be nice...
    (if next-nothing
        (loop next-nothing next-res)
        answer))) ; return a string with the next URL ("peak.html")
A Python Neophyte's Solution.

import urllib2

nothing = 1

for i in range(350):
    r = urllib2.Request('http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%d' % int(nothing))
    s = urllib2.urlopen(r)
    pagemsg = s.read()
    nothing = pagemsg.strip('and the next nothing is')
If you start out on a 'nothing' that isn't 12345, you don't encounter the 'divide by two' mess.

Perl solution (shorter)

#! /usr/bin/perl

use LWP::Simple; #needed to download the webpage

$content = get("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345");
$t = 0;
while($t <=400){
	@value = ($content =~ m/[0-9]+/g);
	$content = get("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=".$value[0]);
	print "$content \n";
	$t++;
}
Re and counting iterations

import re, urllib
a = 1
num = "12345"
p = re.compile('.*(and the next nothing is )([0-9].*$)')
while True:
    text = urllib.urlopen('http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=' + num).read().replace('\n','')
    if a == 251:
        print text
        break
    if a == 86:
        tmp = float(num)
        num = str(tmp/2) 
    else:
        num = p.match(text)
        p.match(text)   
        num = num.group(2)
    a += 1
Python with Requests

Uses Requests.

import requests
import re

next = "12345"

while next.isdigit():
    p = requests.get('http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=%s' % next)
    if 'Divide' in p.content:
        next = str(int(next) / 2)
    else:
        message = "".join(re.findall('nothing is [0-9]*', p.content))
        next = message.lstrip('nothing is ')

print p.content
Shell with curl

node=1234
url="http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="
while true;do s=$(curl -s "${url}${node}");node="${s##* }";echo "$node"|grep '[[:alpha:]]' && break;done
echo "${url%/*}/$node"
derekschrock

Javascript / node.js

Long solution using javascript and node.js (v0.6.10+)

"use strict";

(function () {
    var http = require("http"),
        count = 0,
        value = [],
        resData = "",
        prevValue = [],
        path = "/pc/def/linkedlist.php?nothing=",
        httpOption = {
            "host": "www.pythonchallenge.com",
            "port": 80,
            "path": "" 
        };
        
  
    var getNextNothing = function (nothing, callback) {
        
        resData = "";
        httpOption.path = path + nothing;
        http.get(httpOption, function(res) {
            res.setEncoding("ascii");
            res.on("data", function(data) {
                if(res.statusCode === 200) {
                resData = resData + data;
            }
            }).on("end", function () {
                callback(resData);
            }).on("error", function(err) {
                console.log("Error : " + err.message);
                process.exit();
            });
        });
    };
    
    
    var run = function (retValue) {

        if (count === 400) {
            console.log("\nExiting ... Maximum Number of Iterations reached");
            process.exit();
        }
        value = retValue.match( /\d+/g );
        if (value === null || value.length > 1) {
            if (retValue.match("Divide by two")) {
                value = prevValue / 2;
            }
            else if (retValue.match("misleading numbers")) {
                value = value[1];
            }
            else {
                console.log("Server response: " + retValue);
                process.exit();
            }
        }
        
        count += 1;    
        console.log("Request #" + count + "\nServer response : " + retValue + "\nusing: " + value + " for next request.\n" );
        prevValue = value;
        getNextNothing(value, run);       
    };
        
    run("and the next nothing is 12345");
})();
ECMAScript 5 solution (also using node)

No error handling, and does not stop on the solution automatically. Getting hacky.

var http = require('http');

var findNumber = function(string) {
    for (var i = 0; i < string.length; i += 1) {
        if (!isNaN(parseInt(string.slice(i), 10))) {
            return parseInt(string.slice(i), 10);
        }
    }
};


var request = function(host, path) {
    http.get({ host: host, path: path }, function(response) {
        response.on('data', function(chunk) {
            var data = chunk.toString();
            console.log(data);
            if (data.indexOf('Yes. Divide by two and keep going.') !== -1) {
                request('www.pythonChallenge.com',
                        '/pc/def/linkedlist.php?nothing=' +
                        (findNumber(path) / 2).toString());
            }
            else {
                request('www.pythonchallenge.com',
                        '/pc/def/linkedlist.php?nothing=' +
                        findNumber(data.slice(data.indexOf('nothing is'))));
            }
        });
    });
};

request('www.pythonchallenge.com', '/pc/def/linkedlist.php?nothing=12345');
//Andy Short 2012

Erlang

Just started going through with erlang and noticed this one is missing. This solution doesn't handle the div/2 automatically and requires a manual restart of the process.

-module(challenge).
-export([
    pc4/0
]).
pc4(StartAt) ->
    BaseUrl = "http://pythonchallenge.com/pc/def/linkedlist.php?nothing=",
    Next = fun (Body, Last) ->
        case re:run(Body, "and the next nothing is ([0-9]+)", [{capture, [1], list}]) of
            {match, Result} -> hd(Result);
            nomatch -> %% yes, divide by two or result
                "break"
                %%integer_to_list(element(0, string:to_integer(Last)) div 2)
            end
        end,
    Request = fun(Url) ->
            {ok, {_, _, Body}} = httpc:request(get, {Url, []}, [], []),
            io:format("~s~n", [Body]),
            Body end,
    Process = fun(Rec, Num) ->
            Response = Request(BaseUrl ++ Num),
            Rec(Rec, Next(Response, Num)) end,
    Process(Process, StartAt).

c(challenge).
challenge:pc4("12345").
Another simple python solution

import urllib
def __main__():
	i = 0
	nothing='12345'
	while i < 400:
		filehandle = urllib.urlopen('http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='+nothing)
		list_php = filehandle.read()
		list_php = list_php.split()
		print list_php
		for word in list_php:
			if word.isdigit():
				nothing=word
				
		i += 1

if __name__=="__main__":__main__()

______________________________________________________
What is peak hell? After you say it loudly a few times, it starts to sound like pickle.

so in a moment of enlightenment you:

>>> import pickle, urllib
>>> banner = urllib.urlopen('http://www.pythonchallenge.com/pc/def/banner.p').read()
>>> banner = pickle.loads(banner)
>>> banner
[[(' ', 95)], [(' ', 14), ... (omitted)
>>> len(banner)
23
You see that the banner is a list of 23 lists of pairs. This is some sort of run-length encoding, each character is followed by the number of times it should be repeated. Each toplevel list represents a line.

>>> for line in banner:
...     print "".join(map(lambda pair: pair[0]*pair[1], line))
Then, a nice banner is displayed which says "CHANNEL"

A possibly clearer way uses a list comprehension instead of map():

>>> for linelist in banner:
...     line = [ch * count for ch, count in linelist]
...     print "".join(line)
Or, in Python 2.4 (using generator expressions (PEP289)):

>>> for linelist in banner:
...     print "".join(ch * count for ch, count in linelist)
Or, all on one line, (with two list comprehensions):

>>> print '\n'.join(["".join([i[0]*i[1] for i in b]) for b in banner])
Contents [hide]
1 Simple Solution
2 Explanation
3 Short and pretty
4 A prettier solution
5 Mine
6 Output to file
7 Another
8 Simple
9 Very Simple
10 Very Simple to print
11 Real One Liner
12 Without Pickle
13 Using reduce
14 Vertical (my console isn't 96 chars wide!)
15 In Ruby(Depickling done in Python)
16 Another Ruby solution
17 Yet Another Ruby solution
18 Nested loops
19 Nested loops redux
20 As a Bash Script
21 Haskell
22 Using "future Python"
23 Using Python3.1 Specifically
24 Wuelfhis Way
25 ECMAScript 5 solution (using python2.x for unpickling)
Simple Solution

#!/usr/bin/python

import pickle;

file = open('banner.p', 'r');

unpickled = pickle.load(file);

for j in unpickled:
	print "".join([i[1] * i[0] for i in j])

exit;
Explanation

The expression "lambda pair: pair[0]*pair[1]" means to define a lambda function that takes a pair and returns pair[0]*pair[1], for example:

>>> m = lambda pair: pair[0]*pair[1]
>>> m((3,4))
12
>>> m(('c', 6))
cccccc
Therefore, map(lambda pair: pair[0]*pair[1], line) applies this to all the pairs in the line, and we only have to concatenate them by using "".join().

Short and pretty

import urllib2, sys, pickle
data = pickle.loads(urllib2.urlopen('http://www.pythonchallenge.com/pc/def/banner.p').read())
for line in data:
    for char, count in line: sys.stdout.write(char * count)
    sys.stdout.write("\n")
A prettier solution

Why print when you can have yourself a nice little banner with PIL (banner.p contents is in "s"):

import pickle, pprint
import Image, ImageDraw
im = Image.new("1", (95, 24))
draw = ImageDraw.Draw(im)
data = pickle.loads(s)
line = 0
for i in data:
    xpos = 0
    for j in i:
        if j[0] == " ":
            draw.line([(xpos,line), (xpos+j[1],line)], 255)
        xpos += j[1]
    line += 1    
im.save("banner.bmp")
But you could do that with a list comprehension:

   data = ["".join(i * ('\xff' if s == ' ' else '\x00') for s, i in ln)
           for ln in data]
   size = width, length = len(data[0]), len(data)
   mode = 'L'  # 8-bit pixels
   Image.fromstring(mode, size, "".join(data)).save('banner.bmp')
Or use tesseract to OCR the banner to a string

   from os import path
   import tempfile
   import shutil
   import subprocess
   # make the serifs white, tesseract OCRs it better sans-serif
   baseline = 21
   serifs = [14, 19, 28, 42, 44, 49, 58, 59, 64, 73, 89, 94]
   data[baseline] = "".join(
           ('\xff' if i in serifs else s)
               for i, s in enumerate(data[baseline]))
   tmp = tempfile.mkdtemp()
   Image.fromstring(mode, size, "".join(data)).save(
           path.join(tmp, 'data.tif'))
   subprocess.call(['tesseract', 'data.tif', 'data'],
           cwd=tmp, stderr=subprocess.PIPE)
   answer = open(path.join(tmp, 'data.txt')).readline().rstrip()
   shutil.rmtree(tmp)
Mine

import pickle
obj = pickle.loads( $PASTE_HERE )
result = ""
for outer in obj:
  for inner in outer:
    for i in range(0, inner[1]):
      result += inner[0]
  result += "\n"
print result
Output to file

For windows whose cmd terminal window won't go wide enough

import pickle, urllib

bannerfile = urllib.urlopen('http://www.pythonchallenge.com/pc/def/banner.p')
obj = pickle.load(bannerfile)
out = open('5.txt', 'w')

for lists in obj:
    for tuple in lists:
        out.write(str(tuple[0]) * tuple[1])
    out.write('\n')

print "Printed banner to '" + out.name +"'."
out.close()
Another

import pickle
pick = open('/home/george/Desktop/banner.p')
the_mess = pickle.load(pick)
for each_list in the_mess:
   line = ' '
   for each_tuple in each_list:
       part = str(each_tuple[0]*each_tuple[1])
       line = line + part
   print line
Simple

import pickle

pklfile = file(r'banner.p', 'r')
u = pickle.Unpickler(pklfile)

x = u.load()

for i in range(len(x)):
	banner = ""
	for j in range(len(x[i])):
		banner += x[i][j][0] * x[i][j][1]
	print banner
Very Simple

f = file(r'<your path goes here>\banner.p')
o = cPickle.load(f)

f = open('banner.txt','w')
for i in o:
    for index, value in i:
        s = str((index * value),)
        f.write(s)
    f.write('\r\n')
A very simple solution on Windows XP. This takes care of the problem of some extraneous spaces if you use the same code to print to a console. "\r\n" is the Windows CR/LF (carriage return/linefeed).

Very Simple to print

bannerp = open("banner.p", "r")
banner = pickle.load(bannerp)

for lst in banner:
    line = ""
    for char, digit in lst:
        line += char * digit
    print line
Real One Liner

print '\n'.join("".join(i[0] * i[1] for i in l) for l in
                __import__('pickle').loads(__import__('urllib').urlopen(
                'http://www.pythonchallenge.com/pc/def/banner.p'
                ).read()))
Without Pickle

curl -s http://www.pythonchallenge.com/pc/def/banner.p | awk "
 /aa/         { printf(\"\n\"); }
 /^I[0-9]*/   { n = substr(\$1, 2); while(n--) printf(\"%c\", ch); }
 /S'#'|g6/    { ch = \"#\"; }
 /S' '|g2/    { ch = \" \"; }"
Using reduce

bannerurl = "http://www.pythonchallenge.com/pc/def/banner.p"
url = urllib.urlopen(bannerurl)
banner = url.read()
obj = pickle.loads(banner)
print "\n".join([ reduce(lambda x,y : x + y[0]*y[1], line, "") for line in obj ])
Vertical (my console isn't 96 chars wide!)

 import pickle, urllib
 source = pickle.load(urllib.urlopen('http://www.pythonchallenge.com/pc/def/banner.p'))
 print "\n".join(["".join([["".join([b[0]*b[1] for b in a]) for a in source ][x][y] for x in range(22, 0, -1)]) for y in range(95)])
In Ruby(Depickling done in Python)

def printout(banarr)
        banarr.each do |numcharr|
                char=numcharr[0]
                num=numcharr[1]
                num.times do
                        print char
                end
        end
        puts ""
end
def bigprint(arr)
        arr.each do |banarr|
                printout(banarr)
        end
end
arr=(insert depickled data here, with ( replaced with [ and ) replaced with ]  )
bigprint(arr)
Another Ruby solution

Requires depickled data as input.

puts eval(gets.tr('()','[]')).collect{|l|l.collect{|p|p[0]*p[1]}.join}

Yet Another Ruby solution

banner = `python -c "import pickle; print pickle.load(open('banner.p'))"`
banner = eval(banner.tr("()", "[]"))
banner.each do |line|
  line.each { |char, freq| print char * freq }
  puts
end
--Rebecca 00:30, 10 Aug 2010 (PDT)


Nested loops

This is definitely not the most elegant solution here, but here it is.

import pickle
import sys
f = open("banner.p",'r')
p = pickle.load(f)
for i in range(len(p)):
     for j in range(len(p[i])):
          for k in range(p[i][j][1]):
               if k is p[i][j][1]:
                    print ""

               sys.stdout.write(p[i][j][0])
print ""
Nested loops redux

Another nested loop solution which does not use the sys module.

import urllib
import pickle
f=open('banner.p')
p=pickle.load(f)
newStr = ' '
for c1 in range(0, len(p)):
   for c2 in range(0,len(p[c1])):
       char, num = p[c1][c2]
       for tmp in range(0,num):
           newStr = newStr + char
   newStr = newStr + ' \n'        
print newStr
As a Bash Script

Ugly as sin, but it gets the job done.

bannerlist=$(curl -s http://www.pythonchallenge.com/pc/def/banner.p|python -c "import cPickle,sys; print cPickle.loads(sys.stdin.read())"|tr -d '[(');
lines=$(echo $bannerlist|awk '/.*/{n=split($0,a,"]");for(i=0;i<n;i++){m=split(a[i],b,")");for(j=0;j<m;j++){print(b[j]);}}}'|tr -d ", '");
for line in $lines; do
	i=0;
	if [ -z $line ]; then
 		echo ;
	fi
	if [ "#" == $(echo $line|cut -c 1) ]; then
		n=$(echo $line|tr -d "#");
		while [ $i -lt $n ]; do
			echo -n "#";
			((i++));
               done;
	else
		while [ $i -lt $line ]; do
			echo -n " ";
			((i++));
		done;
       fi
 done;
Haskell

This solution uses MissingPy. I'm sure it can be improved, but I need to improve my Haskell knowledge before. ;)

import Python.Interpreter
import Python.Objects

fromPyTuple (x:y:[]) = do
  c <- fromPyObject $ x :: IO String
  i <- fromPyObject $ y :: IO Integer
  return (c, i)

printBanner (x:xs) = do
  mapM (\s -> putStr $ concat $ replicate (fromInteger $ snd s) (fst s)) x
  putStrLn ""
  printBanner xs

printBanner [] = do return ()

main = do
  py_initialize
  pyImport "pickle"
  pybanner <- pyRun_String "pickle.load(open('banner.p'))" Py_eval_input []
  unpy1 <- fromPyObject pybanner :: IO [PyObject]
  unpy2 <- mapM fromPyObject unpy1 :: IO [[PyObject]]
  unpy3 <- mapM (mapM fromPyObject) unpy2 :: IO [[[PyObject]]]
  banner <- mapM (mapM fromPyTuple) unpy3
  printBanner banner
Using "future Python"

I am sure this solution can be useful, because not everybody knows how to get rid of this spaces and carriage returns that Python uses while printing in a standard way. Works with Python 2.6, there is no "future Python" in python 3.0. Assumes that the file is in the same directory and with the same name. It can be improved with the use of urllib.

from __future__ import print_function
import pickle
file = open("banner.p", "r")
object = pickle.load(file)
for list in object:
    for tuple in list:
        char = tuple[0]
        rep = tuple[1]
        for i in xrange(rep):
            print(char, sep = "", end = "")
    print("", sep = "", end = "\n")
file.close()
Using Python3.1 Specifically

import pickle
import urllib.request
pickled = pickle.load(urllib.request.urlopen('http://www.pythonchallenge.com/pc/def/banner.p'))
for row in pickled:
	if len(row) > 1:
		for tuple in row:
			print(tuple[0] * tuple[1], end = "")
	else:
		print(row[0][0] * row[0][1], end = "")
	print('\n')

Wuelfhis Way

import pickle,sys
pkl_file = open('banner.p', 'rb')
data1 = pickle.load(pkl_file)

cont=0
txt='\n'
for a in data1:	
	for b in a:		
		sys.stdout.write(b[0]*b[1])
	print "\r"
	
				
print txt
pkl_file.close()

#respuesta channel



ECMAScript 5 solution (using python2.x for unpickling)

Two files this time. First, python:

import cPickle as pickle

with open('banner.p', 'r') as inFile:
    data = pickle.load(inFile)
    with open('banner.txt', 'w') as outFile:
        outFile.write(str(data))
now to generate the answer using ECMAScript:

var fs = require('fs');
var data = fs.readFileSync('banner.txt').toString();
while (data.indexOf('(') !== -1) {
    data = data.replace('(', '[');
}
while (data.indexOf(')') !== -1) {
    data = data.replace(')', ']');
}
instructions = eval(data);
for (var i1 = 0; i1 < instructions.length; i1 += 1) {
    var line = '';
    for (var i2 = 0; i2 < instructions[i1].length; i2 += 1) {
        for (var i3 = 0; i3 < instructions[i1][i2][1]; i3 += 1) {
            line = line + instructions[i1][i2][0];
        }
    }
    console.log(line);
}
// Andy Short 2012
#าิษฯฮชตฺฮๅนุ
___________________________________________________-
ตฺม๙นุ:
import zipfile, re
findnothing = re.compile(r"Next nothing is (\d+)").match
comments = []
z = zipfile.ZipFile("channel.zip", "r")
seed = "90052"
while True:
    fname = seed + ".txt"
    comments.append(z.getinfo(fname).comment)
    guts = z.read(fname)
    m = findnothing(guts)
    if m:
        seed = m.group(1)
    else:
        break
print "".join(comments)
Printing the result forms the letters 'HOCKEY', but using that as a URL will tell you "it's in the air" and to look at the letters. Indeed, the letters of the word hockey have been built up out of the letters O, X, Y, G, E, and N, and 'oxygen' leads to the next level.

Contents [hide]
1 Simple Python solution (no error handling)
2 Solution without downloading ziped file manually
3 Solving without python modules
4 Finding The Zip
5 BASH Solution
6 Perl solution
7 Another Python Solution
8 A ruby solution
9 Another Python variant
10 With an iterator class
11 Wuelfhis Style
12 ECMAScript 5 and python2.x solution
Simple Python solution (no error handling)

f = "<your path goes here>\channel.zip"
z = zipfile.ZipFile(f)

name = '90052.txt'
while 1:
    print z.getinfo(name).comment,
    name = z.read(name).split()[-1] + '.txt'
Solution without downloading ziped file manually

import urllib
import zipfile
from StringIO import StringIO

zobj = StringIO()
zobj.write(urllib.urlopen("http://pythonchallenge.com/pc/def/channel.zip").read())
z = zipfile.ZipFile(zobj)

filenum = "90052"
lcomment = []

while True:
    if filenum.isdigit():
        filename = filenum + '.txt'
        lcomment.append(z.getinfo(filename).comment)
        info = z.read(filename)
        filenum = info.split(' ')[-1]
    else:
        break
z.close()
print ''.join(lcomment)
Solving without python modules

The puzzle may be solved from the unix shell by running this oneliner:

perl -we '$_ = `unzip -l channel.zip`; s/(\d+)\.txt\n(.)/$h{$1}=$2/sge; $n = 94191; print $h{$n=$1} while `cat $n.txt` =~ /(\d+)$/'
Which prints:

****************************************************************
****************************************************************
**                                                            **
**   OO    OO    XX      YYYY    GG    GG  EEEEEE NN      NN  **
**   OO    OO  XXXXXX   YYYYYY   GG   GG   EEEEEE  NN    NN   **
**   OO    OO XXX  XXX YYY   YY  GG GG     EE       NN  NN    **
**   OOOOOOOO XX    XX YY        GGG       EEEEE     NNNN     **
**   OOOOOOOO XX    XX YY        GGG       EEEEE      NN      **
**   OO    OO XXX  XXX YYY   YY  GG GG     EE         NN      **
**   OO    OO  XXXXXX   YYYYYY   GG   GG   EEEEEE     NN      **
**   OO    OO    XX      YYYY    GG    GG  EEEEEE     NN      **
**                                                            **
****************************************************************
 **************************************************************
PerlLover

Finding The Zip

As an added hint, if you try to interpret the "hint" in the source as pointing to zip.html, it will display a page saying "yes. find the zip.", which would point you to the PROPER way of finding the file - ie, as the file extension, not the name.

Alternativly, if you try the page pants.html, it will display a page with the text "amazing. zoom in".

BASH Solution

Somewhat ugly. But *shrug*. I've actually cleaned it up a smidge.

curl -s http://www.pythonchallenge.com/pc/def/channel.zip>tmp.zip
number=$(unzip -ap tmp readme.txt|egrep -o [0-9]+$)
while [ -n "$number" ]; do
        echo -n "$(unzip -l tmp|egrep -A 1 $number.txt|sed -nE '2 s/(.).*/\1/p')";
        number=$(unzip -ap tmp $number.txt|egrep -o [0-9]+$);
done;
rm tmp.zip;
Perl solution

use Archive::Zip;

my $zip = Archive::Zip->new();
$zip->read('channel.zip');

my $num = 90052;
my $i = 0;

while ($i++ < $zip->numberOfMembers()) {
    my $zf = $zip->memberNamed($num . '.txt');

    $num = $1 if ($zf->contents =~ /\s(\d+)$/);
    print $zf->fileComment;
}
Another Python Solution

#!/usr/bin/env python
import zipfile
import urllib
from StringIO import StringIO

zip_file = StringIO()
zip_file.write(urllib.urlopen("http://www.pythonchallenge.com/pc/def/channel.zip").read())
zip_archive = zipfile.ZipFile(zip_file)
zipdict = {}

for info in zip_archive.infolist():
    zipdict[info.filename] = info.comment

current_nothing = '90052'
while True:
    print zipdict[current_nothing + '.txt'],
    page = zip_archive.read(current_nothing + '.txt')
    try:
        current_nothing = page.split('Next nothing is ')[1]
    except IndexError:
        break
A ruby solution

 require 'zip/zip'
 Zip::ZipFile.open('./channel.zip') do |zip|
   comments = ""
   nothing = 90052
   while nothing
     comments << zip.get_entry("#{nothing}.txt").comment
     nothing = zip.read("#{nothing}.txt") =~ /nothing is (\d+)/ ? $1 : nil
   end
   puts comments
 end
Another Python variant

from zipfile import ZipFile

fz=ZipFile('channel.zip','r')

def get_nextindex_and_comment(fname):
    nextindex=fz.open(fname,'r').read().split()[-1]
    comment=fz.getinfo(fname).comment
    return nextindex, comment

# start at '90052.txt', traverse linked files, spit out comments
index='90052'
while index.isdigit():
    index,comment=get_nextindex_and_comment(index+'.txt')
    print comment,

fz.close()

#soln - http://www.pythonchallenge.com/pc/def/oxygen.html

Symmetry 11:27, 9 Jan 2010 (PST)


With an iterator class

A somewhat unnecessarily complicated way of doing it. The zip file is saved to the directory of the script

from zipfile import ZipFile
from contextlib import closing
import re

class ChannelIterator:
    next_re = re.compile(r'(\d+)')

    def __init__(self, zf):
        self.zip = zf
        self.file = '90052'
        
    def __iter__(self):
        return self

    def next(self):
        if not self.file:
            raise StopIteration
        info = self.zip.getinfo('{0}.txt'.format(self.file))
        data = self.zip.read(info)
        self.file = (self.next_re.findall(data) + [None])[0]
        return info.comment


with closing(ZipFile("channel.zip", "r")) as channel:
    print(''.join(ChannelIterator(channel)))
--Achates 12:45, 31 May 2010 (PDT)


Wuelfhis Style

import os,glob,zipfile

start="90052"
divi="Yes. Divide by two and keep going."
nothing="Next nothing is "
path = 'chl/'
#
infile = glob.glob( os.path.join(path, '*.txt') )
while True:
	if path+start+".txt" in infile:
		fil=open(path+start+".txt",'r')
		data=fil.read()
#		print data
		if nothing in data:
			start=data[data.find(nothing)+16:len(data)]
		else:
			if divi in data:
				start=str(int(start)/2)
		fil=zipfile.ZipFile("channel.zip","r")		
		for file in  fil.filelist:
			if start+".txt" in file.filename:			
				print file.comment,
# this will print the word hockey in banner form
# but each word in hockey is made of a letter
# finally it is oxygen

--Wasuaje 12:10, 10 Sep 2010 (PDT)

ECMAScript 5 and python2.x solution

There is poor native support for dealing with zip archives in node at the time of this writing. I switched to python to find the comments. Assumes that channel.zip and all of its unzipped contents are in the working folder. First, finding the order of the files in ECMAScript:

var fs = require('fs');

var findNumber = function(string) {
    for (var i = 0; i < string.length; i += 1) {
        if (!isNaN(parseInt(string.slice(i), 10))) {
            return parseInt(string.slice(i), 10);
        }
    }
};
var linked_list = "(";
var followLinks = function(file_name) {
    try {
        var data = fs.readFileSync(file_name).toString();
        console.log(data);
        var next_nothing = findNumber(data.slice(data.indexOf('nothing is')));
        var next_file_name = next_nothing.toString() + '.txt';
        linked_list = linked_list + "'" + next_file_name + "',"
        followLinks(next_file_name);
    }
    catch (e) {
    }
}
followLinks('90052.txt');
linked_list = linked_list + ')'
fs.writeFileSync('linked_list.txt', linked_list);
// Andy Short 2012
Now the zipped files are inspected in python using the list generated by the above code:

import zipfile

archive = zipfile.ZipFile('channel.zip')
solution = ''

with open('linked_list.txt', 'r') as inFile:
    linked_list = eval(inFile.read())
    for file_name in linked_list:
        solution = solution + archive.getinfo(file_name).comment
    print solution

    __________________________________________________
    ตฺฦ฿นุ
Level7:Main Page
Challenge info
Title	smarty
URL	http://www.pythonchallenge.com/pc/def/oxygen.html
Prev	 <restrlink>
Next	 <restrlink>
The squares in the middle look suspicious so you think that the answer is encoded within it.

Unfortunately, Python does not have a built-in Image library so you'll have to search for an external module. I've chosen to use PIL, which I had pre-installed.

>>> import Image, urllib, StringIO
>>> img = urllib.urlopen('http://www.pythonchallenge.com/pc/def/oxygen.png').read()
>>> i = Image.open(StringIO.StringIO(img))  # Image.open requires a file-like object
>>> i.size
(629, 95)
>>> [i.getpixel((x,45)) for x in range(629)]
[(115, 115, 115, 255), (115, 115, 115, 255), (115, 115, 115, 255), ...
There seem to be a lot of data here, but it is noticable that the grey squares have R=G=B, and it has a period of 7 pixels.

# Extract every 7th pixel from row 45.
>>> row = [i.getpixel((x, 45)) for x in range(0, i.size[0], 7)]
# Take the R value from all with equal R, G, and B values.
>>> ords = [r for r, g, b, a in row if r == g == b]
# And convert to characters.
>>> print "".join(map(chr, ords))
smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]
Applying the hint:

>>> "".join(map(chr,[105, 110, 116, 101, 103, 114, 105, 116, 121]))
'integrity'
Contents [hide]
1 Short Python solution
2 Solution with Python GD
3 slice + list comprehensions
4 Complete solutions in Python
5 Solving without python modules
6 A solution in Ruby, using RMagick/ImageMagick
7 Another solution in Ruby, oneliner with auxiliary variable:
8 Oneliner in Ruby 1.9
9 Solution in C and GD (If you dont want to install GD for python):
10 Solution without using python at all:
11 PHP Solution
12 Another Python variant
13 In F#
14 Bash shell
15 Solution using PyPNG
Short Python solution

Nice and simple.

import PIL.Image
print PIL.Image.open('oxygen.png').tostring()[108188:110620:28]
Nneonneo 17:16, 27 Feb 2007 (MST)

Solution with Python GD

My solution is quite similar to the above, but I used the Python GD module instead.

import gd

values = list()

img = gd.image('/home/fzero/src/python/oxygen.png')

middle = img.size()[1] / 2
width = img.size()[0]

for x in range(0, width, 7):
    color = img.getPixel( (x,middle) )
    values.append( img.colorComponents(color) )

s = ""

for value in values:
    s += chr( value[0] )

print s
This prints the "smart guy" message. The next step is simply to take the new list and translate it:

smartness = [105, 110, 116, 101, 103, 114, 105, 116, 121]
for smart in smartness:
    print chr(smart),
i n t e g r i t y
Fabio FZero

slice + list comprehensions

from PIL import Image
import re

im = Image.open("oxygen.png")
width, height = im.size

# third parameter of slice gets in a swoop every 7th pixel of middle line
s = (height//2)*width                   
L = list(im.getdata())[s : s+width : 7]  

# filter out non-gray pixels and convert RGB values to characters
ans = ''.join([chr(p[0]) for p in L if p[0]==p[1]==p[2]])  

# convert to characters the numbers within the list of previous message
print ans , "\n" , ''.join([chr(int(n)) for n in re.findall('(\d+)', ans)])  
Complete solutions in Python

import Image, re

im = Image.open('oxygen.png')
width = im.size[0]
height = im.size[1]
pixels = im.load()
bar_y = height / 2 # bar is half way down the image

# look at every 7th pixel 
answer = ''
for i in range (0, width, 7):
    p = pixels[i, bar_y] # get a pixel object[x, y] - (r, g, b, a) 
    if(p[0] == p[1] == p[2]): # only look at greyscale pixels (r = g = b)
         answer = answer + chr(p[0])

print '\n', answer, '\n'

list = re.findall('(\d+)', answer) # find all numbers and put into a list
print ''.join(map(chr, map(int, list))) # int() each, then chr() each
AlexT

import Image

im = Image.open("oxygen.png")

# cut out the grey bar
box = (0, 43, 615, 52)
region = im.crop(box)

# convert to 8-bit pixels (black and white) 
# and then to a string containing the pixel data (using the standard ?raw? encoder)
region = region.convert("L")
hint = region.tostring()

# extract and apply the 'smart guy, you made it.'  message
hint = ''.join([hint[i] for i in range(0, len(hint), 7)])[:87]
print ''.join([chr(i) for i in eval(hint[-45:])])
BioGeek

import Image, re
 
im = Image.open('oxygen.png')
(width, height) = im.size

def isGrey(color):
	return color[0] == color[1] and color[1] == color[2]

response = ''.join(map(lambda c: chr(c[0]),
	filter(isGrey,
		map(lambda x: im.getpixel((x, height/2)),
			range(0, width, width/80)))))

print response
print ''.join(map(lambda x: chr(int(x)), re.compile('\d+').findall(response)))
Egourdin

import urllib
import Image
import StringIO

print ''.join([chr(c) for c in eval('[' + ''.join([chr(a[0]) for a in list(Image.open(StringIO.StringIO(urllib.urlopen('http://www.pythonchallenge.com/pc/def/oxygen.png').read())).crop((0,45,608,46)).getdata())[::7]]).split('[')[1])])
Thisismyrobot

import re, Image

im = Image.open("oxygen.png")
pattern = "[0-9]{3}"
temp, result = "",""

for i in range(0, (im.size[0] / 7)):
	temp += chr(im.getpixel((i * 7, 43))[0])

matches = re.findall(pattern, temp)

for match in matches:
	result += chr(int(match))
	
print result
Beastcraft

Solving without python modules

I solved this puzzle by running the following from the unix shell (try it):

convert -crop 608x1+0+43 oxygen.png oxygen.gray
perl -pe 's/(.).{0,6}/$1/g' oxygen.gray
PerlLover


A solution in Ruby, using RMagick/ImageMagick

require 'RMagick'
include Magick
img = ImageList.new("oxygen.png")
pixels = img.get_pixels(0, 43, 605, 1)
letters = pixels.map {|pix| pix.red.chr}
clue = ""
letters.inject(0) do |count, char|
  clue += char if count == 0
  (count + 1) % 7
end
/\[(.+)\]/.match(clue)
$1.split(", ").map {|num| Integer(num).chr}.join
KeithLazuka


Another solution in Ruby, oneliner with auxiliary variable:

 require "RMagick"
 i=-1
 puts   Magick::ImageList.new("oxygen.png").get_pixels(0,43,605,1).collect{|p|p.red.chr}.select{|c|i+=1;i%7==0}.join.scan(/\d+/).collect{|s|s.to_i.chr}.join
--Rubyist 01:19, 3 Feb 2008 (PST)

Oneliner in Ruby 1.9

 require "RMagick"
 Magick::ImageList.new("oxygen.png").get_pixels(0,45,629,1).map.with_index{|p,i| (p.red/255).chr if i%7==0)}.join.scan(/\d+/){|c| print c.to_i.chr }
I had a problem with pixel values returning numbers above 255 (maybe a different/buggy RMagick version?), which is why the division by 255 is there for. Also this solution expanded looks like this:

 require "RMagick"
 image = Magick::ImageList.new("oxygen.png")
 pixels = image.get_pixels(0,image.rows/2,image.columns,1)
 clue = pixels.map.with_index {|p,i| (p.red/255).chr if (i%7==0)}.join
 puts clue.scan(/\d+/).map{|c| c.to_i.chr}.join
--Teonimesic 19:01, 13 Jul 2010 (PDT)

Solution in C and GD (If you dont want to install GD for python):

#include <gd.h>
#include <stdio.h>
FILE *f;
gdImagePtr im;
int c,x;
int main()
{
   f=fopen("oxygen.png","rb");
   im=gdImageCreateFromPng(f);
   for(x=0;x<606;x+=7)  {
       c=gdImageGetPixel(im,x,50);
       printf("%c",gdImageRed(im,c));
   }
   printf("\n");
}
opium


I solved it with... gimp and the [Alt] key !! It takes me about half an hour !

Convert image to grayscale
Select 1st squar's color
go to a text file
press [Alt]+color_value
manux


I suspected the grey blocks were the key, so... I hexdumped file - noticed comment about it being created by GIMP. Dwonloaded GIMP and ran: Hover cursor over grey blocks and you get R/G/B values in decimal and hex (yes they map to ascii). I used a pencil to write out ascii:)

jxb


Solution without using python at all:

Save the file, open in irfanview, cut a 695x1 section of the gray pixels, paste in another file
save that file as RAW, with planar encoding. Open in a text editor, read.
Convert the array to ascii using pencil.
ASk

PHP Solution

$im = imagecreatefrompng('http://www.pythonchallenge.com/pc/def/oxygen.png');
for ($x = 0; $x <= 602; $x += 7) printf('%c', imagecolorat($im, $x, 47) & 0xFF);
Prints "smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]". Madgeek 22:13, 22 Oct 2009 (PDT)


Another Python variant

import Image
im_source = Image.open("oxygen.png")

#take 1 relevant line from the image and create a list of RGBA tuples
box=(0,44,604,45)
im=im_source.crop(box)
rgba_list=list(im.getdata())

#weed out repeats
t=[]
index=0
while index < len(rgba_list):
    t.append(rgba_list[index])
    index+=7

#extract message using either R or G or B
a="".join(chr(r) for r,g,b,a in t)
print a

# smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]

c=[105, 110, 116, 101, 103, 114, 105, 116, 121]
d="".join(chr(i) for i in c)

print d
# integrity

Symmetry 13:09, 9 Jan 2010 (PST)

In F#

open System
open System.Drawing
open System.IO
open System.Net
open System.Text.RegularExpressions

let getImg (url:string) = 
  new Bitmap(new MemoryStream((new WebClient()).DownloadData(url)))
  
let rec findStartingPoint (img:Bitmap) x y =
  match img.GetPixel(x,y).GetSaturation() <= 0.01f with
  | true -> (x,y)
  | _ -> findStartingPoint img x (y + 10)

let iterateChars (img:Bitmap) =
  let (x,y) = findStartingPoint img 0 0
  let rec next x y =
    seq {
      if not (x < 0 || x > img.Width || y < 0 || y > img.Height) then
        let candidate = img.GetPixel(x,y)
        yield Convert.ToChar(candidate.R)
        yield! next (x+7) y
    }
  seq {
    yield! next x y
  }

let answer = 
  (new String(
              getImg "http://www.pythonchallenge.com/pc/def/oxygen.png"
              |> iterateChars
              |> Seq.toArray)
    |> (new Regex("(?<=\[).+(?=\])")).Match).Value.Split([|','|])
  |> Array.map (fun str -> Convert.ToChar(Int32.Parse(str)))
  |> (fun chars -> new String(chars))
--Efvincent 15:24, 23 Mar 2010 (PDT)

Bash shell

First step, using Netpbm:

curl -s http://www.pythonchallenge.com/pc/def/oxygen.png | pngtopnm | pamcut 0 43 607 1 | sed -r '1,3d;s/(.).{20}/\1/g;s/]]*/]\n/'
Second step (see http://mywiki.wooledge.org/BashFAQ/071):

for a in 105 110 116 101 103 114 105 116 121; do printf \\$(printf '%03o' $a); done; echo
Solution using PyPNG

This library is available at http://code.google.com/p/pypng/.

import png

# Read image using PyPng
img = png.Reader('oxygen.png').read()
# 2nd element of img is the pixel array
pixels = list(img[2])

# Get the row with the grayscale pixels
row = pixels[43]
# Box every 7th pixel into RGBA array
rowboxed = [row[i:i+4] for i in range(0, len(row)-3, 4*7)]
# Convert grayscale pixels from that to a string
outstr = ''.join(map(chr, [r for (r,g,b,a) in rowboxed if r==g==b]))

print outstr
print ''.join(map(chr, eval(outstr[outstr.find('['):])))
______________________________________________________
Level8:Main Page
Challenge info
Title	working hard?
URL	http://www.pythonchallenge.com/pc/def/integrity.html
Prev	 <restrlink>
Next	 <restrlink>
You see a bee in the picture. She sounds busy too. What could that mean?

bee? busy. busy? busy too ? bz2?

The hint in the password box says "inflate" so you consider to try to decompress the strings.

>>> import bz2
>>> bz2.decompress('BZh91AY&SYA\xaf\x82\r\x00\x00\x01\x01\x80' + 
... '\x02\xc0\x02\x00 \x00!\x9ah3M\x07<]\xc9\x14\xe1BA\x06\xbe\x084')
'huge'
>>> bz2.decompress('BZh91AY&SY\x94$|\x0e\x00\x00\x00\x81\x00' + 
... '\x03$ \x00!\x9ah3M\x13<]\xc9\x14\xe1BBP\x91\xf08')
'file'
So you've gathered the username and password for the next level.

For those of you who were frustrated by the lack of documentation for the bzip2 header format(i.e. "what is that BZh9 present in the first four byes of the un and pw?"), a google search produces: http://www.amiga-stuff.com/crunchers-id.html (search for BZh9). JesseW 16:31, 31 May 2005 (MDT)

Contents [hide]
1 Using file
2 BASH Shell Script
3 Using str.decode
4 Decode from file
5 Make the bz2 files then use winrar to look inside
6 Ruby solution using ruby-bz2
7 Wuelfhis way
8 Similar to above
9 Put off by the bee
Using file

A useful tool to unix people is the `file` command:

>>> open('passwd.dontknowwhatis','w').write('BZh91AY&SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13<]\xc9\x14\xe1BBP\x91\xf08')
$ file passwd.dontknowwhatis
passwd.dontknowwhatis: bzip2 compressed data, block size = 900k
$ bzcat passwd.dontknowwhatis
file
--webograph 12:05, 25 Jan 2007 (MST)

BASH Shell Script

The code that gets the strings from the webpage is a little unnecessarily messy and I'm working on that. Anyway. Because I have nothing better do: the horrible monstrosity that is my to solution to this as a BASH shell script

#!/bin/bash
un="$(curl -s http://www.pythonchallenge.com/pc/def/integrity.html|sed -nE "/^un.*$/ s/^.*'(.*)'.*$/\1/p")";
pw="$(curl -s http://www.pythonchallenge.com/pc/def/integrity.html|sed -nE "/^pw.*$/ s/^.*'(.*)'.*$/\1/p")";
t=`mktemp`;
for i in "$un" "$pw"; do
        printf "$i">$t;
        bzcat $t;
        echo;
done;
Achates

How about:

for s in un: pw:; do
  printf $s
  printf "`curl -s http://www.pythonchallenge.com/pc/def/integrity.html | grep $s | cut -d\' -f2`" | bzcat
  echo
done
Benlynn 17:39, 24 May 2010 (PDT)

Using str.decode

>>> 'BZh91AY&SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07<]\xc9\x14\xe1BA\x06\xbe\x084'.decode('bz2')
'huge'
>>> 'BZh91AY&SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13<]\xc9\x14\xe1BBP\x91\xf08'.decode('bz2')
'file'
Decode from file

Another user got stuck trying to get the string directly from the html source:

import urllib
page = urllib.urlopen("http://www.pythonchallenge.com/pc/def/integrity.html")
for line in page:
  if line[:3] == 'un:': un = line[5:-2]
  if line[:3] == 'pw:': pw = line[5:-2]
print un.decode("string_escape").decode("bz2")
print pw.decode("string_escape").decode("bz2")
The trick is to decode first using "string_escape" (the BASH script above uses sed to do the same thing). The easiest way, of course, is to copy the quoted string right into the interpreter.


Make the bz2 files then use winrar to look inside

hdr1='BZh91AY&SYA'
data1='\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07<]\xc9\x14\xe1BA\x06\xbe\x084'

hdr2='BZh91AY&SY'
data2='\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13<]\xc9\x14\xe1BBP\x91\xf08'

def makeBz2(fname,hdr,data):
    f=open(fname,'w')
    f.write(hdr)
    for i in data: f.write(i)
    f.close()

makeBz2('user.bz2',hdr1,data1)
makeBz2('pass.bz2',hdr2,data2)
Symmetry 13:13, 10 Jan 2010 (PST)


Ruby solution using ruby-bz2

require 'bz2'
un = "BZh91AY&SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07<]\xc9\x14\xe1BA\x06\xbe\x084"
pw = "BZh91AY&SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13<]\xc9\x14\xe1BBP\x91\xf08"
puts BZ2.decompress(un)
puts BZ2.decompress(pw)
--Rebecca 05:38, 10 Aug 2010 (PDT)


Wuelfhis way

The easiest so far

import bz2

un= "BZh91AY&SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07<]\xc9\x14\xe1BA\x06\xbe\x084"
pw= """BZh91AY&SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13<]\xc9\x14\xe1BBP\x91\xf08"""
print bz2.decompress(un)
print bz2.decompress(pw)

#respuestas huge file


Similar to above

My script was very similar to the above to solve, but in 3 lines;

import bz2

print "Username is: " + bz2.decompress("BZh91AY&SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07<]\xc9\x14\xe1BA\x06\xbe\x084")
print "Password is: " + bz2.decompress("BZh91AY&SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13<]\xc9\x14\xe1BBP\x91\xf08")


Put off by the bee

#!/bin/python

import sys,  urllib2,  bz2
from PIL import Image

page = urllib2.urlopen("http://www.pythonchallenge.com/pc/def/integrity.html").read()
un = page.splitlines()[20][5:-1]
pw = page.splitlines()[21][5:-1]

i = Image.open("integrity.jpg")
p = i.load()

# what's the size of the image?
print i.size

# grab coordinates from source
coords = eval(page.splitlines()[11][10:-2])
# couldn't remember html map notation, but as there are an even number of ... numbers, lets guess at x,y,x,y,x,y,x,y...

# lets color all pixes coordinate positions red
for x in range(len(coords)/2):
    p[coords[x*2],coords[x*2+1]] = (255, 0, 0)
i.show()

# hmm, that was just an outline of the bee...

print bz2.decompress(un.decode('string_escape'))
print bz2.decompress(pw.decode('string_escape'))

________________________________________________________
ตฺพลนุ
The source file contains a list of numbers, and the title of the level suggests to interpret it as a list of dots.

Assuming you've loaded the lists into the variables "first" and "second" (I just used copy and paste from the page-source for that,and adding [ and ] of course), you only have to:

import Image, ImageDraw
img = Image.new('RGB', (640,480))
draw = ImageDraw.Draw(img)
draw.line(first)
draw.line(second)
img.show()
Fortunately, draw.line() likes lists of coordinates and doesn't even require us to make it a list of 2-tuples.

Either the picture is of a bull or of a cow. Changing the link to 'cow' returns that it's a male. Typing 'bull', instead, takes you to level 10. There, you see the picture of a cow (why ?).

Contents [hide]
1 Notes on Parsing Up the Numbers
2 Solving with gd
3 Solving with cairo
4 Solving without python modules
5 Solving with pygame
6 Solving with matplotlib
7 Solving with Imaging library
8 Solving with turtle
9 Solving with Tkinter in a different way
10 Another Solution with ImageMagick
11 Solving with NodeBox
12 Solving in text-mode/ascii-art
13 Solving in HTML5 Canvas
14 Ruby solution using RMagick
15 Solution using SVG
16 One way to get the data
Notes on Parsing Up the Numbers

If you start with a quick cut and paste, making code like this:

first = """146,399,163,403,
  ... """
Then you can quickly make a list of numbers:

 first_list = [ int(x.strip()) for x in first.split(",")]
Or two lists:

  first_x = first_list[::2]  # even indices, start at zero, to end, step by 2.
  first_y = first_list[1::2]  # odd indices
--Charles Merriam 03:45, 20 Jul 2007 (PDT)

Or... you can bracket and EVAL the string :-)

first_list = eval ("[%s]" % first)
Or just add the brackets yourself instead of making a string

first = [145,399,163,
 ...]
Solving with gd

If you are using libgd, then you need to convert the list into pairs. The solution may be drawn on the original picture, like this:

import gd
image = gd.image('good.jpg')
first = [146, 399, ...]
second = [156, 141, ...]
third = first + second
fourth = []
steps = len(l)/2
for i in range(steps):
    fourth.append((third[2*i], third[2*i+1]))
image.lines(fourth, 0)
image.writePng('good.png')
Solving with cairo

import cairo
def draw(ctx, array):
    ctx.move_to (array[0], array[1])
    for x,y in zip(array[2::2], array[3::2]):
        ctx.line_to (x, y)
    ctx.stroke()
surface = cairo.ImageSurface (cairo.FORMAT_ARGB32, 600, 600)
ctx = cairo.Context(surface)
draw(ctx, first)
draw(ctx, second)
surface.write_to_png('temp.png')

Solving without python modules

I solved this puzzle using "convert" (from ImageMagick):

convert -size 400x400 -fill black -stroke white -draw "polygon `cat second`" xc:black image.png
The file "second" contains comma or newline separated numbers, copy-pasted as-is from the page source. PerlLover

Another way (for people who noticed the imagemap in level 8 is the shape of the bee) is to save the source of the web page, grab the imagemap tag from level 8, and stick first and second as coords inside two copies of the AREA tag, then view your modified page. Press TAB until the imagemap links are highlighted.

Solving with pygame

 import sys
 import pygame
 
 first=[list]
 second=[list]
 def getPs(data) :
   ps=[]
   for i in range(0,len(data),2) :
     ps.append((data[i],data[i+1]))
   return ps
 
 pygame.init()
 window = pygame.display.set_mode((640, 480))
 pygame.draw.polygon(window, (255, 255, 255), getPs(first))
 pygame.draw.polygon(window, (255, 255, 255), getPs(second))
 pygame.display.flip()
 
 while True: 
  for event in pygame.event.get(): 
     if event.type == pygame.QUIT: 
         sys.exit(0)
Solving with matplotlib

from pylab import  *
data=[146,399,163,....]
data2 = [156,141,165,.....]
x = [data[i] for i in xrange(0,len(data),2)]
y = [data[i] for i in xrange(1,len(data),2)]
plot(x,y)
x = [data[i] for i in xrange(0,len(data2),2)]
y = [data[i] for i in xrange(1,len(data2),2)]
plot(x,y)
show()
or, since you have numpy if you are using matplotlib,

figure()
first = asarray(data); second = asarray(data2)
plot(first[::2], first[1::2])
plot(second[::2], second[1::2])
a,b = ylim(); ylim(b,a) # turn upside down
show()
Solving with Imaging library

Just another way of solving the riddle... this time using python imaging library. You have to make a list of pairs or at least I haven't found the right way.

import Image
first = [...]
second = [...]
def makeimage(list, name):
 pairs = []
 aux = []
 skip = False
 itemindex = 0
 pairindex = 0
 for item in first:
   if skip == True:
     skip = False
     itemindex += 1
     continue
   pairs.append( [item, first[ (itemindex + 1) ] ] )
   pairindex += 1
   itemindex += 1
   skip = True
 img = Image.open(name + '.jpg')
 for x in pairs:
   img.putpixel(x, 1)
 img.save(name + '.jpg')
 makeimage(first, 'first')
 makeimage(second, 'second')

To pair up values from the list p, you can write zip(p[::2], p[1::2]). So the Python Imaging Library approach could look like this:

import ImageDraw
i = Image.new('1', (500,500), 1)
draw = ImageDraw.Draw(i)
for p in first, second: draw.line(zip(p[::2], p[1::2]))
i.save('bull.png')
Gareth Rees 02:58, 18 May 2007 (MDT)

Or more directly:

   import ImageDraw   # which will import Image
   img = Image.new("RGB",(640,480),'white')
   draw = ImageDraw.Draw(img)
   draw.line(first_list, 'green', 2)
   draw.line(second_list, 'red', 2)
   img.show(,'eog')
--Charles Merriam 03:45, 20 Jul 2007 (PDT)


Or, (with strings pasted into variables first and second):

import Image, ImageDraw, re
im = Image.new('RGB', (640, 480), 'white')
draw = ImageDraw.Draw(im)
for path in (first, second):
	draw.line(
		map(int, re.compile('\d+').findall(path)),
		'red', 4)
del draw
im.show()
Egourdin


Using polygon:

 from PIL import Image, ImageDraw
 img = Image.new("RGB",(640,480), 'white')
 draw = ImageDraw.Draw(img)
 draw.polygon(first_list, 'black')
 draw.polygon(second_list, 'grey')
 img.show()
jorjun 17:42, 30 Oct 2009 (GMT)


Complete solution:

# Written by - Dmitry Menshikov
import urllib2, re, Image, ImageDraw
def draw_figure(coord_list, color):
    coord_list = map(lambda s: int(s), coord_list)
    drawer.polygon(coord_list, outline=color)
auth_handler = urllib2.HTTPBasicAuthHandler()
auth_handler.add_password(realm='inflate',
    uri='http://www.pythonchallenge.com/pc/return/good.html',
    user='huge',
    passwd='file')
opener = urllib2.build_opener(auth_handler)
urllib2.install_opener(opener)

page = urllib2.urlopen('http://www.pythonchallenge.com/pc/return/good.html').read()
match = re.search(r'first:\n([\d,\n]+)\n\nsecond:\n([\d,\n]+)\n\n-->', page)
first, second = [match.group(i).replace('\n', ).split(',') for i in [1, 2]]

im = Image.new('RGB', (500, 500))
drawer = ImageDraw.Draw(im)

for arg in [(first, '#ccc'), (second, '#800')]:
    draw_figure(*arg)

im.save('c9image.png', 'PNG')
Solving with turtle

This method uses the turtle module that comes with Tk to plot the points. I've used the above technique to pair up the values. The x,y values need to be changed for turtle's coordinate system, which has the origin at the centre with x and y increasing right and up respectively.

from turtle import *
tk = Tkinter.Tk()
canvas = Tkinter.Canvas(tk, background="white", width=500, height=500)
canvas.pack( expand=1, fill="both" )
pen = RawPen( canvas )
def drawPoints( plist ):
  points = map(lambda x: (x[0]-250, 250-x[1]), zip(plist[::2], plist[1::2]))
  pen.up()
  pen.goto(points[0])
  pen.down()
  map(pen.goto, points)
drawPoints(first)
drawPoints(second)
tk.mainloop()
David Britnell 03:44, 24 May 2007 (MDT)

Solving with Tkinter in a different way

It was funny. I use the variable 'cow' quite often. I had to laugh when it was a cow! The picture is definately a cow, not a bull. And I didn't understand the second polygon.. the cow face. Took me a while of doing combinations of bull, cow, head, and face before I just typed bull in by itself. Oh well.

   #!/usr/bin/env python
   import Tkinter
   import time
   COW = [ 'copy paste set 1 here' ]
   SECOND = [ 'copy paste set 2 here' ]
   COUNT = 0
   OUTLINE = []
   print len(COW)
   while COUNT < len(COW):
       OUTLINE = OUTLINE + [(COW[COUNT], COW[COUNT + 1])]
       COUNT = COUNT + 2
   OUTLINE2 = []
   COUNT = 0
   while COUNT < len(SECOND):
       OUTLINE2 = OUTLINE2 + [(SECOND[COUNT], SECOND[COUNT + 1])]
       COUNT = COUNT + 2

   CANVAS = Tkinter.Canvas()
   CANVAS.create_polygon(OUTLINE, outline='Black', fill='Blue')
   CANVAS.create_polygon(OUTLINE2, outline='Black', fill='Red')
   CANVAS.pack()
   CANVAS.update_idletasks()
   time.sleep(30)

Another Solution with ImageMagick

My approach was very similar to PerlLover's. I, however, used curl and sed to get the strings from the webpage and used a slightly different set of options with convert.

#!/bin/bash
first=`curl -s -u 'huge:file' http://www.pythonchallenge.com/pc/return/good.html|sed -n '/^first.*$/,/^second.*$/ p'|tr -cd '0-9,'`
second=`curl -s -u 'huge:file' http://www.pythonchallenge.com/pc/return/good.html|sed -nE '/^second.*$/,/-->/p'|tr -cd '0-9,'`
convert -size 450x450 -fill "none" -stroke "black" -draw "polygon $first" -draw "polygon $second" xc:white x:
Or if you're on OS X like me, you can replace the x: in the convert command with something like gif:-|open -fa Preview That prevents you from having to start X11.

-Achates 10:59, 16 Apr 2008 (PDT)

Solving with NodeBox

source = ...
source = source.replace('\n', )
source = source.split(',')
source = map(int, source)
nofill()
stroke(0)
beginpath(source[0], source[1])
for i in range(2, len(source), 2): lineto(source[i], source[i+1])
endpath()
Impiaaa 17:27, 3 Dec 2008 (PST)

Solving in text-mode/ascii-art

Without any modules or graphics, since there are enough dots they don't have to be connected to show the cow.

aa=[['.']*80 for i in range(42)]
for dots in [first,second]:
  for i in range(0,len(dots),2):
    aa[int(dots[i+1]/10)][int(dots[i]/5)] = '#'
print '\n'.join([.join(a) for a in aa])
PTT 07:41, 16 Feb 2009 (PST)

Solving in HTML5 Canvas

<html>
 <head>
  <script type="application/javascript">
var first = [ /* first numbers */ ]
var second = [ /* second numbers */ ]
function draw(d) {
   var ctx = document.getElementById("canvas").getContext("2d");
   ctx.beginPath();
   ctx.moveTo(d[0], d[1]);
   for (var i = 2; i < d.length; i += 2) ctx.lineTo(d[i], d[i+1]);
   ctx.stroke();
}
   </script>
 </head>
 <body onload="draw(first); draw(second)">
   <canvas id="canvas" width="500" height="500"/>
 </body>
</html>
http://jsfiddle.net/Y7vFA/

Kyz 15:41, 17 Apr 2010 (PDT)

Ruby solution using RMagick

require 'RMagick'
first = [ ... ]
second = [ ... ]
size = (first+second).max + 20
img = Magick::Image.new(size, size)
draw = Magick::Draw.new
draw.fill_opacity(0)
draw.stroke('black')
draw.polyline(*first)
draw.polyline(*second)
draw.draw(img)
img.display
--Rebecca 06:13, 10 Aug 2010 (PDT)

Solution using SVG

Create two paths in an SVG document, and paste in the two point lists as the d attribute. Separate pairs with 'L' (I used the vim command :s/\(\d\+,\d\+\),/\1 L /g) and put 'm' at the head of the list. You'll wind up with something like this:

<?xml version="1.0" encoding="UTF-8"?>
<svg
  xmlns="http://www.w3.org/2000/svg"
  version="1.1">
   <path style="fill:black;stroke:black" d="m 156,141 L 165,135 L
           169,131 L 176,130 L 187,134 L 191,140 L 191,146 L 186,150 L
           179,155 L 175,157 L 168,157 L 163,157 L 159,157 L 158,164 L
           159,175 L 159,181 L 157,191 L 154,197 L 153,205 L 153,210 L
           152,212 L 147,215 L 146,218 L 143,220 L 132,220 L 125,217 L
           119,209 L 116,196 L 115,185 L 114,172 L 114,167 L 112,161 L
           109,165 L 107,170 L 99,171 L 97,167 L 89,164 L 81,162 L
           77,155 L 81,148 L 87,140 L 96,138 L 105,141 L 110,136 L
           111,126 L 113,129 L 118,117 L 128,114 L 137,115 L 146,114 L
           155,115 L 158,121 L 157,128 L 156,134 L 157,136 L 156,136"
           />
   <path style="stroke:black;fill:black" d="m 146,399 L 163,403 L
           170,393 L 169,391 L 166,386 L 170,381 L 170,371 L 170,355 L
           169,346 L 167,335 L 170,329 L 170,320 L 170,310 L 171,301 L
           173,290 L 178,289 L 182,287 L 188,286 L 190,286 L 192,291 L
           194,296 L 195,305 L 194,307 L 191,312 L 190,316 L 190,321 L
           192,331 L 193,338 L 196,341 L 197,346 L 199,352 L 198,360 L
           197,366 L 197,373 L 196,380 L 197,383 L 196,387 L 192,389 L
           191,392 L 190,396 L 189,400 L 194,401 L 201,402 L 208,403 L
           213,402 L 216,401 L 219,397 L 219,393 L 216,390 L 215,385 L
           215,379 L 213,373 L 213,365 L 212,360 L 210,353 L 210,347 L
           212,338 L 213,329 L 214,319 L 215,311 L 215,306 L 216,296 L
           218,290 L 221,283 L 225,282 L 233,284 L 238,287 L 243,290 L
           250,291 L 255,294 L 261,293 L 265,291 L 271,291 L 273,289 L
           278,287 L 279,285 L 281,280 L 284,278 L 284,276 L 287,277 L
           289,283 L 291,286 L 294,291 L 296,295 L 299,300 L 301,304 L
           304,320 L 305,327 L 306,332 L 307,341 L 306,349 L 303,354 L
           301,364 L 301,371 L 297,375 L 292,384 L 291,386 L 302,393 L
           324,391 L 333,387 L 328,375 L 329,367 L 329,353 L 330,341 L
           331,328 L 336,319 L 338,310 L 341,304 L 341,285 L 341,278 L
           343,269 L 344,262 L 346,259 L 346,251 L 349,259 L 349,264 L
           349,273 L 349,280 L 349,288 L 349,295 L 349,298 L 354,293 L
           356,286 L 354,279 L 352,268 L 352,257 L 351,249 L 350,234 L
           351,211 L 352,197 L 354,185 L 353,171 L 351,154 L 348,147 L
           342,137 L 339,132 L 330,122 L 327,120 L 314,116 L 304,117 L
           293,118 L 284,118 L 281,122 L 275,128 L 265,129 L 257,131 L
           244,133 L 239,134 L 228,136 L 221,137 L 214,138 L 209,135 L
           201,132 L 192,130 L 184,131 L 175,129 L 170,131 L 159,134 L
           157,134 L 160,130 L 170,125 L 176,114 L 176,102 L 173,103 L
           172,108 L 171,111 L 163,115 L 156,116 L 149,117 L 142,116 L
           136,115 L 129,115 L 124,115 L 120,115 L 115,117 L 113,120 L
           109,122 L 102,122 L 100,121 L 95,121 L 89,115 L 87,110 L
           82,109 L 84,118 L 89,123 L 93,129 L 100,130 L 108,132 L
           110,133 L 110,136 L 107,138 L 105,140 L 95,138 L 86,141 L
           79,149 L 77,155 L 81,162 L 90,165 L 97,167 L 99,171 L
           109,171 L 107,161 L 111,156 L 113,170 L 115,185 L 118,208 L
           117,223 L 121,239 L 128,251 L 133,259 L 136,266 L 139,276 L
           143,290 L 148,310 L 151,332 L 155,348 L 156,353 L 153,366 L
           149,379 L 147,394 L 146,399 L 146,399 146,399" />
</svg>
View in your favorite SVG viewer. Voila, a bull!

~bytex64 23:38, 14 Aug 2010 (PDT)

One way to get the data

While copy'n'paste gets'r done, here is one way to extract the data:

  def getcomments(url):
    """Returns list of comments in html page"""
    hf = urllib.urlopen(url)
    wholepage = hf.read()
    s = re.compile(r"<!--\s*((.|\s)+?)\s*-->") #a pattern for all comments, non greedy
    return [g[0] for g in s.findall(wholepage)]

  def lvl9_trial_getlists():
    commentlist = getcomments("http://www.pythonchallenge.com/pc/return/good.html")
    atlist = 0
    datasets = {'first':"", 'second':""}
    for line in commentlist[1].split('\n'):
        if line == "first:":
            atlist = 1
            continue # then skip to next line
        elif line == "second:":
            atlist = 2
            continue
        elif line == "":
            continue
        if atlist == 1:
            datasets['first'] += line
        elif atlist == 2:
            datasets['second'] += line
    for x in datasets:
        datasets[x] = map(int,datasets[x].split(','))
    return datasets
--Infini7y 01:21, 20 August 2011 (PDT)
_________________________________________________
Solution

Do you recognize that bull ?

After you gaze at your new friend, you look at sequence.txt. Each term in the sequence is a recipe for creating the previous term, i.e.:

1
11 - One time 1
21 - Two times 1 (or "two ones")
1211 - One time 2, One time 1 (or "one two, then one one")
111221 - One time 1, One time 2, 2 times 1 (or "one one, then one two, then two ones")
In terms of banner.p, it would be:

[('1', 1)]
[('1', 2)]
[('2', 1), ('1', 1)]
[('1', 1), ('2', 1), ('1', 2)]
[('1', 3), ('2', 2), ('1', 1)]
and so on. So spotting this problem is a bend-your-head thing, not a python thing.

This is the look-and-say sequence, first devised by John Horton Conway, who has a remarkable knack for developing deep insight starting from an apparently frivolous topic.

The sequence can be found in the On-Line Encyclopedia of Integer Sequences: http://www.research.att.com/projects/OEIS?Anum=A005150

Regular Expression Solutions

Here's a short & sweet way to get the whole job done, exploiting that regexps have a natural way to say "find the longest sequence starting at the current position consisting of repetitions of the current digit". The "(\d)" matches a digit as group #1, and the "\1" matches the same thing as group #1. Group #0, or m.group(0), is the entire string.

import re
def describe(s):
    return "".join([str(len(m.group(0))) + m.group(1)
                    for m in re.finditer(r"(\d)\1*", s)])
s = "1"
for dummy in range(30):
    s = describe(s)
print len(s)  # prints 5808
Here's another version of the regular expression portion, broken into two lines. This shows there are multiple ways to write this, and usually a concise way without explicit for loops.

def describe(s):
    sets = re.findall("(1+|2+|3+)", s)  # like "111", "2", ...
    return "".join([str(len(x))+x[0] for x in sets])
Lazy approach

You can solve almost any sequence puzzle by typing the numbers into the Online Encyclopedia of Integer Sequences. The page for sequence A005150 already has Python code in it, but you don't even need to copy and paste that, because you can see a cross-reference at the bottom to "Length of n-th term = A005341" and from there you can step to the list of values and pick the 31st entry. Gareth Rees 02:50, 18 May 2007 (MDT)

Other Ways

We'll use the following function to generate this sequence:

def push_one(seq, newch):
    if len(seq)==0 or seq[-1][0]!=newch:
        seq.append((newch,1))
    else:
        seq[-1]=(newch,seq[-1][1]+1)
    return seq
This function gets a sequence in banner.p format and tries to add newch to it. If it corresponds to the last tuple of seq, then its count is incremented by one, if the sequence is empty or the last tuple does not correspond to newch, a new tuple is added to the end of the sequence.

Examples:

>>> seq=[('3', 5), ('2', 4)]
>>> push_one(seq, '2')
[('3', 5), ('2', 5)]
Alternatively:

>>> push_one(seq, '4')
[('3', 5), ('2', 5), ('4', 1)]
We can use the built-in reduce() together with push_one()

>>> reduce(push_one, [[], '1', '1', '2', '1'])
[('1', 2), ('2', 1), ('1', 1)]
The first element of the sequence is a placeholder for the list, and reduce() pushes one char at a time to the sequence.

So we can define:

 >>> def getnext(x):
 ...   next = reduce(push_one, [[]] + [c for c in x])
 ...   return "".join(map(lambda pair: '%d%c' % (pair[1],pair[0]), next))
getnext() will calculate the next element of the sequence:

>>> getnext('1')
'11'
>>> getnext(_)
'21'
>>> getnext(_)
'1211'
>>> getnext(_)
'111221'
>>> getnext(_)
'312211'
And programmatically:

>>> l=[]
>>> x='1'
>>> for i in range(40):
...     l.append(x)
...     x = getnext(x)
>>> len(l[30])
5808
and we are heading to level 11.

An alternative solution

An alternative solution, in one function, is:

>>> from itertools import groupby
>>> def audioactive2(n):
...     strl = {("1","1","1"): "31", ("1","1"): "21", ("1",): "11",
...             ("2","2","2"): "32", ("2","2"): "22", ("2",): "12",
...             ("3","3","3"): "33", ("3","3"): "23", ("3",): "13"}
...     result = [1]
...     prec = "1"
...     for i in range(n-1):
...         prec = "".join(strl[tuple(l)] for e,l in groupby(prec))
...         result.append(prec)
...     return result
>>> print len(str(audioactive2(31)[-1]))
5808
The above algorithm was borrowed from http://www.fantascienza.net/leonardo/so/briciole_python1/

Yet Another Solution

This is a pretty short only one function version:

import re
>>> curr = '1'
>>> for each in range(30):
... 	match = re.findall("(\d)(\\1*)",curr)
... 	curr = "".join([str(len(k+y))+k  for k,y in match])
... 	
>>> print len(curr)
5808
Solution using generators

This one is different in that it works with lists of digits, instead of with strings.

import itertools

def compress(g):
    for key, subgenerator in itertools.groupby(g):
        yield len(list(subgenerator))
        yield key

def mk_recurse_n(f, n):
   def inner(g):
       for i in range(n):
           g = f(g)
       return g
   return inner

g = mk_recurse_n(compress, 30)([1])
a = list(g)
print len(a)
Ugliest solution by far

This solution does not use regexps nor any python magic (just lists).

def next(f):
    ret = []
    i = 0
    num = 1
    while i < len(f):
        if i < len(f)-1 and f[i] == f[i+1]:
            num += 1
        else:
            ret.append("%d%s" % (num, f[i]))
            num = 1
        i += 1
    return "".join(ret)

a = "1"
for i in range(31):
    print "len(seq[%d]) = %d" % (i, len(a))
    a = next(a)
Even uglier solution

And you thought you did it wrong.

a=[[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1]]
for i in range(27):
   b=[]
   item=a[-1]
   n=0
   while n<len(item):
       try:
           item[n+1]==item[n]
       except IndexError:
           b.append(1)
           b.append(item[n])
           n=n+1
       else:
           if item[n+1]==item[n]:
               try:
                   item[n+2]==item[n]
               except IndexError:
                   b.append(2)
                   b.append(item[n])
                   n=n+2
               else:
                   if item[n+2]==item[n]:
                       b.append(3)
                       b.append(item[n])
                       n=n+3
                   else:
                       b.append(2)
                       b.append(item[n])
                       n=n+2
           else:
               b.append(1)
               b.append(item[n])
               n=n+1
   a.append(b)
   x=i
print len(a[30])

And the one with the most if/else logic

a = ['1']
for x in range(31):
  morris = ""
  n = 0
  while len(a[x]) > n:
    if len(a[x]) > n + 1:
      if int(a[x][n+1]) == int(a[x][n]):
        if len(a[x]) > n + 2:
          if int(a[x][n+2]) == int(a[x][n+1]):
            morris = morris + '3' + a[x][n]
            n = n + 3
          else:
            morris = morris + '2' + a[x][n]
            n = n + 2
        else:
          morris = morris + '2' + a[x][n]
          n = n + 2
      else:
        morris = morris + '1' + a[x][n]
        n = n + 1
    else:
      morris = morris + '1' + a[x][n]
      n = n + 1
  a.append(morris)
print(len(a[30]))
C-style solution

count = 0
s = "1"
a = [s]
while count < 31:
   j = 0
   news = ""
   while j < len(s):
       i = j
       while j < len(s) and s[i] == s[j]:
           j += 1
       news += str(j-i) + s[i]
   a += [news]
   s = news
   count += 1
print len(a[30])

A newbie solution

Finds the next sequence e.g. s='111221' -> E=[1, 2, 1], M=[3, 2, 1] -> T=['3', '1', '2', '2', '1', '1'] -> s='312211'

E is the sequence without repetition
M is multiplicity
   s='1'
   for n in range (1,31):
       M,T,E = [],[],[s[0]]
       # generate E and M
       nrep=1      # number of repeats
       for i in range(0,len(s)-1):
               if (s[i] != s[i+1]):
                   E.append(s[i+1])
                   M.append(nrep)
                   nrep=1
               else: nrep=nrep+1
       M.append(nrep)
       # generate T
       for k in range(len(M)):
           T.append(repr(M[k]))
           T.append(E[k])
       s="".join(T)
       # print s,      # if you want to see the string
       print len(s)
A newbie&& A c-style solution

dosent use much 'magic' things

def next(text):
	bit = text[0]
	num = 0
	delta = 0
	ret = ''
	while(num + delta < len(text)):
		while(num + delta < len(text) and bit == text[num + delta]):
			num+=1
		ret += str(num) + bit
		if(num + delta < len(text)):
			bit = text[num + delta]
		delta += num
		num = 0
	return ret
x = '1'
for loop in range(30):
	x = next(x)
len(x)
--Coolbenson 02:33, 20 Jul 2010 (PDT)

Shortest solution

x="1"
for each in range(30):
    x="".join([str(len(i+j))+i for i,j in re.findall(r"(\d)(\1*)", x)])
print len(x)

Another One

Somehow like the C-Style but functional and reusable:

def morris(num=1, n=0):

   i = 0
   num = list(str(num))
   while i < n:
       new_num = []
       last = None
       count = 0
       ii = 0
       while ii < len(num):
           if last is None: 
               last = int(num[ii])
               count += 1
           elif last == num[ii]:
               count += 1
           else:
               new_num.append(count)
               new_num.append(last)
               last = int(num[ii])
               count = 1
           ii += 1
       else:
           new_num.append(count)
           new_num.append(last)
           num = new_num
       i += 1
   return num

One Line Shortest Solution

If you have obsession in having anything in one line, try it:

len(reduce(lambda p,k:reduce(lambda s,(a,b):s+str(len(list(b)))+a,groupby(p),""),xrange(30),"1"))
True oneliner:

len(reduce(lambda p,k:reduce(lambda s,(a,b):s+str(len(list(b)))+a,__import__("itertools",[],['groupby']).groupby(p),""),xrange(30),"1"))
Little class iterator

The following implements an iterator which generates Morris numbers. You just have to iterate up to the twenty-ninth, and you're set to go. The following could also be coded as a generator, but I chose not to. ;-)

class Morris(object):
    def __init__(self,start):
        self._cur = start
    def __iter__(self):
        return self
    def next(self):
        lastchr = None
        cnt = 0
        buf = []
        for curchr in self._cur:
            if lastchr == curchr:
                cnt += 1
            else:
                if lastchr is not None:
                    buf.append("%s%s" % (cnt,lastchr))
                lastchr = curchr
                cnt = 1
        buf.append("%s%s" % (cnt,lastchr))
        self._cur = "".join(buf)
        return self._cur
for i, num in enumerate(Morris("1")):
    if i+1 == 30:
        break
print len(num)
And just another 3-liner solution

This one is more a hack than a real solution. I'm not really in regexps. First, if one thinks of it, no sequence of equal numbers can be longer than 3 digits, and so only digits 1, 2 and 3 can occur in the sequence.

a = '1'
for i in range(30):
    a = "".join(map(lambda x: `len(x)`+x[0], re.findall('(1+|2+|3+)', a)))
print len(a)
Gives 5808.


Recursive solution

Ugly, ugly, ugly.

def func(x):
	if (x>1):
		sr = func(x-1)
	else:
		sr = "1"
	prev = ""
	count = 0
	lst = list()
	for i in sr:
		if (i != prev and prev != ""):
			lst.append((str(prev),str(count)))
			count = 1
		else:
			count = count+1
		prev = i;
		
	lst.append((str(prev),str(count)))
		
	output = ""
	for i in lst:
		output = output+i[1]+i[0]
	print "Length of "+str(x)+": "+str(len(output))
Another Recursive Solution

import itertools
def getPos(n=0, start='1'):
    if n > 0:
        result = ''
        for s, group in itertools.groupby(start):
            result += str(len(list(group))) + str(s)
        return getPos(n-1, result)
    return start
print len(getPos(30))
Another recursive solution (using lists)

def natural_iteration (r, list=[1]):
	if (r < 1):
		return list
	newlist = [1, list[0]]
	for n in list[1:]:
		if newlist[-1] == n:
			newlist[-2] += 1
		else:
			newlist.extend([1, n])
	return natural_iteration(r-1, newlist)

len(natural_iteration(30))
Egourdin

Another?

a=[1 ]
t=""
while len(a) <= 30:
	t="%s" % a[-1]
	last=""
	result=""
	count=1
	last=t[0]
	for i in range(1,len(t)):
		n=t[i]
		if n == last:
			count=count+1
		else:
			result= result + "%s%s" % (count, last)
			count=1
		last=n
	result=result+ "%s%s" % (count, last)
	a.append(result)

print "len(a[30])=%s" % (len(a[30]))
Another recursive solution with lstrip()

Slightly different from the ones above, still ugly, but quite readable...

### sequence(n): gives the nth look-and-say string ###
def sequence(n):
    if n == 0:
        return "1"
    else:
        prev = sequence(n-1)
        next = ""
        while len(prev) > 0:
            leadingchar = prev[0]
            lengthbefore = len(prev)
            prev = prev.lstrip(leadingchar)
            lengthafter = len(prev)
            next += str(lengthbefore-lengthafter) + leadingchar
        return next

print len(sequence(30))
Sayit

Here's a solution in simple Python:

def sayit(term_string):
    out = ''
    prev = term_string[0]
    runlength = 1
    for i in term_string[1:]:
        if i == prev: # more of same
            runlength += 1
        else:         # run of new char; flush and reset
            out += str(runlength) + prev
            prev = i
            runlength = 1
    # final flush
    return out + str(runlength) + prev

term = '1'
for dmy in range(30):
    term = sayit(term)
print len(term)
This gives a 100% speedup over the first "describe" regex solution, 50% over the "shortest" regex solution, and 40% over the "another C-style" solution. I'm running 2.6, 10Dec07 svn, on GNU/Linux.

(On 3.0 28Dec07 svn the ratios are similar, but everything is 25% slower.)

I found this surprising. I expected the regex solutions to be much faster since they use a C module.

Yet another

This one is very similar to the previous two. It is worth noting how I avoided the "# final flush" of above solution (sayit). Yeah, kinda ugly, but clever. ;-) --CrazyTerabyte 16:52, 15 Dec 2008 (PST)

index=0
value="1"
while index<30:
    index+=1
    r=""
    prev=""
    count=0
    for i in value+"_":
        if prev==i:
            count+=1
        else:
            if prev!="" or i=="_":
                r+=str(count)+prev
            prev=i
            count=1
    value=r
print len(value)
another generator solution

def level10():
    """http://www.pythonchallenge.com/pc/return/bull.html
    """
    import itertools
    def conway():
        x = '1'
        while True:
            yield x
            nx = ''
            for item, grouper in itertools.groupby(x):
                nx += '%d%s' % (len(list(grouper)), item)
            x = nx
    suite = conway()
    for i in range(30):
        suite.next()
    print len(suite.next())


Solution with tail recursion

def inflate(n, acc):
	if n == 0:
		print len(acc)
	else:
		res = ""
		last = ""
		count = 0
		for c in acc:
			if last == c:
				count += 1
			else:
				if count != 0 and last != "": res += str(count) + last
				last = c
				count = 1
		if count != 0 and last != "": res += str(count) + last
		inflate(n - 1, res)


inflate(30, "1")
Without regular expressions

def annotate(num, pos=1):
    while pos < len(num):
        if num[pos] == num[pos-1]: 
            pos += 1
            continue
        num = '%s_%s' % (num[:pos], num[pos:])
        pos += 2
    
    ans = [str(len(i)) + i[0] for i in num.split('_')]
    return ''.join(ans)


num = '1'
for i in range(30): num = annotate(num)
print len(num)
jorjun 19:30, 30 October 2009 (GMT)

And in Ruby

def sayit(current)
  current.scan(/((.)\2*)/).inject("") {|m,o| m << o[0].size.to_s << o[1]}
end
puts (1..30).inject('1'){|m,o| sayit(m)}.length
Using list comprehensions and generators

import itertools
def morris(start = 1):
    #seed
    n = [str(start)]
    while True:
        #algorithm
        yield n
        l = [[p[1],p[0]] for p in [[c,str(len(list(cs)))] for c,cs in itertools.groupby(n)]]
        n = [value for row in l for value in row]

s = morris()

serie = []
for i in range(31):
    serie.append(s.next())

print len(serie[30])
Another short one using re.split, List Comprehension and Array slices

x = '1'
for a in range(30):
    x = ''.join(["%s"%len(a)+a[0] for a in re.split(r"(([0-9])\2*)", x) if a][::2])
print len(x)
--Christopheg 17:45, 18 Oct 2010 (PDT)

Bash shell one-liner

It's the shortest on this page as of now. Remove some of the spaces to get under 80 characters.

a=1; for i in `seq 30`; do a=`echo $a | tr ' ' '\n' | uniq -c`; done; echo $a | wc -w
benlynn Sat May 22 14:12:08 PDT 2010

Functional solution

2 Functions. Not the shortest one but simple.

def count(str):
    pivot = str[0]
    i = 0

    while i < len(str) and str[i] == pivot:
        i += 1
    return pivot, i, str[i:]

def compute_next(str):

    next_string = ""

    while str != "":
        pivot, i, reduced_str = count(str)
        string = repr(i) + pivot

        next_string += string

        str = reduced_str
    return next_string

for i in range(30):
    string = compute_next(string)

print "solution is:", len(string)

uploada Sat Nov 27 17:36:40 JST 2010


Looping over a shifted list

A general idiom to get two adjacent items in each for-loop iteration: zip a sequence with a itself shifted by one.

def the_next_number(s):
  result = ''
  count = 1
  for now, next in zip(s, s[1:] + None):
    if now == next:
      count += 1
    else:
      result += str(count) + now
      count = 1
  return result
--En-cu-kou 10:52, 15 Dec 2010 (PST)

Fairly short solution that uses exceptions

def parseString(text):
    count = 1
    newStr = ""
    for i in range(len(text)):
        try:
            if(text[i] == text[i+1]):
                i += 1
                count += 1
            else:
                newStr += str(count) + text[i]
                count = 1
        except IndexError:
            newStr += str(count) + text[i]
            count = 0

    return newStr

rleString = "1"
for i in range(30):
    rleString = parseString(rleString)
    print rleString

print len(str(rleString))
--Finity 05:38, 27 Mar 2011 (CST)

Another generator, another solution

its not re, but generators are iterable =)

def lvl10_gen_morris():
  # 1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ...
  a = '1'
  while 1:
    yield a
    b = ''
    pc = '' # previous c
    for c in a:
      if c != pc: # always true when on first c => pc == ''
        if pc != '':
          b += str(i) + pc
        i = 1
        pc = c
      else:
        i += 1
    a = b + str(i) + c

def lvl10_trial():
  for i,m in enumerate(lvl10_gen_morris()):
    if i == 30:
      print len(m)
      break
--Infini7y 22:23, 22 August 2011 (PDT)

____________________________________________----
Intro

The somewhat vague image requires some sifting; into odd and even pieces,in fact. You can split out the image into four: one holding all pixels at the even x and y coordinates, one with the odd coordinates, and two with either the x or the y coordinates odd and the other even:

import urllib, Image
from cStringIO import StringIO
def splitOE(source):
    results = []
    width, height = source.size
    results = [Image.new(source.mode, (width//2, height//2))
               for dummy in range(4)]
    for x in range(width):
        for y in range(height):
            target = results[x%2 + (y%2<<1)]
            target.putpixel((x//2, y//2), source.getpixel((x, y)))
    return results
url = 'http://huge:file@www.pythonchallenge.com/pc/return/cave.jpg'
odd_even = splitOE(Image.open(StringIO(urllib.urlopen(url).read())))
for result in odd_even:
    result.show()
Two of these images will show a vague redish background and the word 'evil' (turn up your brightness if needed!). Enough to make you shudder and move on to the next level.

Note that being able to put the username and password ("huge:file@") into the URL is an undocumented aspect of urllib. If you leave it out, you'll be prompted to enter the name and password instead.

Four groups? Nonsense! Just black out every other pixel!

Most of these solutions make the riddle more complicated than necessary, I think.

Looking at the image, you can see that every other pixel is colored, like a checkerboard. Simply black out all the "colored" pixels to get the secret image!

import Image,ImageDraw

im = Image.open("cave.jpg")

coords = []

# Fill coords[] with the pixels to black out.
# There's probably a more elegant way to do this
# instead of for-loops, but why mess with what works?

# rows 0,2,4...
for x in range(1,im.size[0],2):
    for y in range(0,im.size[1],2):
        coords.append( (x,y) )

# rows 1,3,5...
for x in range(0,im.size[0],2):
    for y in range(1,im.size[1],2):
        coords.append( (x,y) )

draw = ImageDraw.Draw(im)
draw.point( coords, fill="black" )
im.save("foo.png")
GrantB 14:43, 26 Jul 2007 (PDT)

TimK

TimK: I did it a little bit differently - I took the original image, moved the odd pixels to the upper left, and wrote the image back out. This actually moves all of the pixels to x/2, y/2, but the odd ones stomp the evens.

import Image
im = Image.open("cave.jpg")
for x in range(im.size[0]):
    for y in range(im.size[1]):
        im.putpixel((x//2, y//2), im.getpixel((x, y)))
im.save("cave.png", "PNG")
And yet one more way:

import Image
blank = Image.new('RGB', (320, 240))
im = Image.open('cave.jpg')
for x in range(640):
    for y in range(480):
        if (x+y)%2 == 0:
            pixel = im.getpixel((x, y))
            blank.putpixel((x//2, y//2), pixel)
blank.show()
There's another way not involving programming: just open the image in some viewer program, and scale it down. There's a big chance one of the scaling will result in the hidden image.

VinceB

VinceB: The Image.transform method works pretty sweetly:

import Image
cave = Image.open('cave.jpg')
newcave = cave.transform((cave.size[0]//2, cave.size[1]//2),
                         Image.AFFINE, (2,0,0,0,2,0))
newcave.show()
Mvanderkolff

Mvanderkolff: That's neat! I did it another way:

img = urllib.urlopen('http://www.pythonchallenge.com/pc/'
                     'return/cave.jpg').read()
idata = Image.open(StringIO.StringIO(img))
imgs = [Image.new("RGB", (320, 480)), Image.new("RGB", (320, 480))]
currCol = currRow = 0
for i in idata.getdata():
    imgs[(currCol+currRow) % 2].putpixel((currCol//2, currRow), i)
    currCol += 1
    currRow += currCol//640
    currCol %= 640
Tr3w

Tr3w: "Affine transformation" is cool, but another way without odd/even trick

import Image, ImageEnhance
im=Image.open("cave.jpg")
final=ImageEnhance.Brightness(im)
final.enhance(8).show()
sjthebat

sjthebat: yet another solution

import Image
im = Image.open('cave.jpg')
data = list(im.getdata())
im_new = Image.new(im.mode, im.size)
im_new.putdata(data[::2] + data[1::2])
im_new.show()
scholi

scholi: A different solution I havent created 4 different pictures with half of the size, but I render only one pixel over 2.

import Image
im=Image.open('cave.jpg')
im1=Image.new('RGB',(640,480))
for y in range(0,480):
    for x in range(0,640):
        c=im.getpixel((x,y))
        if (x+y)%2==0:
            im1.putpixel((x,y),(c[1]*3,c[1]*3,c[1]*3))
im1.show()
Comments: I see immediatly that the domminant color was green (but dark). so this why you see the tuple (c[1]*3,c[1]*3,c[1]*3). The *3 is to make a bigger contrast
julie

julie: Just resizing the image by 1/2 (to 320x240) using the default 'nearest' filter worked for me. Although perhaps by accident.

import Image
original = Image.open('cave.jpg')
im=original.resize((320,240))
im.save('result11.jpg')
daveidmx

daveidmx: I played with sequences initially, and then realized I could totally take advantage of nearest-neighbor scaling:

Image.open('cave.jpg').resize((320, 240)).show()
wgsohne

wgsohne: Hmm. This was really some sifting :-) I just kept on isolating the tuples with small values. My method works out the same in different ways as well.

 from PIL import Image
 from PIL import ImageDraw
 image = Image.open('cave.jpg')
 data = list(image.getdata())
 cols = 640
 rows = 480
 def sift(stride, array):
   sifted = []
   for scanline in range(stride):
     sifted += array[scanline * cols/2 : (scanline + 1) * cols/2]
   return sifted
 image.putdata(sift(rows/4, sift(rows, data[0 : cols * rows : 2])))
 image.show()
Works the same for the slice data[0 : cols * rows : 2] as well ...

Simpler version of a bunch of the above without using getpixel and putpixel

 from PIL import Image
 im=Image.open("cave.jpg")
 full=list(im.getdata())
 even=full[0::2]
 im.putdata(even)
 im.show()
It puts the whole data in a list called full, and I then only take every other element, and then put it back into the original image (the top left quarter is the new image). Beetle B. 15:01, 28 May 2007 (MDT)

Solving without Python modules

PerlLover: I solved it by executing:

convert -colors 92 cave.jpg cave.xpm
and performing simple text-based transformations on the resulted xpm. But there is a much better solution (try it):

convert -modulate 500 cave.jpg evil.png
Solving using The GIMP

meteficha: This one was easy. Just open the image on GIMP with zoom at 100%. Next you remove the first column and line of pixels by changing the size of the image *without resizing*. Move the zoom to 50% and SURPRISE! :-)

Finity: I couldn't get the above method to work for me (probably doing it wrong), but the method I used was to load the image in the GIMP -> right click -> colors -> levels -> Drag the white triangle under "Input Levels" all the way to the left (Until it matches up with the huge peak on the left). Clear as day, then :)

mspaint

Loaded the image into mspaint. Then inverted the colours. The word became clearly visible.

Internet Explorer

View the image alone in Internet Explorer, then hit Ctrl-A (Edit -> Select All). Internet Explorer always stipples images to highlight them.

Solving with unneeded complication

FellowMD: I decided this could potentially be a good time to test my skills with generators. Here's the module I ended up running:

from PIL import Image
cave=Image.open("D:\Documents and Settings\Aaron\Desktop\cave.jpg")
cavestring=cave.tostring() 

def makeFlipper(first):
    while 1:
        yield first
        yield first
        yield first
        first= not first 

def make_good(s):
    index=0
    while index<len(s):
        line=s[index:index+1920]
        flipper=makeFlipper(True)
        if (index/1920) % 2:
            flipper.next()
            flipper.next()
            flipper.next()
        result=[f for f in line if flipper.next()]
        index+=1920
        yield "".join(result)

goodstring="".join([j for j in make_good(cavestring)])
goodimage=Image.fromstring('RGB',(320,480),goodstring)
goodimage.show()
Pretty terrible, I know, but there wasn't a solution up w/ generators. And I solved this one without looking at the hints section.

Matplotlib, numpy, PIL and slices

Using slices makes evens and odds pretty easy.

 import urllib,numpy,Image
 from pylab import *
 
 urllib.urlretrieve('http://huge:file@www.pythonchallenge.com/pc/return/cave.jpg','cave.jpg')
 im=numpy.asarray(Image.open('cave.jpg'))
 
 x,y,z=im.shape
 imshow(im[0:x:2,0:y:2,:])
 #in case the even image is not the interesting image
 figure()
 imshow(im[1:x:2,1:y:2,:])
 show()
Solving with a list comprehension

AoifeH: The magic is "if (x + y) % 2 == 0". The "tuple([val*2 for val in im.getpixel((x,y))])" is to turn up the contrast (not a good solution normally, but good enough for this exercise).

 import Image
 im = Image.open("cave.jpg")
 testim = Image.new('RGB', (640,480))
 width, height = 640,480
 [[testim.putpixel((x,y), tuple([val*2 for val in im.getpixel((x,y))])) for y in range(height) if (x + y) % 2 == 0] for x in range(width)]
 testim.save(open("answer.jpg", "w"))
Bash one-liner

Using Netpbm tools:

cat cave.jpg | jpegtopnm | pnmscale 0.5 -nomix | pnmtopng > tmp.png
The last conversion is unnecessary if your image viewer supports the PPM format.

benlynn Sat May 22 19:07:10 PDT 2010


Ruby solution with RMagick

require 'RMagick'

input = Magick::ImageList.new("cave.jpg")
width = input.columns
height = input.rows
input_view = input.view(0, 0, width, height)

outputs = (0...4).map { Magick::Image.new(width/2, height/2) }
output_views = outputs.map { |img| img.view(0, 0, width/2, height/2) }

(0...height).each do |i|
  (0...width).each do |j|
    if i%2==0 and j%2==0
      output_views[0][i/2][j/2] = input_view[i][j]
    end
    if i%2==1 and j%2==0
      output_views[1][i/2][j/2] = input_view[i][j]
    end
    if i%2==0 and j%2==1
      output_views[2][i/2][j/2] = input_view[i][j]
    end
    if i%2==1 and j%2==1
      output_views[3][i/2][j/2] = input_view[i][j]
    end
  end
end

output_views.map { |v| v.sync }
outputs.each { |out| out.display }
--Rebecca 00:09, 11 Aug 2010 (PDT)

Python - Split the two images

from PIL import Image

pic = Image.open("cave.jpg")
width, height = pic.size

even = Image.new("RGB", [640, 480])
odd = Image.new("RGB", [640, 480])
evenpixels = even.load()
oddpixels = odd.load()

for x in range(0, width, 2):
    for y in range(0, height, 2):
        evenpixels[x, y] = pic.getpixel((x, y))
        evenpixels[x+1, y+1] = pic.getpixel((x+1, y+1))
        oddpixels[x, y+1] = pic.getpixel((x, y+1))
        oddpixels[x+1, y] = pic.getpixel((x+1, y))

even.show()
odd.show()

__________________________________________________
import Image
from cStringIO import StringIO

s = open("evil2.gfx", "rb").read()
for i in range(5):
    piece = s[i::5]  # every fifth byte, starting at i
    im = Image.open(StringIO(piece))
    f = open("%d.%s" % (i, im.format.lower()), "wb")
    f.write(piece)
    f.close()
PIL is used there only to deduce appropriate filename extensions (there are three graphics formats in use here). Depending on what you use to view graphics, it may not care about the extension at all (in which case deducing extensions is a waste of effort). Here are the correct extensions:

open("one.jpg", "wb").write(s[0::5])
open("two.png", "wb").write(s[1::5])
open("three.gif","wb").write(s[2::5])
open("four.png", "wb").write(s[3::5])
open("five.jpg", "wb").write(s[4::5])
ERROR: this does not work

Contents [hide]
1 Solving if you don't need the extensions
2 Deal the cards
3 Solving with perl
4 Bash
5 Ruby
6 Wuelfhis Way
Solving if you don't need the extensions

f=open("evil2.gfx",'rb').read()

for i in range(5):
    open("image"+str(i)+".dat", "wb").write(f[i::5])
Deal the cards

Avoids slicing whole input string 5 times. LF holds open file objects, the program then goes through the "deck" (input file) just once giving each "player" (open file) a "card" (character) in a round fashion, just like the challenge picture suggested ;-)

LF = []
for i in range(5):     # This creates files img0.dat .. img4.dat
    LF.append(open('img%d.dat' % i, 'wb'))

for i, c in enumerate(open('evil2.gfx', 'rb').read()):
    LF[i%5].write(c)

LF = []     # make Python close files by deallocating array
Solving with perl

perl -e 'print `cat evil2.gfx` =~ /(.)..../gs' >image1.jpg
perl -e 'print `cat evil2.gfx` =~ /.(.).../gs' >image2.png
perl -e 'print `cat evil2.gfx` =~ /..(.)../gs' >image3.gif
perl -e 'print `cat evil2.gfx` =~ /...(.)./gs' >image4.png
perl -e 'print `cat evil2.gfx` =~ /....(.)/gs' >image5.jpg
Bash

for i in `seq 5`; do xxd -p -c5 evil2.gfx | cut -b$((2*i-1))-$((2*i)) | xxd -r -p > img$i; done
I ran "feh img?" to display the images. It only showed part of the fourth image, but it was enough.

Benlynn 23:27, 22 May 2010 (PDT)


Ruby

evil =  File.read("evil2.gfx")
outputs = (0...5).map { |i| File.open("level12_out%i" % i, "w") }
counter = (0...5).to_a.cycle
evil.each_char { |char| outputs[counter.next].write(char) }
--Rebecca 01:14, 11 Aug 2010 (PDT)

Wuelfhis Way

Off course you already downloaded the wrong .jpg i renamed it as evil5.gfx

import urllib

f=open("evil5.gfx",'r')
data=f.read()
f.close()

tupla=['','','','','']
cont=0

for char in range(len(data)):
    tupla[cont]+=data[char]
    cont+=1
    if cont==5:
        cont=0

for i in range(len(tupla)):
    f = open("file"+str(i)+".jpg",'w')
    f.write(tupla[i])
    f.close()
    

    _______________________________________________
>>> import xmlrpclib
>>> url = 'http://www.pythonchallenge.com/pc/phonebook.php'
>>> phonebook = xmlrpclib.Server(url)
>>> phonebook.phone('Bert')
'555-ITALY'
We learn that his number is '555-ITALY'. 'italy' is the key to the next level.

RPC Introspection

How did we know which method to use here? You can guess "phone", but there's another way:

>>> print phonebook.system.listMethods()
['phone',
 'system.listMethods',
 'system.methodHelp',
 'system.methodSignature',
 'system.multicall']
"phone" is the only non-system method, and obviously fits. More info about it:

>>> print phonebook.system.methodHelp("phone")
Returns the phone of a person
>>> print phonebook.system.methodSignature("phone")
[['string', 'string']]
That last one returns a list of supported method signatures, and says that the "phone" method supports only one signature: pass a string to it, and get a string back from it.

Using bash

Here's a little bash script to do it.

 #!/bin/bash
 site="http://www.pythonchallenge.com/pc/phonebook.php"
 curl --header "Content-Type: text/xml"  --data "
 <methodCall>
   <methodName>phone</methodName>
   <params>
      <param>
        <value><string>Bert</string></value> 
      </param>
    </params>
 </methodCall>" $site 
 echo
Or if you prefer a one-liner:

 curl --header "Content-Type: text/xml"  --data "<methodCall><methodName>phone</methodName><params><param><value> \
 <string>Bert</string></value></param></params></methodCall>" "http://www.pythonchallenge.com/pc/phonebook.php"
I broke the line up to save the formatting. Ugly right?

-Achates

Wuelfhis Way

For me was the easiest ever !!! Was easy to discover the module, and later just try the php page

import xmlrpclib

s = xmlrpclib.ServerProxy('http://www.pythonchallenge.com/pc/phonebook.php')
print s.system.listMethods()
print s.phone('Bert')  


#Respuesta devuelve un 555-ITALY, la clave: italy
________________________________________________________
The hints tell us to spiral something round. The small image displayed on this page is deceptive; it is in fact a 10000x1 image (yes, 1 pixel high), which can be transformed into a 100x100 picture by spiralling it clockwards and inwards:

>>> def spiral(source):
...     target = Image.new(source.mode, (100, 100))
...     left, top, right, bottom = (0, 0, 99, 99)
...     x, y = 0, 0
...     dirx, diry = 1, 0
...     for i in xrange(10000):
...         target.putpixel((x, y), source.getpixel((i, 0)))
...         if dirx == 1 and x == right:
...             dirx, diry = 0, 1
...             top += 1
...         elif dirx == -1 and x == left:
...             dirx, diry = 0, -1
...             bottom -= 1
...         elif diry == 1 and y == bottom:
...             dirx, diry = -1, 0
...             right -= 1
...         elif diry == -1 and y == top:
...             dirx, diry = 1, 0
...             left += 1
...         x += dirx
...         y += diry
...     return target
The picture shows you a cat, so we type in 'cat' and we get to see a larger picture of of this cat with another in the background. The caption says this is 'uzi' and we'll hear from him later. 'uzi' is in fact the real key to the next level.

The red pixels you see along the edge are a 'red herring'; if you don't spiral the pixels but just copy them over line by line, they form the word 'bit', and bit.html tells you you took the wrong curve.

Contents [hide]
1 Hiding Messy Logic
2 Alternate solution
3 Alternate solution
4 another easy to understand method
5 "Fair" variant of the above method (Leonid Shvechikov)
6 Non-solution that works
7 Very nice haskell solution
8 List with pixelpositions in spiral order
9 Pixelpositions in spiral order, recursive version
10 Map spiral segments to fixed array
11 Alternate solution using complex numbers
12 Alternative solution with recursive iterator
13 Another recursive generator
14 PEZ: Brute solution using a generator
15 My methods, using generator
16 Darkdragon: Intuitive spiral solution (a la State Machine)
17 Method Using an Iterator (Ian Milligan)
18 Pixel coordinate translation with a basic arithmetical function (Solus)
19 Another explicit for-loop solution
20 A very heavy functional solution...
21 With NumPy Array
22 (un)Parameterize the spiral
23 what about my solution
24 Another "step" variation
Hiding Messy Logic

The boundary conditions when spiraling are delicate and unforgiving. While slower, it's easier to write a little class to keep track of pixel positions we've already used:

# Keep track of pixel locations we can't use, either because
# we've already used them, or because they're out of bounds.
class BoundedBox:
    def __init__(self, xbound, ybound):
        self.xbound, self.ybound = xbound, ybound
        self.seen = set()
    
    def __contains__(self, point):
        x, y = point
        return (point in self.seen or
                not 0 <= x < self.xbound or
                not 0 <= y < self.ybound)
    
    def add(self, point):
        self.seen.add(point)
The fiddly logic to map directions to coordinate deltas, and to decide which direction to take next, can also be encapsulated in a few dicts and a function:

deltas = {"E": (1, 0), "S": (0, 1),
          "W": (-1, 0), "N": (0, -1)}
turn = {"E": "S", "S": "W", "W": "N", "N": "E"}

def move(point, direction):
    dx, dy = deltas[direction]
    return point[0] + dx, point[1] + dy
Given that to build on, the rest of the program is wonderfully easy to understand. Note, e.g., that the loop body no longer deals with individual x/y coordinates:

import Image
im = Image.open("wire.png")
out = Image.new("RGB", (100, 100))
blocked = BoundedBox(100, 100)
point = 0, 0     # start at upper left
direction = "E"  # moving East
for pixel in im.getdata():
    assert point not in blocked
    blocked.add(point)
    out.putpixel(point, pixel)
    newpoint = move(point, direction)
    if newpoint in blocked:
        direction = turn[direction]
        newpoint = move(point, direction)
    point = newpoint
out.show()
Alternate solution

Caution: somewhat obfuscated. It helps if you write down what is happening on paper.

The basic idea is to ignore the directions that the cursor will move and instead rotate the image 90 degrees.

import Image
n = 100
im = Image.new('RGB', (n, n))
wire = Image.open('wire.png')
count = 0
for x in range(n*2):
    y = x//4
    first = y+1
    last = n-y
    if x%4 == 0:
        first -= 1
    if x%4 == 3:
        last -= 1
    for i in range(first, last):
        im.putpixel((i, y), wire.getpixel((count+i-first, 0)))        
    im = im.rotate(90)
    count += last - first
im.show()
Alternate solution

The basic idea behind this solution is that the value of x and y depend entirely on the three parameters: width, height and n, where n is an integer greater than or equal to 0. The only minor advantage to this solution is that you don't need to keep track of nearly as many variables as they can all be computed from the input (after hard-coding width and height dependant pieces). It's even possible to go backwards if you feel like rendering the output image a line at a time.

import math
import Image

def getpixel(t):
    t = (100*100-1) - t
    shell = int((math.sqrt(t) + 1)/2)
    if shell == 0:
        leg = 0
    else:
        leg = int((t - (2*shell-1)**2)/2/shell)
    elem = t - (2*shell-1)**2-2*shell*leg-shell+1
    
    if leg == 0:
        x = shell
        y = elem
    elif leg == 1:
        x = -elem
        y = shell
    elif leg == 2:
        x = -shell
        y = -elem
    else:
        x = elem
        y = -shell
    return (49+x,50-y)

inim = Image.open("wire.png")
outim = Image.new("RGB", (100,100))

for i,px in enumerate(inim.getdata()):
    outim.putpixel(getpixel(i), px)

outim.show()
another easy to understand method

The idea is simple. If the pixel ahead is (0,0,0), copy from source. Otherwise, turn right and try again. Turning is implemented by cycling the step list.

import Image

src = Image.open('wire.png')
dst = Image.new(src.mode, (100, 100))
x, y, idx = -1, 0, 0            # back a step
steps = [1,0, 0,1, -1,0, 0,-1]
while idx < 10000:
    nx, ny = x + steps[0], y + steps[1]
    if 0 <= nx < 100 and 0 <= ny < 100 \
            and dst.getpixel((nx, ny)) == (0, 0, 0):
        x, y = nx, ny
        dst.putpixel((x, y), src.getpixel((idx, 0)))
        idx += 1
    else:
        steps = steps[2:] + steps[:2] # turn
dst.show()
"Fair" variant of the above method (Leonid Shvechikov)

Don't look at ahead pixel colors.

Honestly count length of the next segment.

Then turn right.

 import Image
 
 src = Image.open('wire.png')
 dst = Image.new('RGB', (100, 100))
 vector = (1, 0), (0, 1), (-1, 0), (0, -1)
 dx, dy = vector[0]
 x, y, s, p, src_i = -1, 0, 0, 0, 0
 part = 100
 
 while part:
     part -= p # 100, 99, 99, 98, ...
     p ^= 1    # 0, 1, 0, 1, ... 
     for j in range(part):
         x, y = x + dx, y + dy
         dst.putpixel((x, y), src.getpixel((src_i, 0)))
         src_i += 1
     s = (s + 1) % 4 # turn
     dx, dy = vector[s]
 
 dst.show()
Non-solution that works

It's possible to solve this puzzle without bothering to implement the spiral output logic:

import Image
img = Image.open('wire.png')
start, end = 0, 0
out = Image.new('RGB', (400,100))
row = 0
for k in range(100, 0, -2):
    end += k + (k-1) + (k-1) + (k-2)
    chunk = img.crop((start, 0, end, 1))
    out.paste(chunk, (0, row, end-start, row+1))
    start = end
    row += 1
out.show()
The resulting image is skewed กช but not beyond recognition. The cat's face is readily apparent.


Very nice haskell solution

The following very nice code twirl the list of pixels into the cat picture. A similar thing could probably also be done in python. (I just noticed there is a solution above that uses the same idea, but doesn't use recursion!)

Getting the pixel list into haskell is another story (convert wire.png wire.txt and parse the txt file), let's just say that Python has really nice libraries!!

 import Data.List
 
 snake (x,y) [] = []
 snake (x,y) ls = take y ls : rotate (snake (y,x-1) (drop y ls))
   where rotate = transpose . reverse
So you call it by running snake (100,100) pixellist.

List with pixelpositions in spiral order

Before doing anything with the actual data, I first defined a function which gave me the pixel positions along the spiral. This way you can also test it easily using small values to check if it's doing what you expect

 def createspiral(size):
       minX,maxX = 0, size
       minY,maxY = 0, size
 
       spiral = list()
 
       while minX < maxX:
               spiral.extend([(x,minY) for x in range(minX, maxX)])            #go right
               minY = minY + 1
               spiral.extend([(maxX-1,y) for y in range(minY, maxY)])          #go down
               maxX = maxX - 1
               spiral.extend([(x,maxY-1) for x in range(maxX-1, minX-1, -1)])  #go left
               maxY = maxY - 1
               spiral.extend([(minX,y) for y in range(maxY-1, minY-1, -1)])    #go up
               minX = minX + 1
       return spiral
Pixelpositions in spiral order, recursive version

I had the same idea of collecting the spirals coordinates, but in a recursion. However, the solution is a bit slower than the previous one.

 def spiral(size, round = 0):
     coords = []
     if size > 0:
         coords.extend([(x,round) for x in range(round, round+size)])                 # top, left to right
         coords.extend([(round+size-1, y) for y in range(round+1, round+size)])       # right, top down
         coords.extend([(x,round+size-1) for x in range(round+size-2, round-1, -1)])  # bottom, right to left
         coords.extend([(round, y) for y in range(round+size-2, round, -1)])          # left, bottom up
         coords.extend(spiral(size-2, round+1))                                       # next round, recursive
     return coords
Map spiral segments to fixed array

Once I figured out the spiral sequence, I cut the source image into the sequences and placed that data into its final position. I ended up doing a putdata when I thought I had finished, and lo and behold, the first image I saw, was the cat. Lucky me!

def walk(distance, slices, position, direction):
  pixels = zeros(distance + 1)
  for slice in slices:
    (t,l,b,r) = slice
    for p in [t,l,b,r]:
      if p:
        position = moveto(pixels, p, position, direction)
      direction = turtle(direction)
  # discard trailing sentinel
  return pixels[0:distance]
data = list(Image.open('wire.png').getdata())
results = Image.new('RGB',(100,100))
results.putdata(walk(10000, chop(data, sequence(100)), (0,0), go['right']))
results.show()
Alternate solution using complex numbers

 import Image
 import math
    
 im    = Image.open('wire.png')
 blank = Image.new('RGB', (100, 100))
 pos   = (0 + 0j)
 count = 0;
    
 for r in range(99,0,-2):
     for i in range(0,4*r):
         pos = pos + (0 + 1j) ** math.floor(float(i) / float(r))
         blank.putpixel((int(pos.real), int(pos.imag)), im.getpixel((count,0)))
         count = count + 1
     pos = pos + (1 + 1j)
    
 blank.show()

The complete solution is at Level14:SpiralWalk ...

Alternative solution with recursive iterator

from PIL import Image
 
wire = Image.open("wire.png")
roll = Image.new("RGB", (100, 100))
 
# roll_in generates coordinates of a inward spiral of given size
def roll_in(size):
    # Exit condition
    if size == 0:
        pass
    elif size == 1:
        yield 0, 0
    
    else:
        for x in xrange(size-1):
            yield x, 0
        for y in xrange(1, size):
            yield size-1, y
        for x in reversed(xrange(size-1)):
            yield x, size-1
        for y in reversed(xrange(1, size-1)):
            yield 0, y
        for x, y in roll_in(size - 2):
            yield x + 1, y + 1

for i, pos in enumerate(roll_in(100)):
roll.putpixel(pos, wire.getpixel((i, 0))

roll.show()
Another recursive generator

 def walk(n):
     x, y = -1, 0
     for xd, yd, steps in (1, 0, n), (0, 1, n - 1), (-1, 0, n - 1), (0, -1, n - 2):
         for _ in range(steps):
             x, y = x + xd, y + yd
             yield x, y
     if n > 2:
         for x, y in walk(n - 2):
             yield x + 1, y + 1
PEZ: Brute solution using a generator

The hint in the italy.html source said to remember that:

100 * 100 = (100 + 99 + 99 + 98) + (...
I translated that into:

def spiral(side):
    x, y = 0, 0
    while side > 1:
        for i in range(side):
            yield x, y
            x += 1
        x -= 1
        y += 1
        side -= 1
        for i in range(side):
            yield x, y
            y += 1
        y -= 1
        x -= 1
        for i in range(side):
            yield x, y
            x -= 1
        x += 1
        y -= 1
        side -= 1
        for i in range(side):
            yield x, y
            y -= 1
        y += 1
        x += 1

wire = Image.open('wire.png')
unwired = Image.new('RGB', (100, 100))
coords = spiral(100)
for pixel in wire.getdata():
    unwired.putpixel(coords.next(), pixel)

unwired.save('unwired.png', 'PNG')
And I'm to tired to refactor it...

My methods, using generator

The first one I just write down what I was thinking when drawing it by hand, basically the idea is to monitor the remaining space while drawing.


riddlefile = 'wire.png'
import Image
im = Image.open(riddlefile)
new_im = Image.new(im.mode, (100,100))
im_data = im.getdata()

def wire2(size):
	x, y = 0, 0
	xd, yd = size, size
	v=(1,1,-1,-1)
	for k in range(size*2-1):
		d = v[k%4]
		if k % 2 == 0:
			for x in range(x, x + d * xd, d):
				yield (x,y)
			yd -= 1 #y space diminished
			y += d #move pen to empty space
		else:
			for y in range(y, y + d * yd, d):
				yield (x,y)
			xd -= 1
			x -= d

for xy, data in zip(wire2(100), iter(im_data)):
	new_im.putpixel(xy, data)
new_im.show()
and that's after I tried something messy, just another boundary condition method:

def wire(size):
	getrange = (
		lambda m:(	(size-1-m, ), 	range(1+m, size-m)	),
		lambda m:(	range(size-2-m, m-1, -1), 	(size-1-m, )	),
		lambda m:(	(m, ),	range(size-2-m, m, -1)	),
		lambda m:(	range(1+m, size-1-m), 	(1+m, )	),
		)
	for j in range(size):
		yield (j,0)
	for k in range(0, 2*size-2):
		rangex, rangey = getrange[k%4](k // 4)
		for i in rangex:
			for j in rangey:
				yield (i,j)
And I like the one using complex number, it is very insightful and cool


Darkdragon: Intuitive spiral solution (a la State Machine)

While longer, this solution is very explicit.

#!/usr/bin/python

import Image

wire=Image.open("wire.png")
wirex=wire.load()


gato=Image.new("RGB", (100,100))
gatox=gato.load()

pixels=[wirex[i,0]for i in range(0,10000)]

pixels.reverse()

STATE_UP=1
STATE_DOWN=2
STATE_RIGHT=3
STATE_LEFT=4

continu=True
current_state=STATE_RIGHT

x=0
y=0

min_x = 1 #this threw me forever. try it with 0 to see why
max_x = 99
min_y = 0
max_y = 99

while len(pixels)>0:
	gatox[x,y]=pixels.pop()
	
	if current_state   == STATE_DOWN:
		y+=1
		if y>=max_y:
			max_y-=1
			current_state=STATE_LEFT
			
	elif current_state == STATE_UP:
		y-=1
		if y<=min_y:
			min_y += 1
			current_state=STATE_RIGHT
		
	elif current_state == STATE_RIGHT:
		x+=1
		if x>=max_x:
			max_x -= 1
			current_state=STATE_DOWN
	
	elif current_state == STATE_LEFT:
		x-=1
		if x<=min_x:
			min_x += 1
			current_state=STATE_UP
	
gato.show()

Method Using an Iterator (Ian Milligan)

The idea is to create an iterator from the source image and to loop over the spiral number. For each iteration of the loop I put a line on each edge of the new image.

data = iter(image.getdata())
n = 100
answer = Image.new(image.mode, (n, n))
for i in range(n / 2):
    for j in range(n - 2 * i):
        answer.putpixel((i + j, i), data.next())
    for j in range(n - 1 - 2 * i):
        answer.putpixel((n - 1 - i, 1 + i + j), data.next())
    for j in range(n - 1 - 2 * i):
        answer.putpixel((n - 2 - i - j, n - 1 - i), data.next())
    for j in range(n - 2 - 2 * i): 
        answer.putpixel((i, 98 - i - j), data.next())
I did the same in Ruby:

require 'RMagick'

LENGTH = 100

def spiral(pos, pixels, outview)
  length = LENGTH - 2*pos
  (0...length).each { |i| outview[pos][pos+i] = pixels.next }
  (1...length).each { |i| outview[pos+i][pos+length-1] = pixels.next }
  (length-2).downto(0) { |i| outview[pos+length-1][pos+i] = pixels.next }
  (length-2).downto(1) { |i| outview[pos+i][pos] = pixels.next }
end

input = Magick::ImageList.new("wire.png")
pixels = input.get_pixels(0, 0, LENGTH**2, 1).each
output = Magick::Image.new(LENGTH, LENGTH)
output_view = output.view(0, 0, LENGTH, LENGTH)

(0..LENGTH/2).each { |pos| spiral(pos, pixels, output_view) }

output_view.sync
output.display
--Rebecca 05:04, 11 Aug 2010 (PDT)

Pixel coordinate translation with a basic arithmetical function (Solus)

w = abs(x-y)+abs(x+y-W+1)+1: the width (and height) of the spiral/square on which (x,y) lies

W*W-w*w: area of the outer spirals

(((x-y)//w*2+1)*(x+y-W+w)+4*w-4)%(4*w-4): the clockwise distance around the current spiral from the top-left to (x,y)

// does integer division (giving quotient); '%' is modulo operator (yielding remainder of division)

import Image

W = 100
imgA, imgB = Image.open("wire.png"), Image.new("RGB", (W,W))
pixA, pixB = imgA.load(), imgB.load()

def p(x,y):
    w = abs(x-y)+abs(x+y-W+1)+1
    return (((x-y)//w*2+1)*(x+y-W+w)+4*w-4)%(4*w-4) + W*W-w*w

for y in range(0,W):
    for x in range(0,W):
        pixB[x,y] = pixA[p(x,y),0]

imgB.show()
Another explicit for-loop solution

... similar to many of the above. Draws boxes of pixels from the outside towards the center. I just couldn't seem to get it to draw properly as a logically continuous spiral, but this was much simpler.

Tuple packing/unpacking makes it easy to push many of the loop variable assignments into the statements themselves. This could even be collapsed into a one-line unreadable list comprehension monster... :)

import Image
wire = Image.open('chal14_wire.png')
im = Image.new(wire.mode,(100,100))
p = iter(wire.getdata())

for l,n in (((100-2*n)-1,n) for n in range(50)):
    for bx,by,dx,dy in [(n,n,1,0),(n+l,n,0,1),(n+l,n+l,-1,0),(n,n+l,0,-1)]:
        for x,y in [(bx+i*dx,by+i*dy) for i in range(l)]:
            im.putpixel((x,y),p.next())
im.show()
The short Haskell solution and the arithmetic coordinate transformation above are quite impressive, whilst the complex number solution is pure magic

A very heavy functional solution...

import urllib
import sys
import Image


processed = {} # a hash table that contains all the processed coordinates
coords = [] # a list of coordinates where to set the pixels

# this function gives you the next coordinates given the current coordinates and the direction
def next(dir,x,y):
    if dir == 'right':
        new_x = x + 1
        new_y = y
    elif dir == 'down':
        new_x = x
        new_y = y + 1
    elif dir == 'left':
        new_x = x - 1
        new_y = y
    elif dir == 'up':
        new_x = x
        new_y = y -1
    return new_x, new_y



# checkes whether or not the coordinates you pass are valid
def checker((x,y)):
    # not to go beyond the boundaries of the square
    if x < 0: return False 
    if y < 0: return False
    if x > 99: return False # I don' t know why. It s not 100 but 99 in my case. But it works
    if y > 99: return False

    # not to re-processe the same coordinates as before
    if (x,y) in processed.keys():return False
    else: return True


# gives the next direction assuming that the previous direction does not work
# firt right, then down, then left and finally up
def Dir(x,y):
    if checker(next('right', x, y)):
        return 'right'
    if checker(next('down', x, y)):
        return 'down'
    if checker(next('left', x, y)):
        return 'left'
    if checker(next('up', x, y)):
        return 'up'
    else:
        return False # in case it s the end

# computes the next direction to take
# if the previous direction still works we keep that direction

def nextDir(x,y,pre_dir):
    if checker(next(pre_dir, x, y)): return pre_dir
    else: return Dir(x,y)

####
# Let s now construct spiral.png
    
x,y = 0,0
coords = coords + [(x,y)]
pre_dir = 'right'

while nextDir(x,y,pre_dir):
    next_dir = nextDir(x,y, pre_dir)
    processed[(x,y)] = True
    x, y = next(next_dir,x,y)
    coords = coords + [(x,y)]
    pre_dir = next_dir

strip = Image.open('wire.png')
spiral = Image.new(strip.mode, (100,100)) 

for i in range(10000):
    spiral.putpixel(coords[i], strip.getpixel((i,0)))

spiral.save("spiral.png")

--Uploada 22:45, 09 Dec 2010 (JST)

With NumPy Array

import Image
from numpy import array, zeros, uint8

line = Image.open('wire.png')
a = zeros((100, 100, 3), dtype=uint8)

step = array([0, 1])
position = array([0, 0])
count = 0

# continue until when the next spot expected to be unfilled is filled
while not max(a[tuple(position)]):
	# paint colour
	a[tuple(position)] = array(line.getpixel((count, 0)))
	
	# if reached a wall
	if max(position + step) > 99 or min(position + step) < 0 or max(a[tuple(position + step)]):
		# change direction
		step = (abs(step) ^ 1) * (-step[0] if step[0] else step[1])
	
	# advance
	position += step
	count += 1
	
# convert to image
Image.fromarray(a).save('swirl.jpeg')
Doesn't work when the diagonal+1s are pure white of course.

(un)Parameterize the spiral

Don't bend the spoon...

def spiralright(t, xlen=1, ylen=1):
	"""Return x,y for given t, x:0..xlen-1, y:0..ylen-1
		t:0..N, xlen:1..N, ylen:1..N,
		parameterization of x and y from t
		goes along x, then y => right turn square spiral
		outside path is xlen + ylen-1 + xlen-1 + ylen-2 = 2*xlen + 2*ylen - 4
	"""
	if t + 1 > (xlen * ylen): #max t
		raise ValueError("t=%s exceeds, N = xlen * ylen = %s, t:0..N-1" % (t, xlen * ylen))
	
	c4 = 2*(xlen + ylen) - 4
	c3 = 2*xlen + ylen - 2
	c2 = xlen + ylen - 1
	c1 = xlen
	# walk outside path
	if t < c1:  # first segment
		x,y = (t, 0)
	elif t < c2: #second segment
		x,y = (xlen-1, t - c1 + 1)
	elif t < c3: #third segment
		x,y = (c3 - t - 1, ylen-1)
	elif t < c4: #forth segment
		x,y = (0, c4 - t)
	else:
		# go into inner spiral
		x,y = spiralright(t-c4, xlen-2, ylen-2)
		x += 1
		y += 1
	return (x, y)

def lvl14_trial():
	import Image
	img = Image.open(PC_PATH + "/wire.png")
	imgnew = Image.new("RGB",(100,100),'black')  # A new blank image
	# how to walk a square spiral 100x100
	for t in xrange(10000):
		imgnew.putpixel(spiralright(t,100,100), img.getpixel((t,0)) )
		
	imgnew.save(PC_PATH + "/lvl14_wire_new.png")
I also like the generator solutions to yield the next x,y And the gamers directional walk never came to mind. ... Bend your mind. --Infini7y 01:17, 29 August 2011 (PDT)

what about my solution

Turing without human help.

import Image

new = Image.new('RGB',(100,100))
data = list(Image.open('wire.png').getdata())

num = 100
x = -1
y = 0
xp = 1
yp = 0
nump = 0
ip = 0
while True:
    for i in range(num):
        x=x+xp
        y=y+yp
        new.putpixel((x,y),data[i+ip])
    xp,yp = -yp,xp
    nump = -1*(nump+1)
    ip = ip + num
    num = num + nump
    if num == 0: break

new.save('new1.png')

___________________________________________________________-
The picture shows us a calender marked on January 26, but the year has been burned out. The february list in the bottom right shows us this must be a leap year.

Using the datetime module you can find all years that start with a 1 and end with a 6 that are leapyears and have January 26 fall on a Monday. The source tells us we should take the second most recent date of our list:

1756-01-26
The source of the page says this is a TODO item; buy flowers for the next day. The 27th is significant, because that's the birthdate of Mozart, and that's the key to the next level.

Contents [hide]
1 Details
2 Alternative
3 Another way to do it
4 Easiest way (IMHO)
5 An observation
6 Bash one-liner
7 Ruby
Details

The datetime module doesn't have a direct way to tell whether a year is a leap year (although there is such a function in the calendar module), so let's write a functon for that:

from datetime import *
 
def isleap(year):
    d = date(year, 3, 1)
    return (d - timedelta(days=1)).day == 29
That moves back a day from the first of March, and sees whether that moves to the 29th of February. The rest is straightforward:

for year in range(1006, 2000, 10):
    if isleap(year) and date(year, 1, 26).weekday() == 0:
        print year
That prints five possible years, and the "second youngest" clue from the page source tells which to use.

There *is* another way, though, the function

def isleap(year):
    try:
        date(year,2,29)
        return True
    except ValueError: return False
because date() does bounds check the dates.

Alternative

from calendar import weekday, isleap
print filter(lambda y: isleap(y) and 0 == weekday(y, 1, 26), range(1006, 2000, 10))[-2]
Another way to do it

 from calendar import weekday
 for n in range(0,100):
   if weekday(1006 + n * 10, 1, 26) == 0:
     print (1006 + n * 10, 1, 26)
Easiest way (IMHO)

  from calendar import weekday
  for i in range(1006, 1996, 10):
      if weekday(i, 1, 1) == 3:
          print i
An observation

Python's datetime libraries only work with the Gregorian calendar:

>>> datetime.date(1582,1,1).weekday()
4
(It was a really a Monday in the Julian calendar.) So there's no point going further than 1582. Gareth Rees 02:41, 18 May 2007 (MDT)

Bash one-liner

for a in `seq 1 2 99`; do cal jan 1${a}6 | cut -d' ' -f2 | grep -q 26 && echo $a; done
Remove a few spaces to get it under 80 characters.

Benlynn 01:09, 23 May 2010 (PDT)

Ruby

Starting after 1582, because the code doesn't work for pre-Gregorian calendar:

require 'date'

date = Date::civil(1586, 1, 26)

while date < Date::civil(2000, 1, 1)
  date = date >> 12*10
  if date.wday == 1 and date.leap?
    puts date
  end
end
--Rebecca 06:59, 11 Aug 2010 (PDT)

_________________________________________________
We get a jumbled-looking GIF and a hint to get things straight. Every line in the image has a group of 5 pink pixels, so we'll focus on straightening those: rotate each row so that its pink pixels start in its first column. This is a GIF image, and thus uses a palette; the pink pixels are color #195. Here is the solution:

>>> import Image
>>> def straighten(source):
...     target = source.copy()
...     for y in range(source.size[1]):
...         line = [source.getpixel((x, y)) for x in range(source.size[0])]
...         pink = line.index(195)
...         line = line[pink:] + line[:pink]
...         for x, pixel in enumerate(line):
...             target.putpixel((x, y), pixel)
...     return target
>>> out = straighten(Image.open("mozart.gif"))
>>> out.save("out.gif")
The image then clearly shows the word 'romance', the key to the next level.

Contents [hide]
1 For Speed Freaks
2 Similar to above, but I think a bit more simple
3 A bit simpler, hopefully a bit clearer
4 Weird solution that works but is wrong
5 An other solving method
6 Solving from unix shell
7 Another solution with regular expressions
8 A ruby solution with RMagick
9 A perl solution with GD library
10 Simple python
For Speed Freaks

Slinging one pixel at a time is easy but slow. PIL has other, at first less-obvious methods, that can speed this enormously:

import Image
im = Image.open("mozart.gif")
magic = chr(195)
for y in range(im.size[1]):
    box = 0, y, im.size[0], y+1 # box bounding row y
    row = im.crop(box)
    bytes = row.tostring()
    # Rotate 195 to the first column.
    i = bytes.index(magic)
    bytes = bytes[i:] + bytes[:i]
    row.fromstring(bytes)
    im.paste(row, box)  # overwrite the original row
im.save("out.gif")  # or just "im.show()"
Instead of

    bytes = bytes[i:] + bytes[:i]
    row.fromstring(bytes)
PIL's ImageChops can be used instead:

import ImageChops  # add this
...
    row = ImageChops.offset(row, -i)
Another solution that combines a little bit of everything

import Image, urllib, StringIO
img = urllib.urlopen('http://huge:file@www.pythonchallenge.com/pc/'
                     'return/mozart.gif').read()
im = Image.open(StringIO.StringIO(img))  # Image.open requires a file-like object
imX, imY = im.size
data = list(im.getdata())
newIm = Image.new("RGB", (imX, imY))
finalData = []
for y in range(imY):
    myData = data[imX*y:(imX*(y+1))]
    pos = myData.index(195)
    finalData.extend(myData[pos:])
    finalData.extend(myData[:pos])
newIm.putdata(finalData)
newIm.show()
Similar to above, but I think a bit more simple

This will edit the data "inline". Maybe not faster than above, but it avoids the message math of adding and multiplying y values by width. It also cleans up the ugly pink values.

 import Image,urllib,StringIO
 img = urllib.urlopen('http://huge:file@www.pythonchallenge.com/pc/'
                      'return/mozart.gif').read()
 im = Image.open(StringIO.StringIO(img))
 data = list(im.getdata())
 width,height = im.size
 for off in range(0, len(data), width):
     line = data[off:off+width]
     idx = line.index(195)
     data[off:off+width] = line[idx+5:] + line[:idx] + [0,0,0,0,0]

 im.putdata(data)
 im.save("output.gif")
DanielPitts

A bit simpler, hopefully a bit clearer

First I must say that I feel that it took me too long to understand what to do, my native language is not English but I think it would have been much easier if instead of focusing on "straight" someone had hinted the word "align". This challenge is solved by vertically aligning the pink segments of the source image, not by "straightening" them: you straighten something that is "curved" or "twisted", not something that is "broken" (the segments are not connected vertically). Then again, this is a CHALLENGE (not only in programming) and maybe it's only my limited command of English that is to blame for having me working on this for days, damn... anyway, my final program is almost identical to Daniel Pitts', it modifies the image inline by converting its data to a list with getdata() (as recommended by the PIL manual for speedy massive changes) but it's "more inline" since I use the additional parameter of the index function to start the search of the pink segment in the current row, no need to slice and store values in a temporary "line" variable:

from PIL import Image

im = Image.open("mozart.gif")
cols, rows = im.size
PINK = 195

I = list(im.getdata())
for r in range(0, rows*cols, cols):
    x = I.index(PINK, r)
    I[r:r+cols] = I[x:r+cols] + I[r:x]

im.putdata(I)
im.save("mozart-out.gif")
Weird solution that works but is wrong

I wasn't sure what was going on so I tried just running through the image and creating a new row every time I got to a group of pink pixels. It worked but I had to make a large image. The effect was pretty cool when it was finished.

import Image
im = Image.open('mozart.gif')
im.show()
im2 = Image.new('P', (1248, 480))
y = -1
x = 0
for y1 in range(480):
    for x1 in range(640):
        p = im.getpixel((x1, y1))
        if 237 <= p <= 252:  # is one of the white pixels
            if im.getpixel((x1 + 1, y1)) == 195: # the next pixel is pink
                y += 1
                x = 0
        if y >= 0:  # skip stuff before first pink thing
            im2.putpixel((x, y), p)
            x += 1
An other solving method

import Image
im=Image.open("Mozart.gif")
img=Image.new('P',(640,480))
img.putpalette(im.palette.palette)
d=list(im.getdata())
e=[]
for y in range(480):
    t=d[640*y:640*(y+1)].index(195)
    e+=d[640*y+t:(y+1)*640]+d[640*y:640*y+t]
img.putdata(e)
img.show()
--Scholi 07:20, 17 Apr 2006 (MDT)

Solving from unix shell

PerlLover: As usual, I solved it without image modules. :) result.xpm contains "romance" graffiti after these commands:

convert -colors 92 mozart.gif result.xpm
perl -i -pe 's/"(.*)(I{5})(.*)"/"$2$3$1",/' result.xpm
Gelbs: I had never seen xpm files before. It was fun to try this and open the (first) result.xpm file in a text editor just to see the ASCII art rendering of the 16 :) But convert -color 92 chose 'L' not 'I' to be the relevant color for me, but regular expressions are incredible... well done!

Luzandro: awesome.. it's even easily readable - vote for best solution ;)

Anicka: I know even a little more convenient tool for shell hackers, pbmtools. I have converted the image via giftopnm into the text file readable even better than xpm. The rest was just a little work for vim a pnmtogif.

benlynn: I'm also more comfortable with the Netpbm tools, though it's similar to convert:

( printf "P6\n640 480\n255\n"
giftopnm mozart.gif | xxd -s15 -p | tr -d '\n' | \
sed -r 's/.{'$((640*3*2))'}/&\n/g' | sed -r 's/^(.*)((ff00ff){5}.*)$/\2\1/' | xxd -r -p ) | pnmtopng > tmp.png
Another solution with regular expressions

import Image, re
img = Image.open("mozart.gif")
imgtext = img.tostring().replace('\n','0')
imgtext = '\n'.join([imgtext[i*640:(i+1)*640] for i in range(480)])
imgtext = re.compile('^(.*?)(\xc3{5})(.*?)$',re.M).sub(r'\2\3\1', imgtext).replace('\n',"")
img.fromstring(imgtext)
img.save("mozartnew.gif")
A ruby solution with RMagick

#!/usr/bin/ruby
require 'RMagick'
include Magick
moz = ImageList.new("./mozart.gif")
line = moz.export_pixels(0, 0, 640, 1, "RGB") 
line.push line.shift until line[3, 3]*4 == line[6, 12]  
key = line[3, 15]
for y in 0..(moz.rows)
  line = moz.export_pixels(0, y, 640, 1, "RGB")
  line.push line.shift  until line[3, 15] == key
  moz.import_pixels(0, y, 640, 1, "RGB", line)
end
moz.write("./mozart.gif")
And another one:


require 'RMagick'

MARKER = Magick::Pixel.new(red=65535, green=0, blue=65535, opacity=0)

input = Magick::ImageList.new("mozart.gif")
width, height = input.columns, input.rows
output = Magick::Image.new(width, height)

(0...height).each do |i|
  row = input.get_pixels(0, i, width, 1)
  offset = row.index(MARKER)
  output.store_pixels(0, i, width, 1, row[offset..-1] + row[0...offset])
end

output.display
--Rebecca 07:00, 11 Aug 2010 (PDT)

A perl solution with GD library

use GD;
my $src  = GD::Image->new("mozart.gif");
my $dest = $src->clone();
my $w    = $src->width();
my $pink = $src->colorClosest(255, 0, 255);
for my $y (0 .. $src->height()-1) {
    my ($shift) = grep {$src->getPixel($_, $y) == $pink} 0 .. $w-1;
    $dest->copy($src, 0,         $y, $shift, $y, $w-$shift, 1);
    $dest->copy($src, $w-$shift, $y, 0,      $y, $shift,    1);
}
print $dest->gif();
Kyz 03:14, 19 Apr 2010 (PDT)

Simple python

Basically just uses the pixels in between the pinks for each line in the new image.

from PIL import Image

mozart = Image.open("mozart.gif")
mozartpix = mozart.load()
new = Image.new("RGB", [1250, 480])
newpix = new.load()
b = 0
line = []

for y in range(0, 479):
    for x in range(0, 639):
        if mozartpix[x, y] != 195:
            line.append(mozartpix[x, y])
        elif len(line) != 0:
            for a in range(0, len(line)):
                newpix[a, b] = line.pop(0)
            b += 1

new.show()


_______________________________________________
Pythonic step by step (limited intervention)

#http://www.pythonchallenge.com/pc/return/romance.html
import urllib2
from urllib import quote_plus, unquote_plus
import cookielib
import re
print "Staring to follow the busynothing chain, but also picking up the crumbs!"
cj = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj),urllib2.HTTPHandler())
def getPage(nothing="12345"):
	url = "http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing="
	req = urllib2.Request(url+nothing)
	response = opener.open(req)
	return response.read()
pat = re.compile(r"(.*?)and the next busynothing is (\d*)$")
num = 12345
cookievals = []
count = 0
while True:
	count += 1
	m = pat.match(getPage(str(num)))
	for cookie in cj:
			cookievals.append(unquote_plus(cookie.value))
	if m == None:
		break
	elif count > 400:
		print "400 times is more than enough"
		break
	else:
		print str(count) + ": " + m.group(0)
		num = int(m.group(2))
print "Done retrieving cookies"
print
print "Decompressing the message"
import bz2
message = bz2.decompress("".join(cookievals))
print "The message is: %s" % message
print
print "Mozart was born to Leopold..."
print "Looking up Leopold"
##Call his father Leopold
import xmlrpclib
x= xmlrpclib.ServerProxy("http://www.pythonchallenge.com/pc/phonebook.php")
number = x.phone("Leopold")
print "Leopold's number is: %s" % number 
print
print "Calling Leopold and sending him the mssage"
o = urllib2.build_opener()
message = "the flowers are on their way"
o.addheaders.append(('Cookie', 'info='+quote_plus(message)))
res = o.open("http://www.pythonchallenge.com/pc/stuff/violin.php")
print "Message sent!"
print
print"His response is..."
print res.read()
More Python

The page contains an image of cookies, with an inset of the level 4 challenge image of two sawing men.

The Set-Cookie header on linkedlist.php (level 4) gives a hint: repeat that level with the parameter 'busynothing'. Every result includes a Set-Cookie header; use the info cookie value (decode it according to URL quoting rules, with unquote_plus):

   >>> def linkedcookielist(seed='12345'):
   ...     result = ""
   ...     url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php' \
   ...             '?busynothing='
   ...     nextnothing = re.compile('the next busynothing is (\d+)')
   ...     cookievalue = re.compile('info=([^;]+);').search
   ...     while True:
   ...         resp = urllib.urlopen(url + seed)
   ...         next = resp.read()
   ...         cookie = resp.info().getheader('Set-Cookie')
   ...         if cookie and cookievalue(cookie):
   ...             result += urllib.unquote_plus(
   ...                 cookievalue(cookie).group(1))
   ...         try:
   ...             seed = nextnothing.search(next).group(1)
   ...         except:
   ...             return result
It is a bz2-compressed value. Run it through bz2.decompress() to get the message:

   is it the 26th already? call his father and inform him that "the flowers
   are on their way". he'll understand.
Mozart's father is Leopold, and his number according to the XML-RPC phonebook is '555-VIOLIN'. violin.html tells you to go to ../stuff/violin.php. There we find Leopold asking you what you want. Now inform him that "the flowers are on their way."

You can do so by sending him a cookie with the message:

   >>> import urllib,urllib2
   >>> message = "the flowers are on their way"
   >>> url = 'http://www.pythonchallenge.com/pc/stuff/violin.php'
   >>> req = urllib2.Request(url,
   ...     headers={'Cookie': 'info=' + urllib.quote_plus(message)})
   >>> print urllib2.urlopen(req).read()
You'll get the same page again but this time he's also admonishing you to not forget the balloons. 'balloons.html' is the next level; stuff/balloons.html redirects to the password-protected return/ directory again.

Using cookielib
Another way of reading the cookies is by using the cookielib module.

   import cookielib
   cj = cookielib.CookieJar()
   opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
Cookies are retrieved when visiting a site like this:

   request = urllib2.Request('http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=12345')
   response = opener.open(request)
   cookies = cj.make_cookies(response, request) # extract all cookies that this request-response pair added to the jar
The page's text is response.read(), the Cookie instance from the jar is cookies[0], and the data from that cookie is cookies[0].value

Sending cookies with cookielib can be a pain. The easiest way (aside from generating a Cookie: header directly) is to edit a cookie the server gave you and give it back:

   cookie = cookies[0] # from the previous code clock
   cookie.value = 'the flowers are on their way'
   request = urllib2.Request('http://www.pythonchallenge.com/pc/stuff/violin.php')
   cj.set_cookie(cookie) # overwrite the current info='whatever' cookie in the jar with the "flowers" cookie
   cj.add_cookie_header(request) # add the Cookie: header to request
   print urllib2.urlopen(request).read()
Create Cookie in Python

Actually creating a simple cookie in Python is not difficult but annoyingly not well documented

One has to set a policy so that the CookieJar can know which cookie(s) it should send for a particular request. Also, one has to create a Cookie using the basically undocumented cookielib.Cookie. This [[1]] gave some help understanding what to do.

   import urllib, urllib2, cookielib, time
   cj = cookielib.CookieJar(cookielib.DefaultCookiePolicy())
   opener = urllib2.buld_opener(urllib2.HTTPCookieProcessor(cj))
   request = urllib2.Request('http://www.pythonchallenge.com/pc/stuff/violin.php')
   #Create the cookie (cf. 
   ck = cookielib.Cookie(
       version=0, #Can use version 1 if rfc2965=True is parameter of DefaultCookiePolicy
       name="info", value=urllib.quote_plus("the flowers are on their way"),
       port="80", port_specified=False,
       domain=".pythonchallenge.com", domain_specified=False, domain_initial_dot=True,
       path="/", path_specified=False,
       secure=False, expires=time.time()+86400, discard=False,
       comment=None, comment_url=None, rest={}, rfc2109=False)
   cj.set_cookie(ck)
   cj.add_cookie_header(request)
   response = opener.open(request)
   data = response.read()
   response.close()
   print data
Javascript injection

To talk to leopold you need to use cookies. But I wasn't sure how to set the cookie with python, so I used some javascript injection. Just type:

   javascript:void(document.cookie="info=the+flowers+are+on+their+way")
in your browser's address bar, press enter and reload the page. Don't forget the balloons!

Using cookielib

Another way of reading the cookies is by using the cookielib module.

   import cookielib
   cj = cookielib.CookieJar()
   opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
Cookies are retrieved when visiting a site like this:

   request = urllib2.Request('http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=12345')
   response = opener.open(request)
   cookies = cj.make_cookies(response, request) # extract all cookies that this request-response pair added to the jar
The page's text is response.read(), the Cookie instance from the jar is cookies[0], and the data from that cookie is cookies[0].value

Sending cookies with cookielib can be a pain. The easiest way (aside from generating a Cookie: header directly) is to edit a cookie the server gave you and give it back:

   cookie = cookies[0] # from the previous code clock
   cookie.value = 'the flowers are on their way'
   request = urllib2.Request('http://www.pythonchallenge.com/pc/stuff/violin.php')
   cj.set_cookie(cookie) # overwrite the current info='whatever' cookie in the jar with the "flowers" cookie
   cj.add_cookie_header(request) # add the Cookie: header to request
   print urllib2.urlopen(request).read()
PERL SOLUTION!!!

I was determined to show that this puzzle, like the rest, can be solved without python (mainly because I like being over-complex :D)... In the end I used perl and php to do so. This took me a while and is fairly messy, and is clearly not the best way to capture cookies, but I wrote it quickly and IT IS NOT PYTHON :D It requires just the basic perl and php installations and no extra modules or anything. It also requires curl and bzcat (from bzip2)...

#!/usr/bin/perl -w
# Written by Tek 2008 :D
use MIME::Base64;
$i = 0;
$nothing = (defined($ARGV[0]) ? $ARGV[0] : 12345);
$cookiestr = "";
print "Starting with busynothing: ${nothing}\n";
while($i < 400)
{
   $_ = `curl -si http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=${nothing}`;
   $pattern = "and the next busynothing is ";
   chomp;
   @parts = split(/\r\n\r\n/, $_);
   $headers = $parts[0];
   @headerlines = split(/\r\n/, $headers);
   foreach(@headerlines)
   {
      if ($_ =~ m/Set-Cookie/)
      {
         $_ =~ m/Set-Cookie: info=(.*)\;/;
         $out = $1;
         $out =~ s/\;.*//;
         $cookiestr = $cookiestr . $out;
         #print "Adding ${out} to cookiestr!\n";
      }
   }
   $_ = $parts[1];
   $_ =~ s/$pattern//o;
   if (length($_) != 5)
   {
      print "Failing at: ${i}";
      print "\n";
      print $_;
      print "\n";
      if (/br/)
      {
         $nothing = substr($_, -5);
         print "First string fixed!\n";
      } elsif (/\D/)  {
         print "Failed after ${nothing}\n";
         print "Cookiestr: ${cookiestr}\n";
         open(OUTPUT, ">cookiestr.txt");
         print OUTPUT $cookiestr;
         close(OUTPUT);
         print "Cookiestr saved to file cookiestr.txt!\n";
         $base64 = "PD9waHAKJGlucHV0ID0gZmlsZV9nZXRfY29udGVudHMoImNvb2tpZXN0ci50eHQiKTsKZmlsZV9wdXRfY29udGVudHMoImNvb2tpZXN0cnVybGRlY29kZWQudHh0IiwgdXJsZGVjb2RlKCRpbnB1dCkpOwokb3V0cHV0ID0gYGJ6Y2F0IGNvb2tpZXN0cnVybGRlY29kZWQudHh0YDsKcHJpbnQgJG91dHB1dCAuICJcbiI7Cj8+Cg==";
         $phpfile = decode_base64($base64);
         open(PHPFILE, ">decoder.php");
         print PHPFILE $phpfile;
         close(PHPFILE);
         $output = `php decoder.php`;
         print $output;
         die;
      } else {
         $nothing = $_;
         print "Resolved ${_} into ${nothing}\n";
      }
   } else {
      $nothing = $_;
      $i++;
      print "Iteration: ${i}, Nothing: ${nothing}\n";
   }
}
Those of you worried about running a base64 encoded php script, the code for the php script is:

<?php
$input = file_get_contents("cookiestr.txt");
file_put_contents("cookiestrurldecoded.txt", urldecode($input));
$output = `bzcat cookiestrurldecoded.txt`;
print $output . "\n";
?>
And you can check that by simple decoding the base64 string (there are several online base64 decoders). I used base64 as it was the easiest way of embedding a php script in a perl script... I needed to use PHP as perl's uri_unescape function didn't seem to work properly at decoding the string... Also, perl's Compress::Bzip2 and URI::Escape modules aren't core I think... And now on to the rest of the challenges to solve them in perl :D

--Tek 14:16, 6 Mar 2008 (PST)

Ruby Solution

   #!/usr/bin/ruby
   require 'cgi'
   require 'open-uri'
   require 'bz2'
   
   crumbs = 
   nothing = 12345
   url = "http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing="
   while nothing > 0
       phpCall = open(url + nothing.to_s)
       busyNothing = phpCall.read
       crumbs += phpCall.meta['set-cookie'].split(';')[0].split('=')[1]
       nothing = busyNothing.split("busynothing is ")[1].to_i
   end
   message = BZ2.bunzip2(CGI.unescape(crumbs))
   puts message
Then look up his father:

   #!/usr/bin/ruby
   require 'xmlrpc/client'
   server = XMLRPC::Client.new2("http://www.pythonchallenge.com/pc/phonebook.php")
   puts server.call("phone", "Leopold")
Then give Leopold the message:

   #! /usr/bin/ruby
   require 'cgi'
   require 'open-uri'
   
   message='the flowers are on their way'
   url='http://www.pythonchallenge.com/pc/stuff/violin.php'
   puts open(url, "Cookie" => "info=" + CGI.escape(message)).read()
This returns all the html to stdout, but you can still easily read the response,

   oh well, don't you dare to forget the balloons.
Another perl solution

use LWP::UserAgent;

my $ua  = LWP::UserAgent->new();
my $out = '';
my $x   = 12345;

do {
    my $url = "http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=$x";
    my $res = $ua->request(HTTP::Request->new(GET => $url));
    $out .= $1 if $res->header('set-cookie') =~ /info=([^;]+);/;
    $_ = $res->content();
    printf "info=%-3s %s\n", $1, $_;
} while (($x) = /next busynothing is (\d+)/);

# GRR! Who decided to put "+"s in an otherwise valid URI-encoded string?
$out =~ s/\+/ /g;
$out =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;

open(FH, "|bzcat") && print(FH $out) && close FH;
What's his father's phone number?

perl -MRPC::XML::Client -le 'print RPC::XML::Client->new("http://www.pythonchallenge.com/pc/phonebook.php")->simple_request("phone","Leopold")'
Let's inform him.

wget -O- --header "Cookie: info=the+flowers+are+on+their+way" http://www.pythonchallenge.com/pc/stuff/violin.php
Kyz 03:38, 19 Apr 2010 (PDT)

_______________________________________---
A double picture of a few swans, the right half slightly darker than the left. We are asked if we can tell the difference, the source code hint says it is more obvious than what you might think.

The technical term for the difference is brightness, and brightness.html indeed does exist. In the source we find a reference to deltas.gz, which we can load, and decompress to find one big textfile with two columns of each 18 hex values in a row, 2291 rows long.

Both data sets start with a PNG header, but neither can be saved due to image decoding errors. Clearly some scrambling has taken place.

We split up the data into two datasets by splitting the lines in half, put all left column lines in list, and all the right halves in list b, stripping off extra whitespace. Discard empty lines.

Next we need to split these lines into three piles; one original image, and two that have been spliced into the two copies of that original image:

>>> def splitdiff(a, b):
...     seq = difflib.SequenceMatcher(None, a, b)
...     result1 = result2 = result3 = ""
...     for tag, i1, i2, j1, j2 in seq.get_opcodes():
...         if tag == 'equal':
...             result1 += "".join(a[i1:i2])
...         if tag == 'delete':
...             result2 += "".join(a[i1:i2])
...         if tag == 'insert':
...             result3 += "".join(b[j1:j2])
...         if tag == 'replace':
...             result2 += "".join(a[i1:i2])
...             result3 += "".join(b[j1:j2])
...     return result1, result2, result3
The three sets then mereley have to be converted to data (interpret the digits as hex values) and written out to image files. They form the next level URL and a username and password.

Contents [hide]
1 difflib.ndiff
2 Brute force unscrambling
3 Using list comprehensions
4 Using the GNU diff tool
5 Python One-liner
6 Using difflib.Differ and binascii.unhexlify
7 Using difflib.SequenceMatcher().get_matching_blocks()
8 From the command line
difflib.ndiff

Here's a second solution (complete):

>>> import urllib, gzip, Image, difflib, time
>>> from cStringIO import StringIO
>>> url = 'http://huge:file@www.pythonchallenge.com/pc/return/deltas.gz'
>>> data = urllib.urlopen(url).read()
>>> l1 = []
>>> l2 = []
>>> for line in gzip.GzipFile(fileobj=StringIO(data)):
...     l1.append(line[:53])
...     l2.append(line[56:-1])
...
>>> result = list(difflib.ndiff(l1, l2))
>>> 
>>> def solve(condition):
>>>     s = [chr(int(group, 16))
...          for line in result if line.startswith(condition)
...          for group in line[len(condition):].split()]
...     Image.open(StringIO("".join(s))).show()
... 
>>> for condition in " +-":
...     solve(condition)
...     time.sleep(1)  # give time to view
--deo 20:14, 21 May 2005 (MDT)

Brute force unscrambling

This took me a few days to do. After staring at delta.txt (alot of staring) i found patterns.

I tried to match the left side's lines to the right side's lines. Studying the matches that were closest to the original line, an easy to follow pattern emerges. Note the resulting 'twins' list, it shows the pattern clearly.

Here's my solution:

txt_filename = 'delta.txt'
f = open(txt_filename)
text = f.readlines()
f.close()


def StrHex2Chr(str_to_conv):
	if(str_to_conv.isalnum()):
		return(chr(int(str_to_conv,16)))
	else:
		return("")


def TextTo2ListsOfRows(text):
	a,b = [], []
	for row in text:
		temp_row_a = ""
		temp_row_b = ""
		for index in range(0,52,3):
			temp_row_a += StrHex2Chr(row[index:index+2])
			temp_row_b += StrHex2Chr(row[index+56:index+58])
		
		a.append(temp_row_a)
		b.append(temp_row_b)
	return a,b

text_a, text_b = TextTo2ListsOfRows(text)

def find_twins(a,b):
	new_c = []
	
	for i in range(len(a)):
		j = 0
		smallest_gap = 999999
		
		try:
			while True:
				j = b.index(a[i], j)
				if ( abs(j-i) < abs(smallest_gap) ):
					smallest_gap = j - i
				j += 1
			
			# this runs if we found a twin
			
		except Exception, e:
			# this runs once there are no more twins
			new_c.append(smallest_gap)
	return(new_c)
	

twins = find_twins(text_a, text_b)

diffs = []
sames = []
last = 0
for i,x in enumerate(twins):
	if x == 999999:
		diffs.append(text_a[i])
	else:
		if (abs(last-x) <= 1):
			sames.append(text_a[i])
			last = x
		else:
			diffs.append(text_a[i])
			print i

f = open('diffs.png','wb')
f.write("".join(diffs))
f.close()
f = open('sames.png','wb')
f.write("".join(sames))
f.close()


twins = find_twins(text_b, text_a)
diffs = []
last = 0
for i,x in enumerate(twins):
	if (abs(last-x) <= 1):
		last = x
	else:
		diffs.append(text_b[i])

f = open('diffs2.png','wb')
f.write("".join(diffs))
f.close()

--ka 14:14, 5 Feb 2007 (MDT)

Using list comprehensions

import gzip, difflib
pairs = [(l[:53], l[56:]) for l in gzip.open('deltas.gz').read().split('\n')]
columns = [[p[i] for p in pairs] for i in range(2)]
diffs = difflib.Differ().compare(columns[0], columns[1])
def unhex(s): return "".join([c:chr(int(c,16)) for c in re.findall("[0-9a-z]{2}", s)])
pngs = [unhex("".join(filter(lambda l: l[0] == d, diffs))) for d in " -+"]
for i in range(len(pngs)): open('delta%d.png' % i, 'wb').write(pngs[i])
Gareth Rees 02:26, 18 May 2007 (MDT)

Using the GNU diff tool

I split the deltas-file into two parts using the rectangular editing tools of Emacs. On the two resulting files, I invoked diff:

diff deltas1 deltas2 --old-line-format="" --new-line-format="%L"  --unchanged-line-format="" > out1
diff deltas1 deltas2 --old-line-format="%L" --new-line-format=""  --unchanged-line-format="" > out2
diff deltas1 deltas2 --old-line-format="" --new-line-format=""  --unchanged-line-format="%L" > out3
Then I converted the three files into binary format with a few lines of Python code. The image with the url was broken (maybe just a programming error on my side), but my browser displayed it nonetheless.

--Rebecca 03:46, 13 Oct 2007 (PDT)

Python One-liner

Actually two lines

import difflib

for filename,filedata in zip(('left','right','common'),("".join([chr(int(b,16)) for b in " ".join(lst).split()]) for lst in ([ln.strip('+- ') for ln in list(difflib.Differ().compare(*zip(*[(ln[:53],ln[56:].strip()) for ln in open('delta.txt').readlines()]))) if ln.startswith(ch)] for ch in ('+','-',' ')))): open(filename+'.png','wb').write(filedata)
--Cloverprince2 04:41, 7 Jul 2008 (PDT)


Using difflib.Differ and binascii.unhexlify

With delta.txt the ungzipped file:

#!/usr/bin/env python
#-*- coding: utf8 -*-
from difflib import Differ
from binascii import unhexlify

data1, data2 = [], []
sep = "   "

f = open("delta.txt", "rb")
for line in f:
    sep_pos = line.rfind(sep)
    data1.append(line[:sep_pos] + "\n")
    data2.append(line[sep_pos + len(sep):])    
f.close()

d = Differ()
result = list(d.compare(data1, data2))

f = open("delta.png", "wb")
f1 = open("delta1.png", "wb")
f2 = open("delta2.png", "wb")
for line in result:
    if line[0] == "+":
        f1.write(unhexlify(line.strip("\n+").replace(" ", "")))
    elif line[0] == "-":
        f2.write(unhexlify(line.strip("\n-").replace(" ", "")))
    else:
        f.write(unhexlify(line.strip().replace(" ", "")))
f.close()
f1.close()
f2.close()
ohan 00:19, 26 Feb 2009 (PST)

Using difflib.SequenceMatcher().get_matching_blocks()

import gzip
import difflib
import Image
from cachedurllib import cachedurlopen

dt = gzip.open(cachedurlopen('18-balloons-deltas.gz', 'http://huge:file@www.pythonchallenge.com/pc/return/deltas.gz').name)

d  = [[], [], []]
for l in dt:
     for k, v in zip((0, 1), l.split('   ', 1)):
         d[k].append(''.join([chr(int(c, 16)) for c in v.strip().split()]))

print '\n'.join(['%d: %r..%r' % (len(s), s[:1], s[-1:]) for s in d if s])

m = 0
for i, j, n in difflib.SequenceMatcher(None, d[0], d[1]).get_matching_blocks():
    if n:
        i -= m; j -= m; m += n
        d[2].extend(d[0][i:i+n])
        d[0][i:i+n] = []
        d[1][j:j+n] = []

print '\n'.join(['%d: %r..%r' % (len(s), s[:1], s[-1:]) for s in d])

d = [''.join(s) for s in d]

for k in range(len(d)):
    f = '18-balloons-%d.png' % k
    file(f, 'wb').write(d[k])
    # Image.open(f).show()
--iki 3:40, 13 Aug 2009 (CEST)

From the command line

wget http://huge:file@www.pythonchallenge.com/pc/return/deltas.gz
gunzip < deltas.gz | sed 's/  .*$//' | grep -v '^$' >left.txt
gunzip < deltas.gz | sed 's/^.*  //' >right.txt
diff -U 2000 left.txt right.txt | egrep -v '^(---|\+\+\+|@@)' >diff.txt
grep '^ ' diff.txt | perl -ne 'print chr(hex $1) while /([0-9a-f]{2})/g' >same.png
grep '^-' diff.txt | perl -ne 'print chr(hex $1) while /([0-9a-f]{2})/g' >left.png
grep '^+' diff.txt | perl -ne 'print chr(hex $1) while /([0-9a-f]{2})/g' >right.png
Kyz 04:51, 19 Apr 2010 (PDT)
_______________________________________________
In the source of this page we find an email. After loading and stripping it down to just the message (make sure the first characters are 'From') we can load the attachment from it:

>>> leopold_email = email.message_from_string(message)
>>> leopold_email.get_payload(0).get_payload(decode=True)
It's a .wav file, which gives some slight noise, then a voice saying 'Sorry!'. However, 'sorry.html' only asks us what we are apologizing for.. Leopold does ask us to tell him what is inside because his "computer is out of order". So let's fix the order then:

>>> def reversesound(source):
...     reverse = wave.open('reversed.wav', 'wb')
...     reverse.setparams(source.getparams())
...     for i in range(source.getnframes()):
...         reverse.writeframes(source.readframes(1)[::-1])
...     reverse.close()
When played, reverse.wav lets you know what the apology was for! You are called an idiot and laughed at, my my. 'idiot' is the key to a new page, idiot.html, where Leopold asks you to apologize, and a link to level 20.

And there's a much faster, but more memory-intensive, way to do it, without loops:

>>> import array
>>> frames = array.array("H", source.readframes(source.getnframes()))
>>> frames.byteswap()
>>> reversed.writeframes(frames.tostring())
Contents [hide]
1 A politically correct solution? :-)
2 Surprise
3 Let me add this one too, please! :)
4 My method is wrong, but I got there too
5 Low level swap without library
6 WAV Specification anybody?
7 From the command line
A politically correct solution? :-)

The previous solutions are perfectly valid, but I guess the tips suggest you follow a different path:

the map shows us India, and the audio filename is 'indian.wav'
wave sound files are usually encoded using big or little 'endian' byte orders
indian.wav initially seems to be encoded in little-endian
Leopold said: 'It is so much easier for you, youngsters.' and 'Maybe my computer is out of order.'
Obviously, we try the other way, the big one... ;-)
>>> url = 'http://butter:fly@www.pythonchallenge.com/pc/hex/bin.html'
>>> src = urllib.urlopen(url).read()
>>> c = re.compile("<!--\n(.*)\n-->", re.DOTALL)
>>> data = c.findall(src)[0]
>>> 
>>> message = email.message_from_string(data)
>>> audio = message.get_payload(0).get_payload(decode=True)
>>>
>>> wav = wave.open(StringIO.StringIO(audio))
>>> wav.getsampwidth() # 2 bytes, 16bits
2
>>> format = ossaudiodev.AFMT_S16_BE # Big Endian
>>>
>>> # The trick is to use two separated channels
>>> channels = 2
>>>
>>> dsp = ossaudiodev.open('w')
>>> dsp.setparameters(format, channels, wav.getframerate())
>>> dsp.write(audio)
--deo 19:57, 21 May 2005 (MDT)-->

UncleTimmy: Well, the difference between little- and big-endian for 2-byte samples is the order of the bytes, and all the solutions address that directly. It's good to see an ossaudiodev solution, but note that ossaudiodev isn't available on all platforms (while the wave module is).

Luigiwalser: You don't need the ossaudiodev module to change the endianness of the sound, the wave module itself lets you do that. This solution should work no matter how many bytes there are per sample, and is just as simple as the reversing solution:

>>> w=wave.open('indian.wav')
>>> w2=wave.open('endian.wav','w')
>>> w2.setnchannels(w.getnchannels())
>>> w2.setsampwidth(w.getsampwidth())
>>> w2.setframerate(w.getframerate())
>>> frm=w.readframes(w.getnframes())
>>> wave.big_endian=1
>>> w2.writeframes(frm)
>>> w.close()
>>> w2.close()
--Luigiwalser 16:30, 4 Aug 2005 (EST)-->

Surprise

Remember "dealing evil"? Back on level 12, you "dealt" the bytes of evil2.gfx into 5 graphics files. You can also deal the bytes of indian.wav into two .wav files:

import wave
f = wave.open("indian.wav", "rb")
guts = f.readframes(f.getnframes())
f.close()
for i in 0, 1:
    out = wave.open("i%d.wav" % i, "wb")
    out.setparams((1, 2, 11025//2, 55788//2, 'NONE', 'not compressed'))
    out.writeframes(guts[i::2])
    out.close()
After this, i0.wav is a lower-quality rendering of the "the idiot song", while i1.wav sounds a lot like the original. This "solution" probably wasn't intended, but it's the one I found first. There's so much redundancy in media files it's hard to prevent unintended solutions.

Let me add this one too, please! :)

Although not as elegant as the previous posted solutions, I'd like to share mine. The file "indians.wav" is, obviously, the encoded file in the email of this challenge.

import struct

wav = wave.open('indians.wav','rb')
owav = wave.open('indians2.wav','wb')
owav.setparams(wav.getparams())

org = wav.readframes(-1)
dest = struct.unpack('>' + str(wav.getnframes()) + 'h', org)
sdest = "".join([struct.pack('<h', x) for x in dest])
owav.writeframes(sdest)
owav.close()
--CarmineM 01:58, 11 Jun 2005 (MDT)

My method is wrong, but I got there too

I hadn't understood the phrase 'out of order'. I hadn't noticed the map is in reverse colors. But somebody in the forum mentioned to change the property of the wave header. So I set nchannels to 2, sampwidth to 1, and copied all the frames. I chose the wrong way but arrived at destination.

new_wav.setparams(2, 1, wav.getframerate(), wav.getnframes(), 'NONE', 'not compressed')
new_wav.writeframesraw(wav.readframes(wav.getnframes())
Luckily my left ear did not refuse to listen to the opposite channel.

There are actually two sequences of signals in the file. If you change the byte order, you change which signal is dominant. But if you split it, you hear both.


Alternately, while keeping the original number of channels to 1, you can change the sampling width from 2 to 1 and double the frame rate:

new_wav.setparams(1, 1, wav.getframerate()*2, 0,'NONE', 'not compressed')
new_wav.writeframes(wav.readframes(-1))
The outcome is to interleave both signals with the same weight in a single channel. (Note: Make sure to use writeframes() instead of writeframesraw().)

Low level swap without library

I searched for some information about wave-files and found this page, where the file format is described: http://ccrma.stanford.edu/courses/422/projects/WaveFormat/

Then I just copied the header and changed the endianess of the data-block

 bytes = indian.read(44) # copy wav-header
 output.write(bytes)
 
 while len(bytes) > 0: # data => swap endian
         bytes = indian.read(4)
         output.write(bytes[::-1])
Note that the above also swaps left and right audio channels. bytes = indian.read(2) will avoid that.

To do the same with list comprehensions, try this:

 headers = indian.read(44)
 data = indian.read()
 
 swapped = [ b+a for (a,b) in zip(data[::2],data[1::2]) ]
 data_=.join(swapped_)
 
 output.write(headers)
 output.write(data_)
WAV Specification anybody?

I looked at the WAV specification and found that little endian wavs have "RIFF" in the header. Big-endian ones have "RIFX". Then I used vim -b indian.wav, changed an F to an X, and heard that I'm an idiot. Nice :)

My solution is more "It is not the spoon that bends, but rather *you* who bends"... why change the endianess when we can inform the player of the endianness directly? :D

What audio player did you use; I tried the same trick using mplayer but it wouldn't play. Also, when I run file on the normal indian.wav I get 'RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 11025 Hz' (what you'd expect) but when i run it on the modified one (all I changed was the one character) I get 'RIFF (big-endian) data, WAVE audio, Microsoft PCM, 16 bit, 256 channels 288030720 Hz' which makes no sense.
Same issue here; it's because 'RIFX' indicates that all values in the file (including length and format data) are in big-endian, which causes garbage values. I guess some players can figure out what to do (maybe they just default to sane values?)
I have verified this with no modification to the decoded wav. Import as RAW in audacity, It should ask for the params, set it to big endian, and the sample rate to 11025.
From the command line

curl http://butter:fly@www.pythonchallenge.com/pc/hex/bin.html | munpack
sox -V indian.wav indian.sw
perl -pe 's/(.)(.)/\2\1/g' < indian.uw >indian_byteswap.uw
sox -r 11025 indian_byteswap.uw indian_byteswap.wav
Kyz 04:46, 19 Apr 2010 (PDT)

I don't have munpack on my system so I used base64 -d instead. I did the endian swap via dd:

(head -c 44 indian.wav; tail -c +45 indian.wav | dd conv=swab) > tmp.wav
Benlynn 17:04, 24 May 2010 (PDT)
___________________________________________________---
A fence is shown, with a big sign claiming private property on it. We are, however, invited to closely examine the fence. The image of the fence, unreal.jpg, is served with a curious 'Content-Range' header; we apparently only were served the first 30203 bytes of the full file which is 2123456789 bytes small. Requesting the whole range gives us a 206 response with the question why we don't respect someone's privacy, but this time the Content-Range header claims to have served a different part of the funny 2123456789 range; from byte 30203 through to 30326. So we investigate what comes after that last number too. Let's automate this though:

 >>> import urllib2
 >>> import re
 >>> def fencebreaking():
 ...     auth = urllib2.HTTPBasicAuthHandler()
 ...     auth.add_password('pluses and minuses', 'www.pythonchallenge.com',
 ...         'butter', 'fly')
 ...     urllib2.install_opener(urllib2.build_opener(auth))
 ...     url = 'http://www.pythonchallenge.com/pc/hex/unreal.jpg'
 ...     range = re.compile('bytes (\d+)-(\d+)/(\d+)').search
 ...     req = urllib2.Request(url)
 ...     resp = urllib2.urlopen(req)
 ...     start, end, length = [int(i)
 ...         for i in range(resp.info()['content-range']).groups()]
 ...     req.add_header('Range', '')
 ...     while end:
 ...         req.headers['Range'] = 'bytes=%i-' % (end + 1)
 ...         resp = urllib2.urlopen(req)
 ...         print resp.read()
 ...         start, end, length = [int(i)
 ...             for i in range(resp.info()['content-range']).groups()]
 
After just a few iterations we're told that we are in:

   we can go on in this way for really long time.
   stop this!
   invader! invader!
   ok, invader. you are inside now.
Now that we are 'inside', let's see what 'invader' really means; according to 'invader.html', that's *us*. Also, if we are really inside, let's poke about. It turns out that all the way at the end is also some information:

 >>> url = 'http://www.pythonchallenge.com/pc/hex/unreal.jpg'
 >>> req = urllib2.Request(url, headers={'Range': 'bytes=2123456789-'})
 >>> resp = urllib2.urlopen(req)
 >>> print resp.read()
 esrever ni emankcin wen ruoy si drowssap eht
 
This tells us that "esrever ni emankcin wen ruoy si drowssap eht"; or in reverse, that "the password is your new nickname in reverse"; in other words, the password is 'redavni'.

Note that there are some headers to inspect; resp.info()['content-range'] tells us this newfound information really started at 2123456744; so let's inspect if anything preceeds this information.

>>> req.headers['Range'] = 'bytes=2123456743-'
>>> resp = urllib2.urlopen(req)
>>> print resp.read()
and it is hiding at 1152983631.
And we learn that something is hiding at 1152983631. Nothing can be found directly preceding this last message, so we move to this new hint.

>>> req.headers['Range'] = 'bytes=1152983631-'
>>> resp = urllib2.urlopen(req)
This returns a chunk of data, only 239733 bytes short. There are no adjacent chunks to be found. The data returned is a password protected zipfile; ZipInfo will not be able to open it without additional coding, but the Unix zip tools do just fine; I assume Windows tools will have no problems either. The password we already deduced above. (And looking at the url invader.html confirms it.)

The readme.txt tells us this file is really level 21!

Using the UNIX shell and curl

URL=http://butter:fly@www.pythonchallenge.com/pc/hex/unreal.jpg
for x in 30203 30237 30284 30295 30313 2123456744 2123456712
do
    curl -r $x- $URL
done
curl -r 1152983631- $URL >unreal.zip
unzip -P redavni unreal.zip
Kyz 07:04, 19 Apr 2010 (PDT)
_____________________________________________________
readme.txt tells us:

   * We used to play this game when we were kids
   * When I had no idea what to do, I looked backwards.
The package.pack file is basically a pass-the-parcel birthday package; all wrapped up in layers of wrappings. Sometimes those wrappers are backwards; so let's unwrap the layers:

>>> def unwrap(data):
...     while True:
...         if data.startswith('x\x9c'):
...             data = zlib.decompress(data)
...         elif data.startswith('BZh'):
...             data = bz2.decompress(data)
...         elif data.endswith('\x9cx'):
...             data = data[::-1]
...         else:
...             return data
The resulting message is 'sgol ruoy ta kool', or 'look at your logs' backwards. We didn't keep any logs, but some experimentation shows that we can keep track of our progress by printing various characters as we find layers; going backwards means moving the print head back:

>>> def unwrap(data):
...     result = ""
...     while True:
...         if data.startswith('x\x9c'):
...             data = zlib.decompress(data)
...             result += ' '
...         elif data.startswith('BZh'):
...             data = bz2.decompress(data)
...             result += '#'
...         elif data.endswith('\x9cx'):
...             data = data[::-1]
...             result += '\n'
...         else:
...             return result
printing the result of this method will form the word 'copper', which is our key to level 22.


As a matter of fact, you don't have to detect the decompression method, just try all 4 options.

def unwrap(data):
	history = ""
	while True:
		try:
			data = zlib.decompress(data)
			history += 'z'
		except:
			try:
				data = bz2.decompress(data)
				history += 'b'
			except:
				history += '\n'
				data = data[::-1]
				if(history[-3:] == '\n\n\n'):
					break
	return(history)
Another more generic way:

   reverse = lambda s: s[::-1]
   reverse.__module__ = 'reverse'
   decompressors = [zlib.decompress, bz2.decompress, reverse]
   logs = []
   step = True
   last = None
   data = zip.read('package.pack', pwd)
   while step:
       step = False
       for decompress in decompressors:
           try:
               if last == decompress.__module__ in ('reverse',): raise Exception()
               data = decompress(data)
               step = True
               last = decompress.__module__
               logs.append((len(data), last))
               break
           except:
               pass
   mark = dict(zlib='.', bz2='*', reverse='\n')
   print "".join([mark[log[1]] for log in logs])
Example in Perl

use Compress::Zlib qw(inflateInit);
use Compress::Bzip2 qw(decompress_init);

undef $/;
my $data = <>;

for (;;) {
    if ($data =~ /^\x78\x9c/) {
	print ' ';
	my ($out, $status) = inflateInit()->inflate($data);
	$data = $out;
    }
    elsif ($data =~ /^(BZ)?h[1-9]/) {
	print '*';
	$data = "BZ$data" unless $data =~ /^BZ/;
	my $stream = decompress_init();
	my $out = $stream->add($data) . $stream->finish();
	$data = $out;
    }
    elsif ($data =~ /([1-9]h(ZB)?|\x9c\x78)$/) {
	print "\n";
	$data = reverse $data;
    }
    else {
	print "\n$data\n";
	exit;
    }
}
Kyz 07:03, 19 Apr 2010 (PDT)

Bash shell

Long ago I needed zpipe, so I happen to have it handy. Most people will need to run:

curl -s -o zpipe.c http://www.zlib.net/zpipe.c && gcc -o zpipe zpipe.c -lz
With zpipe, this riddle is easy to solve in Bash, though it's a bit fiddly because of temporary files:

cp package.pack 1.tmp
while [[ 1 ]]; do
  case `head -c 1 1.tmp` in
  'x') ./zpipe -d < 1.tmp > 2.tmp                 ; printf ' ' ; a=0 ;;
  'B') bzip2 -d < 1.tmp > 2.tmp                   ; printf X   ; a=0 ;;
    *) if [[ $a == 1 ]]; then break; fi
       xxd -p -c1 1.tmp | tac | xxd -r -p > 2.tmp ; echo       ; a=1 ;;
  esac
  mv 2.tmp 1.tmp
done
cat 1.tmp ; echo
Benlynn 16:53, 24 May 2010 (PDT)

Factor

I've been working at these in Factor, and this came out reasonably nicely:

IN: challenge21
USING: kernel sequences compression.zlib bzip2 io.files
       io.encodings.binary continuations fry combinators byte-arrays ;

: pack-data ( -- bytes )
    "data/idiot2/package.pack" binary file-contents ;

: uncompress-data ( data -- data' )
    dup length <compressed> uncompress ;

: general-uncompress ( data -- data' method ? )
    dup 2 head
    { { B{ 120 156 } [ uncompress-data CHAR: . t ] }
      { B{ 66 90 } [ bz2-decompress-bytearray CHAR: B t ] }
      [ drop f f ]
    } case ;

: uncompress-line ( data -- data' line ? )
    [ general-uncompress ] [ ] "" produce-as
    nip dup length 0 = not ;

: uncompress-lines ( data -- data' lines )
    [ uncompress-line ] [ [ reverse ] dip ] produce nip ;

: challenge21 ( -- hint answer )
    pack-data uncompress-lines [ >string ] dip ;
86.20.31.174 05:15, 7 September 2011 (PDT)
________________________________________________---
A picture of a joystick and a black GIF file called "white.gif".

Playing with the white levels reveals a very small dot in the center of the GIF. Further fiddling reveals it is an animated GIF and the dot is moving slightly; in fact it is waggling like one would a joystick. Think etch-a-sketch.

dfs

Pure Python

A good image viewer helps figure out what you're looking at from a high level (I use the free IrfanView on Windows), but PIL is much better for digging out details. First a handy function to return an iterator over the frames of the GIF:

import Image, ImageSequence

def get_iterator():
    return ImageSequence.Iterator(Image.open("white.gif"))
Then, for example, the number of frames can be computed like so (although note that we don't need to know this!):

N = len(list(get_iterator()))  # it's 133
Poking around suggests the following: for each frame, one pixel uses color 8 and all the rest use color 0. Also, color 0 is (0, 0, 0), and color 8 is (8, 8, 8). So this is an animation of a 1-pixel, very dark dot, moving on a black background. Here's code to verify all that:

for frame in get_iterator():
    assert frame.getcolors() == [(39999, 0), (1, 8)]
    p = frame.getpalette()
    assert p[0:3] == [0, 0, 0]
    assert p[8*3:9*3] == [8, 8, 8]
Since only colors 0 and 8 are ever used, and only 1 pixel per frame uses color 8, the only real info here is which pixel uses color 8. So let's make a list of all color 8 locations. This uses the very fast getdata() method, but that requires us to figure out the (x, y) coordinate. This is easy when you know how (code not shown here verified that all frames are 200x200):

locations = []
for frame in get_iterator():
    c = list(frame.getdata())
    assert len(c) == 40000
    i = c.index(8)
    y, x = divmod(i, 200)
    locations.append((x, y))
Staring at the list of locations shows that only 9 are used, the cross-product of (98, 100, 102) with itself, centered on (100, 100). Remember the photo of the joystick? Can't be a coincidence! As the page title said, we should emulate a joystick. But a joystick doing what?

That was the hardest part for me (although pretty easy compared to some previous levels <wink>). I eventually pictured a very simple line-drawing app, drawing a line at a constant speed, and moving in the current direction of the joystick. Another twist is needed to make that work smoothly: whenever the joystick returns to the netural (center) position, the screen should reset.

PIL's ImageDraw module can be used for this, but it's easier to use the standard turtle.py library. This requires some coordinate conversion: PIL, like most standard graphics packages, puts (0, 0) in the upper left corner and has y increasing "down", but turtle puts (0, 0) smack in the middle of the canvas and has y increasing "up". This is all that's needed:

import turtle, time
EXP = 2    # make bigger to draw larger letters
x = y = 0  # center of turtle canvas
for pilx, pily in locations:
    dx = (pilx - 100) // 2  # -1, 0, +1
    dy = (100 - pily) // 2  # -1, 0, +1
    x += dx * EXP
    y += dy * EXP
    turtle.goto(x, y)
    if dx == dy == 0: # joystick at center
        time.sleep(1) # so we can read the letter
        turtle.reset()
        x = y = 0
Not Much Python

Okay, here we go. No Python really required; but you can if you want.

I used the giflib utils. (Available for Cygwin and *nix. Note that the Cygwin version tends to output data in text mode, thus messing up CR/LF.) http://sourceforge.net/projects/libungif

I'll be using Bash.

$ gifasm -d ww0 white.gif
makes 133 GIF files. Note how the files are inconveniently named.

$ for f in ww0[0-9][0-9][0-9]; do mv -v $f `echo $f|sed "s/ww0/ww/"`; done
Much better! Okay, lets make them visible (not really necessary).

$ for f in ww*.gif; do gifclrmp -g 5 $f >b$f; done
(You can reanimate it with gifasm -A 500 -a bww*.gif >whiter.gif.)

It turns out that most of the files are identical.

$ md5sum bww* | cut -d" " -f1 | sort | uniq | wc
There are only 10 different types of file! Viewing one of each type reveals that the waggle is digital: middle, down, down-right, right, right-up, up, left-up, left, left-down and middle-special. (Luckily, they even appear in that order, which makes things much easier.)

Etch a sketch time.

(Originally I used emacs, bash and gnuplot, but heres the Python solution. Note that y is upside down in a canvas. Also note how the filenames are inconvenient again. Sigh. There's probably some really good library for handling these things that I haven't found yet.)

import Tkinter

r = Tkinter.Tk()
c = Tkinter.Canvas()
c.pack()

dir = [(0,0),(0,-5),(5,-5),(5,0),(5,5),(0,5),(-5,5),(-5,0),(-5,-5),(50,0)]
dircount = 0
piclist = {}
x, y = 10, 150
for i in range(133):
    pic = open("bww%03d.gif" % i, "rb").read()
    if pic not in piclist:
        piclist[pic] = dir[dircount]
        dircount += 1
    dx, dy = piclist[pic]
    if dx < 10:
        c.create_line(x, y, x+dx, y-dy)
    else:
        y = 150
    x += dx
    y -= dy

r.mainloop()
dfs

Another Solution

Here's another solution which uses PIL and differs from the other solutions in that it draws the answer into a single image. I also used getbbox() which was a pretty easy way to find the location of the pixel in each frame to key off.

#!/usr/bin/python
import Image
import ImageDraw

im = Image.open("white.gif")
new = Image.new("RGB", (200, 200))
draw = ImageDraw.Draw(new)
cx, cy = 0, 100
for frame in range(133):
    im.seek(frame)
    left, upper, right, lower = im.getbbox()
    dx = (left - 100)//2
    dy = (upper - 100)//2
    if cx:
        draw.point([cx, cy])
    cx += dx
    cy += dy
    if dx == dy == 0:
        cx += 25
        cy = 100
new.show()
I got to this point by initially opening the GIF in GIMP. That allowed me to see that it was 133 frames. Then I loaded the frames into PIL and started looking at the histogram, pixel data, and palette. It was pretty clear what was going on right away.

Using Perl and GD

GD sadly lacks the ability to open gif animations, so I used NetPBM commands to extract the appropriate frame.

use GD;

my $dest = GD::Image->new(250, 50, 1);
my $pen = $dest->colorAllocate(255, 255, 255);
my ($pic, $x, $y, $dx, $dy) = (0 x 5);

for my $frame (1 .. 133) {
    # extract frame $frame from the gif animation and open it
    my $data = `giftopnm -image=$frame white.gif | ppmtogif`;
    my $src = GD::Image->new($data);

    # find the non-black dot - x,y are always one of 98, 100 or 102
    my $dot = $src->colorClosest(8, 8, 8);
    for my $v (-2, 0, 2) {
	my ($h) = grep {$src->getPixel(100+$_, 100+$v) == $dot} -2, 0, 2;
	$dx = $h, $dy = $v, last if defined $h;
    }

    if ($dx == 0 && $dy == 0) {
	($x, $y) = (25 + 50*$pic++, 25);
    }
    else {
	$dest->line($x, $y, $x+$dx, $y+$dy, $pen);
	($x, $y) = ($x+$dx, $y+$dy);
    }
}
open(FH, ">white.png") && print(FH $dest->png()) && close FH;
Kyz 10:20, 19 Apr 2010 (PDT)
_____________________________________________---
Pythonic Solution

The title asks 'what is this module?'. The source tells us "this is an undocumented module", and some apparent gibberish ('va gur snpr bs jung?'). Take the title and the first source hint literally: there is a module named 'this', and if you import this you get to see Tim Peters' Zen of Python:

 >>> import this
 The Zen of Python, by Tim Peters
 [...]
In the source code for the module, however, the text has been obscured, and a short decoding routine is included. We can reuse this routine to decode our obscure text as well:

 >>> s = 'va gur snpr bs jung?'
 >>> print "".join([this.d.get(c, c) for c in s])
 in the face of what?
The decoded hint asks us a question, which can be answered with Tim's Zen:

 "In the face of ambiguity, refuse the temptation to guess."
'ambiguity' is our next key.


Earlier solution

If you need to write code for this one, you're insane ;-):

import sys, StringIO, re
capture = StringIO.StringIO()
save_stdout, sys.stdout = sys.stdout, capture
import this
sys.stdout = save_stdout
guts = capture.getvalue().lower()
searchfor = "va gur snpr bs ".decode("rot-13")
m = re.search(searchfor + r"(\w+)", guts)
print m.group(1)
I don't know what the above means (and where did the text come from?), but Googling

site:cvs.sourceforge.net/viewcvs.py/python "in the face of"
spits out the answer. I don't get it.

UncleTimmy 07:48, 20 May 2005 (MDT): This one was very much a Python riddle. "this" is in fact the name of an undocumented module, but one that's well-known to Python programmers. It's a kind of "Easter egg", added after "import this" was adopted as the motto for a Python conference several years ago. Grab a Python, start it, and type "import this" at the prompt.

Thanks, and the significance of the cow in the picture?

UncleTimmy 14:31, 20 May 2005 (MDT): Heh! You'll have to bribe thesamet to answer that one. When the page source said "it can't find it", I figured it meant the cow was looking for the module, and that's all. Then again, I seem to miss a lot of clues ;-)

Thesamet 16:14, 20 May 2005 (MDT): What does it look like? There is no ambiguity in its face. Of course the cow is looking for the module!

Themule 02:30, 29 May 2005 (CEST): Oops, try this:

fgrep -i "in the face" /usr/lib/python2.4/*
It's totally unrelated to the riddle, but it does provide the solution!


If you can't find the right module...

Since the only hint I got about the module to use was that it is undocumented, I copy'n'pasted the list of modules from the module index of the documentation and filtered my lib directory. If you still can't find the right module in the remaining list of undocumented modules, just import them all...

modules = """
__builtin__
__future__
__main__
_winreg (Windows)
aepack (Mac)
aetools (Mac)
...
"""
py_dir = "/usr/lib/python2.5/"
for f in os.listdir(py_dir):
    (name, ext) = os.path.splitext(f)
    if ext == ".py" and not name in modules:
        try:
            print "=== Undocumented: %s" % name
            __import__(name)
        except ImportError:
            pass
--Rebecca 01:21, 17 Dec 2007 (PST)

using str.decode

>> 'va gur snpr bs jung?'.decode('rot13')
u'in the face of what?'
_______________________________________----
Contents [hide]
1 First Blood
2 Alternative using dijkstra.py
3 Non-recursive "frameworky" solution
4 A* search solution
5 Dead End Filler
6 Stack based solution you can watch with Tk
7 Animated all shortest paths
8 A simple, fast breadth-first search algorithm
9 A short and simple solution
10 MS Paint Solution
11 A Ruby Solution
12 Another short and simple solution
13 An extremely short and somewhat simple solution
14 Breadth-first graph-building
15 Solved with Perl, AI::Pathfinding::AStar and GD
First Blood

--Birkenfeld 22:57, 18 May 2005 (MDT)

Since I'm the first one here, I'll post my solution. It may be very inefficient and a memory-hog (I had to do sys.setrecursionlimit() because 1000 was not enough...)

UncleTimmy notes: fiddling the recursion limit is dangerous, and may cause mysterious errors or segfaults (depending on OS).

import time, sys

def pass1(i):
    # pass 1: generate list of non-white pixels
    nw = set()
    for x in range(640):
        for y in range(640):
            if i.getpixel((x,y)) != (255,255,255,255):
                nw.add((x,y))
    print "found %i non-white pixels" % len(nw)
    return nw

def pass2(i, nw):
    # pass 2: search way(s) through the maze
    def vadd(t1, t2):
        return tuple(t1[i] + t2[i] for i in range(len(t1)))
    def rev(tup):
        return tuple(-i for i in tup)
    offsets = [(0,1), (0,-1), (1,0), (-1,0)]
    ways = []

    def branch(pos, prevoff, points, indent):
        while 1:
            #print indent*" ", pos; sys.stdout.flush()
            points.append(pos)
            offs = [off for off in offsets if off != rev(prevoff) and
                    vadd(pos, off) in nw]
            if len(offs) == 1:
                pos = vadd(vadd(pos, offs[0]), offs[0])
                prevoff = offs[0]
            elif len(offs) > 1:
                for off in offs:
                    cpos = vadd(vadd(pos, off), off)
                    branch(cpos, off, points[:], indent+1)
                return
            else:
                if pos == (1, 639):
                    ways.append(points)
                #print "---"
                return

    branch((639,1), (0,1), [], 0)
    print "found %i way(s) through" % len(ways)
    return ways

def pass3(i, way):
    # pass 3: collect bytes on the way
     bytes = []
     for point in way:
        bytes.append(i.getpixel(point)[0])
    return bytes
Calling in such a way:

   import Image
   i = Image.open("maze.png")
   nw = pass1(i)
   way = pass2(i, nw)[0]
   bytes = pass3(i, way)
   open("no24.zip", "wb").write("".join(chr(b) for b in bytes))
Alternative using dijkstra.py
#ตน้ต๗ำรณฌณ๖ผซฯ

(--Rspyc 14:36, 18 May 2005 (MDT))

I started to make my own algorithm for finding to path from top to bottom, but then I figured it was too much trouble. I searched for a Python implementation of Dijkstra's shortest path algorithm and found it in pyNMS (http://pynms.sourceforge.net/, http://pynms.sourceforge.net/dijkstra.html). To use dijkstra.py, you need both dijkstra.py and priodict.py. I didn't bother installing pyNMS properly; I just put both modules in my working directory.

Using Dijkstra's algorithm for this is probably overkill, but it works.

import dijkstra
import Image

"""dijkstra.py requires a dictionary-like object for access to vertices and edges"""
class G:
    def __init__(self, imgdata, imgsize):
        self.imgdata = imgdata
        self.width, self.height = imgsize
    def __getitem__(self, vertex):
        """return dict containing edges and corresponding weights"""
        x, y = vertex
        # All neighbours
        neighbours = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]
        # Filter out pixels outside of image
        neighbours = [(nx, ny) for (nx, ny) in neighbours
                      if 0 <= nx < self.width and 0 <= ny < self.height]
        # Keep only non-white pixels
        neighbours = [(nx, ny) for (nx, ny) in neighbours
                      if self.imgdata[nx + ny*self.width][1] == 0]
        return dict([(n, 1) for n in neighbours])  # Attach arbitrary weight to the edges

"""Phase 1: extract path from image"""
def phase1():                    
    img = Image.open('maze.png')
    data = list(img.getdata())
    start = 639, 0
    end = 1, 640
    g = G(data, img.size)
    print 'Dijkstra...'
    D, P = dijkstra.Dijkstra(g, start, end)
    # Construct path from P; add color values in the same pass
    print 'Constructing path...'
    path = []
    pos = end
    while True:
        x, y = pos
        path.append((pos, data[x+img.size[0]*y][0]))
        if pos == start:
            break
        pos = P[pos]
    path.reverse()
    # Save the sequence to file, so we can study it without having to
    # recalculate it again and again
    cPickle.dump(path, file('maze.sequence', 'wb'))
    print 'path pickled as maze.sequence'

"""Phase 2: generate zipfile from data"""
def phase2():
    path = cPickle.load(file('maze.sequence', 'rb'))
    # Some investigation suggests that only the red values are relevant
    reds = [r for (pos, r) in path]
    # First I tried using all the red pixels and not the black (i.e. only the
    # pixels with non-zero values), but that resulted in a corrupt file. The
    # correct way is simply to take every second value, starting from the second
    # one.
    data = reds[1::2]
    file('maze.zip', 'wb').write("".join(map(chr, data)))

# Execute
phase1()
phase2()
Non-recursive "frameworky" solution

--UncleTimmy 19:34, 18 May 2005 (MDT)

This level was so cool! The first thing I tried (looking for paths in the white squares) didn't work, so I made a helper class to capture the logic of brute-force maze crawling. Note that this doesn't assume much about what "a maze" or "a solution" is, apart from that a path can be described as a sequence of integer pairs ("points"), and that a legitimate path never contains a repetition of a point:

class MazeBase(object):
    def __init__(self):
        self._reset()

    def _reset(self):
        # List of (point, list of successor choices) pairs.
        # This captures the current path from the starting point;
        # the successor lists are used during backtracking.
        self.path = []

        # A point is on the current `path` iff it's in this set.
        self.onpath = set()

    # Subclass must override.  Return true iff `point` is a part of
    # the maze we can traverse (in bounds, and not part of "a wall").
    # It will never be called with a point already on the current
    # path.
    def is_feasible(self, point):
        raise NotImplementedError

    # Return list of `point`'s traversable neighbors.  This
    # implementation assumes all _possible_ neighbors are
    # the four (x+/-1, y) and (x, y+/-1).  A subclass should
    # override if the maze geometry doesn't work that way.
    def neighbors(self, (x, y)):
        return [p for p in (x+1, y), (x-1, y), (x, y+1), (x, y-1)
                if p not in self.onpath and self.is_feasible(p)]

    def add_to_path(self, point):
        assert point not in self.onpath
        self.onpath.add(point)
        self.path.append((point, self.neighbors(point)))

    # Generate all paths starting at point `start`.  The same
    # list object is yielded each time, so the caller should
    # copy what it wants if it lets the generator resume.
    def gen_paths(self, start):
        self._reset()
        assert self.is_feasible(start)
        self.add_to_path(start)
        path, onpath = self.path, self.onpath
        yield path
        while path:
            point, choices = path[-1]
            if choices:
                self.add_to_path(choices.pop())
                yield path
            else:   # out of choices here -- backtrack
                del path[-1]
                onpath.remove(point)
An intermission for some code specific to level 24:

import Image
im = Image.open("maze.png")

black = 0, 0, 0, 255
white = 255, 255, 255, 255
blue = 0, 0, 255, 255
Now the subclass that eventually solved the riddle, defining "a path" to consist of non-white squares:

class Level24(MazeBase):
    def __init__(self, image):
        super(Level24, self).__init__()
        self.im = image
        self.xn, self.yn = image.size

    def is_feasible(self, point):
        return (0 <= point[0] < self.xn and
                0 <= point[1] < self.yn and
                self.im.getpixel(point) != white)

    def solve(self):
        self.solution = None # nothing yet
        # "from top to bottom" suggests we need to start in
        # row 0 and end in row yn-1.
        last_row = self.yn - 1
        for x in range(self.xn):
            if self.im.getpixel((x, 0)) == black:
                for path in self.gen_paths((x, 0)):
                    if path[-1][0][1] != last_row:
                        continue
                    if self.solution is not None:
                        # It would be an ambiguous puzzle if
                        # more than one such is found.
                        raise ValueError("multiple solutions")
                    self.solution = [p[0] for p in path]
                    # If you want to assume the solution is
                    # unique, put a `return` here, and it will
                    # run about twice as fast.
I'm not sure how thesamet constructed this devious puzzle, but that in fact finds a unique solution. Just for fun, this also saves twisty.png drawing a blue line showing the path taken, and justblue.png drawing the same blue line against a white background:

m = Level24(im)
m.solve()

import ImageDraw
im2 = im.copy()
ImageDraw.Draw(im2).point(m.solution, blue)
im2.save("twisty.png")

im2.paste(white)
ImageDraw.Draw(im2).point(m.solution, blue)
im2.save("justblue.png")
The rest just extracts the embedded zip file, and verifies some assumptions made "by eyeball". I find it worthwhile to verify assumptions ;-)

data = []
for p in m.solution:
    r, g, b, a = im.getpixel(p)
    assert g == b == 0 and a == 255
    data.append(r)
import array
data = array.array("B", data).tostring()
# That's the same as data = "".join(map(chr, data)), but faster for
# "large" len(data).

d1 = data[0::2]
assert d1 == "\x00" * len(d1)

d2 = data[1::2]
f = open("hidden.zip", "wb")
f.write(d2)
f.close()
There's still something peculiar here: while many programs can open that zip file, Python's zipfile module cannot:

>>> import zipfile
>>> z = zipfile.ZipFile("hidden.zip", "r")
Traceback (most recent call last):
...
BadZipfile: File is not a zip file
I know what to do to it so Python can open it, but in case that's a step in a later level, I'm not telling ;-)

A* search solution

--Mjpieters 16:13, 23 May 2005 (MDT)

Others have already posted what to do when you find the path through the maze, so here is my way of solving the maze. I used an implementation of the A* (best first) search algorithm I already had lying around from an AI class I once did. The following code requires the PQueue module, and will use psyco if available:

# Best-first search algorithm
# Explorative implementation.
# (c) Martijn Pieters 2004, 2005

from pqueue import PQueue

#
# Generic best-first search algorithm.
#
class SearchState:
    """Base class for best-first searches.

    Provides the interface for the search, including the closed status, the
    heuristic and the framework support for storing the state in the required
    structures (hashing and such).

    """
    closed = 0    # Not a seperate list, the states themselves maintain this
    depth = 0     # Distance from starting state
    parent = None # Reference to state that generated this

    #
    # Abstract methods to implement in concrete classes
    #
    def getInternalState(self):
        """Get the internal state of this search node.

        Should return a immutable python type that identifies this node
        uniquely.

        """
        raise NotImplementedError

    def calculateHeuristicScore(self):
        """Calculate the heuristic distance to the goal state as an int"""
        raise NotImplementedError

    def createChildren(self):
        """Create child nodes.

        Implementation can be a generator.

        """
        raise NotImplementedError

    def getGoalState(self):
        """Return the goal state"""
        raise NotImplementedError

    #
    # State implementation
    #
    def listChildren(self):
        """Returns a list of child nodes"""
        for child in self.createChildren():
            child.parent = self
            child.depth = self.depth + 1
            yield child

    _distance = None
    def getHeuristicScore(self):
        """Get the heursitic score. Value is cached."""
        if self._distance is None:
            self._distance = self.calculateHeuristicScore()
        return self._distance

    def __cmp__(self, other):
        return cmp(self.getInternalState(), other.getInternalState())

    def __hash__(self):
        return hash(self.getInternalState())


# A* search algorithm
def searchBestFirst(start):
    goal = start.getGoalState()
    open = PQueue()
    open.insert(start.getHeuristicScore(), start)
    seen = {start: start}

    while open:
        # Find lowest score and remove from open
        priority, current = open.pop()

        # Give an indication of the progress so far:
        # print 79 * '\r',
        # print "Searching, depth = %2d, f() = %2d" % (current.depth, priority),

        if current == goal:
            print "\nCreated %d states, %d states left on open." % (
                len(seen), len(open))
            return make_path(current, seen)

        # The following calculates f(n) = h(n) + g(n) for all child states
        children = [(c.getHeuristicScore() + c.depth, c)
                    for c in current.listChildren()]
        for priority, child in children:
            if not seen.has_key(child):
                seen[child] = child
                open.insert(priority, child)
            else:
                # We've seen this state before, is it a shorter path?
                oldchild = seen[child]
                if oldchild.depth > child.depth:
                    if not oldchild.closed:
                        # The longer path should be removed
                        del open[oldchild]
                    open.insert(priority, child)
                    # Make sure the shorter path is recorded.
                    seen[child] = child

        seen[current].closed = 1

    print "\nSearched all %d states, through %d levels." % (
        len(seen), max(map(lambda s: s.depth, seen.keys())))
    return None

# Use psyco if available (python JIT compiler) for the search algorithm.
# Note though, that psyco trades memory for speed, so the memory requirements
# will go up notably for large state spaces.
try:
    import psyco
    psyco.bind(searchBestFirst)
except ImportError:
    pass


def make_path(end, seen):
    """Back-track from end back to goal

    Using the parent references, reconstruct the path again. The seen structure
    holds the nodes with the shortest paths.

    """
    path = [end]
    while seen[path[-1]].parent:
        path += [seen[path[-1]].parent]
    path.reverse()
    return path


#
# Maze implementation of search algorithm
#
class MazeState(SearchState):
    """Maze location representation in a state-space search
   
    State is represented as a an (x, y) tuple.

    In order to accomodate the search algorithm, the distance from the starting
    point is tracked, a heuristic function is provided, and it's closed state
    is tracked (wether or not it already has been considered).
   
    The state includes a reference to the parent state in the graph, so the
    path through the graph can be reconstructed.
   
    """
   
    def __init__(self, maze, pos=(0, 0)):
        """Create a new maze state of at position pos.
       
        """
        self._img = maze
        self._state = pos

    def getInternalState(self):
        return self._state

    def calculateHeuristicScore(self):
        """Return the minimum distance from the goal """
        goalx, goaly = self.getGoalState()._state
        x, y = self._state
        return abs(goalx - x) + abs(goaly - y)
   
    def createChildren(self):
        """Create child states.
       
        Returns all possible child nodes as an iterable.
       
        """
        x, y = self._state
        img = self._img
        for i in (-1, 0, 1):
            for j in (-1, 0, 1):
                if (i and not j) or (j and not i):
                    pos = (x + i, y + j)
                    if pos[0] < 0 or pos[1] < 0:
                        continue
                    if pos[0] >= img.size[0] or pos[1] >= img.size[1]:
                        continue
                    r, g, b, a = self._img.getpixel(pos)
                    if not g and not b:
                        yield self.__class__(self._img, pos)
   
    def getGoalState(self):
        return self.__class__(self._img, (1, 640))


import Image
maze = Image.open('tmp/maze.png')
   
start = MazeState(maze, (639, 0))
path = searchBestFirst(start)
   
if path:
    print 'Path length:', len(path)
    path = [n.getInternalState() for n in path]
    data = ""
    for pos in path[1::2]:
        r, g, b, a = maze.getpixel(pos)
        data += chr(r)
        open('tmp/mazedata.zip', 'wb').write(data)
Dead End Filler

--Chopin 06:25, 25 May 2005 (MDT) I read about a 'dead end filler' algorithm and thought it would be nice to try implementing it in python. It scans the maze and fills in all the dead ends, so in the end the solution remains. Therefore also giving a nice image of the solution.

import Image
im = Image.open('maze.png')
X, Y = im.size

MARK = 255
MARKER = MARK, MARK, MARK, 255

def is_wall(x, y):
    # Border.
    if x < 0 or x >= X or y < 0 or y >= Y:
        return True
    p1, p2, p3, p4 = im.getpixel((x, y))
    # White or marked is a wall.
    return p1 == p2 and p1 in (127, 255)

# If 'dead end' return the only possible direction, else None.
# Start flag to ignore start and end point (these are also 'dead ends').
def is_dead_end(x, y, start=True):
    # Possible start or finish (top/bottom).
    if start and (y == Y - 1 or y == 0):
        return None
    if is_wall(x, y):
        return None
    direction = None
    for dx, dy in (-1, 0), (1, 0), (0, -1), (0, 1):
        if not is_wall(x + dx, y + dy):
            if direction:
                # More than one way out:  not a dead end.
                return None
            direction = dx, dy
    return direction

def dead_end_filler(x, y, start=True):
    out = ""
    direction = is_dead_end(x, y, start)
    while direction:
        out += chr(im.getpixel((x, y))[0])
        im.putpixel((x, y), MARKER)
        dx, dy = direction
        x, y = x + dx, y + dy
        direction = is_dead_end(x, y, start)
    return out

def scan(x, y):	
    for j in range(y):
        for i in range(x):
            if not is_wall(i, j):
                dead_end_filler(i, j)

scan(X, Y)
im.save('maze.solved.png')

out = dead_end_filler(639, 0, False)

f = open('24.zip', 'wb')
f.write(out[1::2])
f.close()
Stack based solution you can watch with Tk

--Japyh 20:34, 27 May 2005 (MDT)

#!/usr/bin/python
import Image
import Tkinter
import array

class PixelSetter:
    # Update display every TK_INTERVAL pixel changes.
    # Larger runs faster but is jerkier.
    def __init__(self, tk, image, TK_INTERVAL=1):
        self.tk = tk
        self.image = image
        self.TK_INTERVAL = TK_INTERVAL
        self.count = 0

    def put(self, x, y, color):
        if self.tk:
            self.image.put(color, (x, y))
            self.count += 1
            if self.count >= self.TK_INTERVAL:
                self.tk.update()
                self.count = 0

# Stack based solution to finding a path through the maze.
def find_path(maze, row, col):
    PATH, WALL, CRUMB = range(3)
    if maze[row][col] == WALL:
        return
    max_row = len(maze) - 1
    max_col = len(maze[0]) - 1
    move = (( 0,  1), # East
            ( 1,  0), # South
            ( 0, -1), # West
            (-1,  0), # North
           )
    stack = [(col, row, 0)]
    while stack:
        col, row, direction = stack.pop()
        if maze[row][col] == PATH:
            # First time we've visited this pixel.
            setpixel(col, row, "#FF0000")
            maze[row][col] = CRUMB
            if row == max_row:
                stack.append((col, row, direction))
                break
        for direction in range(direction, 4):
            drow, dcol = move[direction]
            next_row, next_col = row + drow, col + dcol
            if (0 <= next_row <= max_row and
                  0 <= next_col <= max_col and
                  maze[next_row][next_col] == PATH):
                stack.append((col, row, direction + 1))
                stack.append((next_col, next_row, 0))
                break
        else:
            setpixel(col, row, "#7FFFFF")
    return [p[:2] for p in stack]

# Transform maze.png into maze[row][col] where True == wall,
# False == path (open).
im = Image.open("maze.png")
data = list(im.getdata())
white, black = (255, 255, 255, 255), (0, 0, 0, 255)
wall = set([white, (127, 127, 127, 255)])
width, height = im.size
maze = []
for i in xrange(0, len(data), width):
    maze.append([pixel in wall
                 for pixel in data[i:i+width]]) 

# Tk goodness.  Set tk = None to disable.
tk = Tkinter.Tk()
if tk:
    canvas = Tkinter.Canvas(tk, width=width+10,
                                height=height+10)
    # Save as a .gif so Tk can load it in an eyeblink.
    # Change path to black for greater contrast.
    data = [pixel in wall and white or black
            for pixel in data]
    im2 = im.copy()
    im2.putdata(data)
    im2.save("maze.gif")
    # PhotoImage supports fiddling individual pixels
    # efficiently.
    image = Tkinter.PhotoImage(file="maze.gif")
    canvas.create_image(5, 5, image=image, anchor=Tkinter.NW)
    canvas.pack()
    tk.update()
    setpixel = PixelSetter(tk, image).put
else:
    def setpixel(*args):
        pass

path = find_path(maze, 0, 639)
data = [im.getpixel(coords)[0] for coords in path]
a = array.array('B', data[1::2])
f = open("maze.zip", "wb")
a.tofile(f)
f.close()

if tk:
    tk.mainloop()
Animated all shortest paths

UncleTimmy 12:54, 29 May 2005 (MDT)

This one is just plain pretty to watch, and illustrates an important search technique (breadth-first search). Picture yourself at the starting pixel. Determine all the directions you can move from there. Clone yourself, and move in all those directions simultaneously. Also give each of your clones a bucket of paint, and have them dump the paint on the pixel they move to. That's the end of one step. In the next step, each of your clones in turn clones itself, moving simultaneously to all pixels reachable in two steps from the starting pixel. They get a different color of paint.

And so on. At step #i, all the pixels reachable in exactly (but no fewer than) i steps from the starting pixel are given the same color. This goes on until every pixel reachable from the start has been seen. The main program then traces the path back from the goal pixel (after determining that a unique one exists), coloring the pixels on that path grey.

For clarity, the image of the maze displayed initially is fiddled to have black walls and white free pixels. The hidden zip file can be extracted from the final path via any of the methods previously shown; since the point of this one is just to give a nice animation, code for that is skipped here.

import Image
from ImageColor import getrgb
import Tkinter

class Color:
    def __init__(self):
        self.hue = 0   # hue; 0 - 359
        self.sat = 25  # saturation; 0 - 100
        self.hue_inc = self.sat_inc = 1

    def get_tk_rgb(self):
        rgb = getrgb("hsl(%d,%d%%,50%%)" % (self.hue, self.sat))
        return "#%02X%02X%02X" % rgb

    def bump(self):
        self.sat += self.sat_inc
        change_hue = False
        if self.sat > 100:
            self.sat, self.sat_inc, change_hue = 99, -1, True
        elif self.sat < 25:
            self.sat, self.sat_inc, change_hue = 26, 1, True
        if change_hue:
            self.hue += self.hue_inc
            if self.hue == 360:
                self.hue, self.hue_inc = 358, -1
            elif self.hue < 0:
                self.hue, self.hue_inc = 1, 1

def all_shortest_paths(inimage, outimage):
    width, heigth = inimage.size
    dxy = (0, 1), (0, -1), (1, 0), (-1, 0)
    fringe = [(x, 0) for x in range(width)
              if inimage.getpixel((x, 0)) not in wall]
    parent = {}  # map point to its predecessor
    color = Color()
    while fringe:
        cstring = color.get_tk_rgb()
        for point in fringe:
            outimage.put(cstring, point)
            inimage.putpixel(point, white)
        tk.update()
        color.bump()
        next = set()
        for point in fringe:
            x, y = point
            for dx, dy in dxy:
                child = x2, y2 = x + dx, y + dy
                if (child not in next and
                      0 <= x2 < width and
                      0 <= y2 < height and
                      inimage.getpixel(child) not in wall):
                    next.add(child)
                    parent[child] = point
        fringe = next
    return parent

im = Image.open("maze.png")
white, black = (255, 255, 255, 255), (0, 0, 0, 255)
wall = set([white, (127, 127, 127, 255)])
width, height = im.size
tk = Tkinter.Tk()
canvas = Tkinter.Canvas(tk, width=width+10,
                            height=height+10)
# Save as a .gif so Tk can load it in an eyeblink.
# Change paths to white and walls to black.
im2 = im.copy()
im2.putdata([pixel in wall and black or white
             for pixel in im.getdata()])
im2.save("maze.gif")
# PhotoImage supports fiddling individual pixels
# efficiently.
image = Tkinter.PhotoImage(file="maze.gif")
canvas.create_image(5, 5, image=image, anchor=Tkinter.NW)
canvas.pack()
tk.update() 

parent = all_shortest_paths(im, image)
tail = None
for point in parent:
    if point[1] == height - 1:
        if tail is None:
            tail = point
        else:
            raise ValueError("ambiguous")
if tail is None:
    raise ValueError("no solution")
while tail in parent:
    image.put("grey", tail)
    tk.update()
    tail = parent[tail]
tk.mainloop()
A simple, fast breadth-first search algorithm

Some of you write too much code. :-) This one also does not require fiddling with recursion limits.

 #Read the data. Note that this does not use PIL, but my alternate, "simple" way
 #of importing the data, which is to save as PPM-ascii and read in the numbers;
 #this file already has the header stripped off. This is probably not fastest.
 import string
 x=open("maze.txt")
 xr=x.read()
 x.close()
 xs=string.split(string.strip(xr))
 m=[]
 for wd in xs:
   if len(wd)>0:
     m.append(int(wd))
 
 #Initialize array for regions traveled, and set starting state.
 #As I travel through the grid, I keep track of my progress in this array,
 #forming a tree by linking each cell to the cell I used to get there.
 #This way I avoid retracing my path, and at the end I follow the path
 #backward back to the starting point, so I start at the bottom.
 states=[(1,640)]
 sdic=[]
 for i in range(641):
   sdic.append([(0,0)]*641)
 sdic[1][640]=(-1,-1)
 
 #Define a lookup function within the maze array
 def mc(x,y):
   mi=(641*y+x)*3
   return m[mi:(mi+3)]
 
 #Define a step function which tries each possible step from a given state,
 #eliminating ones that go off the edges, go into whitespace(=walls), or
 #retrace traveled paths, and stores each other one in the list of new states
 #to try next round, as well as marking how I got there.
 def stp(x,y):
   global states
   tries=[(x-1,y),(x+1,y),(x,y-1),(x,y+1)]
   for c in tries:
     if c[0]>=0 and c[0]<=640 and c[1]>=0 and c[1]<=640:
       if sdic[c[0]][c[1]]==(0,0):
         if mc(c[0],c[1])!=[255,255,255]:
           states.append(c)
           sdic[c[0]][c[1]]=(x,y)
 
 #Main driver routine which iterates over the list of current states repeatedly
 #until it runs out of states or the goal is reached.
 while len(states)>0 and sdic[639][0]==(0,0):
   oldstates=states[:]
   states=[]
   for cas in oldstates:
     stp(cas[0],cas[1])
 
 #Retrace the path through the known states grid, and collect the red data from the maze
 if sdic[639][0]!=(0,0):
   mdat=""
   c=(639,0)
   while sdic[c[0]][c[1]]!=(-1,-1):
     mdat=mdat+chr(mc(c[0],c[1])[0])
     c=sdic[c[0]][c[1]]
 
 #At this point I analyzed the resulting mdat and found every other character was null, so drop those
 #every other characters.
 k=""
 for i in range(1,44623,2):
   k=k+mdat[i]
A short and simple solution

borospeti 01:55, 2 Mar 2006 (CET)

Short, but not too fast :-) As a sideeffect, creates a new image showing all visited pixels.

 import Image
 
 a = Image.open("./maze.png")
 b = Image.new("RGB",(641,641))
 
 white = (255,255,255,255)
 mark = (0,0,100)
 
 start = (639,0)
 end = (1,640)
 
 path = []
 
 (x,y) = start
 path.append((x,y))
 b.putpixel((x,y),mark)
 while (x,y)!=end and len(path)>0:
         if a.getpixel((x,y+1))!=white and b.getpixel((x,y+1))!=mark:
                 y+=1
                 path.append((x,y))
                 b.putpixel((x,y),mark)
         elif a.getpixel((x-1,y))!=white and b.getpixel((x-1,y))!=mark:
                 x-=1
                 path.append((x,y))
                 b.putpixel((x,y),mark)
         elif a.getpixel((x,y-1))!=white and b.getpixel((x,y-1))!=mark:
                 y-=1
                 path.append((x,y))
                 b.putpixel((x,y),mark)
         elif a.getpixel((x+1,y))!=white and b.getpixel((x+1,y))!=mark:
                 x+=1
                 path.append((x,y))
                 b.putpixel((x,y),mark)
         else:
                 path = path[:-1]
                 (x,y) = path[-1]
 res=[]
 for p in path[1::2]:
         res.append(a.getpixel(p)[0])
 f=open('maze.zip','wb')
 f.write("".join(map(chr, res)))
 f.close()
MS Paint Solution

Well, this is my answer to the claims in the forum, that it will take an year to solve the maze with Microsoft Paint. We know from the theory that if there is a path through a maze then that path separates the maze in two disjoint domains. We can call them the "blue" and the "green" domain (the names are arbitrary). So what I basically did was to pick up the green (0,255,0) color in MS Paint, switch to the Flood Fill tool and click on an arbitrary white point. Luckily for me the were no closed loops inside the maze and all the walls in both domain form two singly connected sets. Thus flood filling from a single white point in the maze autmagically colored the walls in the "green" domain in (surprise, surprise) green. Then I picked up the blue color (0,0,255) and clicked on some point inside the remaining white domain. Voila... all the walls in are now either blue or green. Now the solution of the maze is just the set of points that separate the "blue" and the "green" domain - those are points that have both blue and green neighbors (except for the corner points that have only one colored neighbor). Inspecting the result one finds that the path starts at (639,0) and ends at (1,640). Starting from the topmost value point (639,1) follow the path until you hit a crossroad. Then choose the direction that leads to a point that has both green and blue neighbors. Collect the red color components of the points at odd x and odd y coordinates and... Bingo!

One could solve the whole level with MS Paint and a hex editor if there was a way to get the color components out of a pixel point in Paint. But lets save some trouble:

  import Image
  
  GREEN = (0,255,0,255)
  BLUE = (0,0,255,255)
  WHITE = (255,255,255,255)
  
  def isborder(im,x,y):
      green,blue = 0,0
      for (x1,y1) in ((x,y+1),(x-1,y),(x,y-1),(x+1,y)):
          color = im.getpixel((x1,y1))
          if GREEN == color:
              green += 1
          elif BLUE == color:
              blue += 1
      return (green <= 1) and (blue <= 1)
  
  def iswall(im,x,y):
      color = im.getpixel((x,y))
      return (color[1] or color[2])
  
  def whichway(im,x,y):
      ways = [(x1,y1) for (x1,y1) in ((x,y+1),(x-1,y),(x,y-1),(x+1,y)) if not iswall(im,x1,y1)]
      for way in ways:
          if isborder(im,way[0],way[1]):
              return way 
  
  def traverse(im,x,y):
      zipcontent = []
      while True:
          if x%2 and y%2:
              zipcontent.append(chr(im.getpixel((x,y))[0]))
          im.putpixel((x,y),WHITE)
          way = whichway(im,x,y)
          if way is None:
              break
          x,y = way
      return "".join(zipcontent)
  
  im = Image.open("maze-2c.png")
  im.putpixel((639,0),WHITE)
  im.putpixel((1,640),WHITE)
  open("maze.zip","w").write(traverse(im,639,1))
maze-2c.png is the image colored in green and blue with MS Paint.

A Ruby Solution

--Mudboy 09:29, 2 Jun 2006 (MDT)

For anyone out there trying to solve these with ruby here is my attempt. It uses a simple back tracking algorithm and takes about 4-5 seconds to finish. It would probably be faster if I didn't use RMagick to read the pixel data (then again my first attempt took over an hour :).

   require 'RMagick'
   
   include Magick
   
   $DEBUG = false
   
   class Maze
       def initialize(m, width, height, start, finish)
           @maze = m
           @width = width
           @height = height
           @start = start
           @finish = finish
           @path = [] # array of pos
           @visited = []
           @wall = Pixel.from_color('white')
       end
       
       def path
           raise "maze not solved" if @path.empty?
           @path
       end
       
       def solve
           count = 0 # safety count
           
           @pos = @start
           
           while @pos != @finish && count < 100000
               count += 1
               x, y = pos2coord(@pos)
               puts "(#{x},#{y})" if $DEBUG
               down = coord2pos(x, y+1)
               left = coord2pos(x-1, y)
               right = coord2pos(x+1, y)
               up = coord2pos(x, y-1)
               
               if valid?(down)
                   puts 'down' if $DEBUG
                   @pos = down
                   visit(@pos)
               elsif valid?(left)
                   puts 'left' if $DEBUG
                   @pos = left
                   visit(@pos)
               elsif valid?(right)
                   puts 'right' if $DEBUG
                   @pos = right
                   visit(@pos)
               elsif valid?(up)
                   puts 'up' if $DEBUG
                   @pos = up
                   visit(@pos)
               else
                   puts 'bactrack' if $DEBUG
                   @pos = bactrack
                   count -= 1                
               end
           end
       end
       
   
   private
       def coord2pos(x, y)
           (y % @height) * @width + (x % @width) 
       end
       
       def pos2coord(p)
           [p % @width, (p / @width) % @height]
       end
       
       def wall?(pos)
           @maze[pos] == @wall
       end
       
       def valid?(pos)
           !wall?(pos) && !@visited[pos]
       end
       
       def visit(pos)
           @visited[pos] = true
           @path << pos
       end
       
       def bactrack
           @path.pop
           @path.last
       end
   end
   
   img = Image.read('maze.png').first
   
   maze = img.get_pixels(0, 0,img.columns, img.rows)
   
   m = Maze.new(maze, img.columns, img.rows, 639, 410241)
   m.solve
           
   File.open('out.zip', 'w+b') do |f|
       m.path.each do |pos|
           f.write(maze[pos].red.chr) if pos % 2 == 0
       end
   end

Another short and simple solution

--Pinkeye2000 12:16, 25 Jul 2006 (MDT)

This solution is pretty slow, but the code is easy to follow. I tried to think of it as someone walking through the maze with their right hand on the wall.

import Image

def move(x, y, d):
    if d > 3: d -= 4
    
    if d == 0: y -= 1
    elif d == 1: x += 1
    elif d == 2: y += 1
    elif d == 3: x -= 1
    return (x, y)

def findxy(x, y, pix):
    if len(pix) < 2:
        return False
    return (x, y) == pix[-2]

WHITE = (255,255,255,255)
im = Image.open("maze.png")
(x, y, d) = (639, 0, 2)
pix = [(x, y)]

while y < 640:
    if im.getpixel(move(x, y, d+1)) != WHITE:
        d += 1
        if d > 3: d = 0
    else:
        while im.getpixel(move(x, y, d)) == WHITE:
            d -= 1
            if d < 0: d = 3

    (x, y) = move(x, y, d)
    if findxy(x, y, pix):
        pix = pix[:-1]
    else:
        pix.append((x,y))
   
pk = []
usepix = False
for xy in pix:
    if usepix: pk.append(chr(im.getpixel(xy)[0]))
    usepix = not usepix

f = open("maze.zip", "wb")
f.write("".join(pk))
f.close()
An extremely short and somewhat simple solution

--DanielPitts 14:11, 01 Aug 2006 (PDT)

This solution utilizes some of pythons nice language syntaxes to help minimize lines of code. The algorithm is simple depth-first-search, non-recursive.

Note that the short-circuit evaluation is important for two reasons. First, If we go up before down, we'll die at the top of the image. Second, the stack.pop() should only be called if no other path is found.

Note2: The solution I submitted before had a few bugs in it. This one works, and is smaller. I tried to minimize non-blank lines of code.

 from Image import open
 
 maze, dest, (x,y), stack, tryMove = open("maze.png"), (1,640), (639,1), [], (lambda dx,dy: (maze.getpixel((x+dx, y+dy))[2] == 0 and (x+dx, y+dy, 0)))
 
 while (x,y) != dest:
         maze.putpixel((x,y), (maze.getpixel((x,y))[0], 0, 255, 255))
         stack.append((x,y, maze.getpixel((x,y))[0]) )
         x,y,tmp = tryMove(-1,0) or tryMove(1,0) or tryMove(0,1) or tryMove(0,-1) or (stack.pop() and stack.pop())
 
 file("maze.zip", "wb").write("".join(map(lambda (x, y, r): chr(r), filter(lambda (x,y,r): (x^y)&1==0, stack))));
Breadth-first graph-building

Breadth-first is certain to get the shortest solution even if the maze is multiply-connected, depth-first isn't. (In this case it doesn't matter, but I wouldn't like to check that by inspection!)
By starting your search at the exit, you can build a directed graph in which each reachable position in the maze points to the adjacent position that's closer to the exit.
You can avoid special cases in the search code by prefilling bits of the graph so that the search hits these cases instead of leaving the maze.
These ideas lead to the following approach:

directions = [(0,1), (0,-1), (1,0), (-1,0)]
white = (255,) * 4
w,h = maze.size
exit = (1, h-2)
queue = [exit]
graph = {exit: (1, h-1), (1, h-1): 'exit', (w-2,0): 'entrance'}
while queue:
    pos = queue.pop(0)
    for d in directions:
        new_pos = (pos[0] + d[0], pos[1] + d[1])
        if not graph.has_key(new_pos) and maze.getpixel(new_pos) != white:
            graph[new_pos] = pos
            queue.append(new_pos)
pos = (w-2, 1)
path = []
while pos != 'exit': path.append(maze.getpixel(pos)[0]); pos = graph[pos]
open('maze.zip','wb').write("".join(path[::2]))
Solved with Perl, AI::Pathfinding::AStar and GD

The main problem I had was that if you don't explicitly tell GD the PNG is a "truecolour", the raw Red channel values are wrong. The maze was easy.

Also, findPath() crashed, so the less attractive (but working) findPathIncr() was used.

package MyMaze;
use base AI::Pathfinding::AStar;
use GD;

sub new {
    my ($class, $img) = @_;
    my $self = {};
    # this function returns a boolean for whether a suggested [x,y] is valid:
    # - it is within the bounds of the picture
    # - it is not the colour of the wall (white)
    my $wall_colour = $img->colorClosest(255, 255, 255);
    $self->{is_path} = sub { $_[0]->[0] >= 0 && $_[0]->[0] < $img->width() &&
			     $_[0]->[1] >= 0 && $_[0]->[1] < $img->height() &&
			     $img->getPixel(@{$_[0]}) != $wall_colour };
    return bless $self, $class;
}

# returns all valid neighbour nodes to this node - try E, S, W, N of here
sub getSurrounding {
    my ($self, $here, $target) = @_;
    my ($x, $y) = split /,/, $here;
    return [map  { ["$_->[0],$_->[1]", 1, 1] }
	    grep { $self->{is_path}($_) }
	    [$x+1, $y], [$x, $y+1], [$x-1, $y], [$x, $y-1]
    ];
}

# traverse the maze from (639,0) to (1,640)
my $src = GD::Image->newFromPng("maze.png", 1);
my $maze = MyMaze->new($src);
my $state; do {
    $state = $maze->findPathIncr("639,0", "1,640", $state, 10000)
} while ($state->{path}->[-1] ne "1,640");

# save the red component of odd-numbered coords on the traversed path
my @out = map  { ($src->rgb($src->getPixel($_->[0], $_->[1])))[0] }
          grep { $_->[0] % 2 && $_->[1] % 2 }
          map  { [split/,/] } @{$state->{path}};
open(FH, ">maze.zip") && print(FH pack 'C*', @out) && close FH;

# draw the traversed path in blue and save as traversed.png
my $blue = $src->colorAllocate(0,0,255);
map { $src->setPixel(split(/,/), $blue) } @{$state->{path}};
open(FH, ">traversed.png") && print(FH $src->png()) && close FH;
Kyz 14:13, 19 Apr 2010 (PDT)

---------------------------------------------------
Well, this is extremely easy if you get the clues.

At first, you have to find the waves. There are wave files from "lake1.wav" to "lake25.wav" in the directory.

So you download them all (for which you can already use Python:)

import urllib
template = "http://butter:fly@www.pythonchallenge.com/pc/hex/lake%i.wav"
for i in range(1, 26):
    urllib.urlretrieve(template % i)
Okay, now you have them, but they all sound relatively ugly. You know that you must combine them in some way because the puzzle image suggests it. But how?

There are two hints:

Hint one: "imagine how they sound ..."
Hint two: "can you see the waves"
The waves are images! The image data is raw RGB, and starts where the wave data begins.

 >>> import wave
 >>> lake1 = wave.open('lake1.wav','r')
 >>> lake1.getnframes()
 10800
 >>> lake1.getsampwidth()
 1
The wave has 10800 frames of size 1 byte each. Every 3 frames define 1 pixel (RGB), so there are 3600 pixels in each file. It makes sense to guess that it is 60x60.

import Image
for i in range(1, 26):
   Image.fromstring("RGB", (60, 60),
                    wave.open("lake%i.wav"%i).readframes(10800)).show()
That gave me 25 xv windows which I could arrange as I liked. There is the word "decent" written over the new picture.

Contents [hide]
1 Combining images via program
2 All-in-one solution
3 Shell one-liner
3.1 Shell using NetPBM tools
4 GUI file manager solution
Combining images via program

Unfortunately, on Windows show() doesn't open new windows -- you get one little piece of the puzzle at a time. That's enough to recognize that this is again a picture of the lake, but with some word written over it.

Because doing the simplest thing that could possibly work doesn't always fail ;-), I thought I'd try laying the pieces out in a 5x5 grid, taking the .wav files in order, left to right, top to bottom. And that worked! The code is simple, but possibly hard to understand:

import wave, Image
pieces = []
for i in range(1, 26):
    f = wave.open("lake%d.wav" % i, "rb")
    pieces.append(f.readframes(f.getnframes()))
    f.close()

combined = []
for i in range(0, 25, 5): # row i//5 comes from pieces i:i+5
    for j in range(60):   # 60 pixels tall
        for k in range(5): # take a row of 60 pixels from each piece
            combined.append(pieces[i+k][180*j:180*(j+1)])
im = Image.fromstring("RGB", (300, 300), "".join(combined))
im.save("decent.jpg")
This way is easier to understand:

im = Image.new("RGB", (300, 300))
for y in range(5):
    for x in range(5):
        im.paste(Image.fromstring("RGB", (60, 60), pieces.pop(0)),
                 (60*x, 60*y))
im.show()
All-in-one solution

Here is a from 0-to-image solution that combines the above techniques into one snippet of code:

>>> import urllib, wave, Image
>>> from cStringIO import StringIO
>>> canvas = Image.new('RGB', (300, 300))
>>> url = "http://butter:fly@www.pythonchallenge.com/pc/hex/lake%i.wav"
>>> for i in range(25):
...     wav = wave.open(StringIO(urllib.urlopen(url % (i + 1)).read()))
...     piece = Image.fromstring('RGB', (60, 60), wav.readframes(10800))
...     canvas.paste(piece, ((i % 5) * 60, (i / 5) * 60))
...
>>> canvas.show()
Pretty much the same, but I didn't use the wave-module and first calculated the boundingboxes with list comprehension:

 import math, urllib, Image
 
 BASEURL = "http://butter:fly@www.pythonchallenge.com/pc/hex/"
 WAV_HEADER_LEN = 44
 NUM_FRAGMENTS = 25
 FRAG_SIZE = 60
 
 width = height = int(math.sqrt(NUM_FRAGMENTS)) * FRAG_SIZE
 
 output = Image.new("RGB", (width, height))
 bboxes = [(x, y, x+FRAG_SIZE, y+FRAG_SIZE)
               for y in range(0, height, FRAG_SIZE)
               for x in range(0, width,  FRAG_SIZE)
 ]
 
 for i in range(NUM_FRAGMENTS):
       data = urllib.urlopen(BASEURL + "lake%d.wav" % (i+1)).read()
       fragment = Image.fromstring("RGB", (FRAG_SIZE, FRAG_SIZE), data[WAV_HEADER_LEN:])
       output.paste(fragment, bboxes[i])
 
 output.show()

Shell one-liner

borospeti 13:04, 2 Mar 2006 (CET)

Using wget, sox, and ImageMagick (split into four lines for convenient reading :-). (sox is actually stripping the header only)

 for i in `seq 1 25`; do wget -q --user=butter --password=fly http://pythonchallenge.com/pc/hex/lake$i.wav;  \
                      sox lake$i.wav -u -b -t raw lake$i.raw ;                                               \
                      convert -size 60x60 -depth 8 RGB:lake$i.raw lake$i.png; done;                          \
 montage lake?.png lake??.png -geometry +0+0 lake.png
Shell using NetPBM tools
#!/bin/bash
x=0; y=0
ppmmake black 300 300 >O
for n in {1..25}
do
  wget -O- http://butter:fly@www.pythonchallenge.com/pc/hex/lake$n.wav | \
    rawtoppm -headerskip 44 -rgb 60 60 >A
  pnmpaste A $x $y O >T
  mv T O
  x=$((x+60)); if [ $x -eq 300 ]; then x=0; y=$((y+60)); fi
done
pnmtopng O >output.png
rm A O
Kyz 06:01, 13 May 2010 (PDT)

GUI file manager solution

After converting the WAV-s to PNG (or JPG) by any of the above methods you can use the following way to get an idea of the whole image:

On Windows XP - switch to Thumbnails view and resize the window until the thumbnails come in 5x5 On GNOME - put your images on the Desktop and lay the thumbs in 5x5
___________________________________________
Contents [hide]
1 Intro
2 The intended approach
3 Unintended approach #1: use a different unzipper
4 Unintended approach #2: use a different gif viewer
5 Unintended approach #3: hack the CRC
6 Unintended approach #4: bypass the CRC
7 Possible cure
Intro

After having apologized to Leopold...

echo Sorry | mail -s Sorry leopold.moz@pythonchallenge.com
Or, the pythonic way:

>>> import email.Message, smtplib
>>> apology = email.Message()
>>> apology.add_header('To', 'leopold.moz@pythonchallenge.com')
>>> apology.add_header('From', "your email address")
>>> apology.add_header('Subject', 'Apology')
>>> apology.set_payload('Sorry!')
>>> print apology.as_string()
To: leopold.moz@pythonchallenge.com
From: your email address
Subject: Apology

Sorry!

>>> server = smtplib.SMTP('localhost')
>>> server.sendmail(apology['from'], apology['to'], apology.as_string())
{}
>>> server.quit()
He gives you an md5 for the corrupted zip file you found earler on the maze level (mybroken.zip). Eventually the zip does decompress to give a GIF saying "speed". Combine with the "boat" from the page, et voila!

The intended approach

Many zip programs refuse to extract mybroken.gif from mybroken.zip, because of a CRC error. For example, Python's zipfile module will not, and neither will WinZip. You have to repair the zip then.

Leopold's "Would you believe what one mistake can lead to?" suggests that just one byte is corrupted, and the md5 he supplies gives a systematic way to find it, just by trying all one-byte substitutions until the md5 checksum matches:

import md5, array

def sub(data, good_md5):
    allchars = map(chr, range(256))
    for i, oldch in enumerate(data):
        for newch in allchars:
            data[i] = newch
            if md5.new(data).hexdigest() == good_md5:
                return True
        data[i] = oldch
    return False

data = array.array("c", open("mybroken.zip", "rb").read())
sub(data, "bbb8b499a0eef99b52c7f13f4e78c24b")
f = open("repaired.zip", "wb")
f.write(data)
f.close()
Of course the same can be done by slicing & dicing the data as a big string; `array` is pleasant here because it allows mutating one character at a time.

Unintended approach #1: use a different unzipper

Many other zip programs don't refuse to extract mybroken.gif from the corrupt mybroken.zip. And then:

Unintended approach #2: use a different gif viewer

Many gif viewers don't display mybroken.gif intelligibly if it's extracted via #1 or #3 without repairing the zip file first. For example, PIL can't show the broken gif at all, and a variety of viewers on Windows show just the top part of the broken gif, down to just a few of the first few rows of blue pixels. But other gif viewers do show it, some intelligibly enough to read "speed", and some almost perfectly. IrfanView is a cute example of a viewer that shows both behaviors, depending on seemingly irrelevant details of how the gif is viewed.

Unintended approach #3: hack the CRC

The zip file can also be "repaired" by finding the two places in the file where the expected 4-byte CRC is stored, and replacing it with the actual 4-byte CRC (many zip programs report both CRCs, so this info is easy to get). This leads back to #2: mybroken.gif is still corrupt then, but that may not matter.

Unintended approach #4: bypass the CRC

import zipfile, zlib

zip = zipfile.ZipFile('mybroken.zip')
inf = zip.getinfo('mybroken.gif')
off = inf.file_offset
len = inf.compress_size
zip.close()

src = file('mybroken.zip','rb')
src.seek(off)
dat = src.read(len)
src.close()

gif = zlib.decompress(dat, -15)

file('mybroken.gif','wb').write(gif)
Possible cure

Dfsmith suggests: This would have been more apropos if the zip had been encrypted, so that the picture would be invisible without the md5 correction. Next time Leopold!

_______________________________________________
Lots of twists here! I love this level. First get the obvious file and open it:

import urllib
urllib.urlretrieve("http://butter:fly@pythonchallenge.com/"
                   "pc/hex/zigzag.gif", "zigzag.gif")
import Image
im = Image.open("zigzag.gif")
Poking around reveals that it has a 256-color palette, all colors have the same R, G and B values, every palette color is used in the picture, and every R (or B or G -- same thing) value appears in the palette. Verification:

p = im.getpalette()
for i in range(0, len(p), 3):
    assert p[i] == p[i+1] == p[i+2] # R==G==B in each palette color
p2rgb = p[::3] # maps palette index to its R value
assert len(set(p2rgb)) == 256 # all R values appear in palette
assert len(im.getcolors()) == 256 # all palette colors are used
More, staring at im.histogram() shows that all 256 colors are used often, which suggests there may be compressed data hiding in this picture. But where? There's nothing that "looks like" a compressed data header at either end of the file.

Recalling the "between the tables" page title, it's natural to look at the pixel palette indices and R values for the first few pixels, wondering whether those are "the tables" in question:

>>> pdata = im.getdata()
>>> for i in range(10):
...     p = pdata[i]
...     print "%3d %3d" % (p, p2rgb[p])
215 208
208 203
203  12
 12 254
254  60
 60 139
139  72
 72  66
 66 189
189 127
That's sure suggestive, but unclear of what ;-). The R value of a pixel is the palette index of the next pixel, over and over, zigzag-ing back and forth. But printing out the same stuff for a lot more pixels shows that the pattern isn't rigid, and the exceptions turn out to be the key. More, the exceptions are key in two ways: both the pixel positions at which there are exceptions, and the "unexpected" values, are crucial. Gathering both:

pdata = im.getdata()
exceptions = []
expected = None
indices = []
for i, p in enumerate(pdata):
    if expected is not None and p != expected:
        exceptions.append(p)
        indices.append(i)
    expected = p2rgb[p]
At first I didn't gather the indices, and stopped after finding just the first two exceptions. Those "spelled out" BZ, which sure seemed to say this might be the way to get compressed data out! Now that we have all the exceptions:

bzdata = "".join(map(chr, exceptions))
import bz2
bzexpanded = bz2.decompress(bzdata)
This compressed very well! 9464 bytes of exception data expanded to 70644 bytes of maddening silliness: seemingly endless repetitions of ../ring/bell.html and various Python keywords.

After staring at that a while, I figured I was missing something ;-) I figured it couldn't hurt to draw a picture, made up of blue pixels at the indices where exceptions occured:

im2 = Image.new("RGB", im.size)
colors = [(255, 255, 255)] * len(pdata)
blue = 0, 0, 255
for i in indices:
    colors[i] = blue
im2.putdata(colors)
im2.show()
And that gives a rebus, clearly saying "not keyword", with a "busy?" taunt at the bottom. LOL! BTW, it's much harder to see the taunt if you, e.g., fiddle the pixels in the original gif -- too much surrounding noise.

Removing the keywords from bzexpanded is easy via several methods; here's a particularly pleasant way:

allwords = bzexpanded.split()
import keyword
oddballs = set(allwords) - set(keyword.kwlist)
That gives a set of three strings. The login box says "the order matters", and that's easy enough to guess, or to compute:

for word in allwords:
    if word in oddballs:
        print word
        oddballs.remove(word)
        if not oddballs:
            break
which prints:

../ring/bell.html
repeat
switch
zig-zag solution

Here's another way (perhaps the intended one) to find the bzip2 by explicitly using the zigzag . (Actually finding the "BZh" string and finding that it was unique in the file was the first thing I did in that level ;-))

There are 5 closed cycles in the palette, which result in these lists:

l = [
 [0, 37, 21, 159, 228, ... (149 items)],
 [2, 162, 74, 52, 82, ...  (40 items)],
 [6, 9, 156, 98, 197, ...  (37 items)],
 [7, 41, 223, 117, 80, ... (9 items)],
 [16, 248, 233, 51, 84, ... (21 items)]
]
They are collected by the following code:

   p = list(im.global_palette.palette[::3])
   po = map(ord, p)
   l = []
   g = {}
   for i in range(256):
       if i not in g:
           group = len(l)
           t = [i]
           g[i] = group
           n = po[t[-1]]
           while n not in t:
               t.append(n)
               g[n] = group
               n = po[t[-1]]
           l.append(t)
The image contains those sequences in arbitrary order and length. It can be considered as a sequence of the lists (or tables) built above. Every time we enter a new table, a direction change of our zig-zag-line is reached, we just memorize that byte and get finally the bzip2:

   s = im.tostring()
   r = []
   while s:
       o = ord(s[0])
       tl = l[g[o]]
       i = tl.index(o)
       table = "".join(map(chr, tl[i:] + tl[:i]))
       # iterate as long as possible over this table
       while s.startswith(table):
           table += table
       # find the longest match
       i = len(table)
       while i > 0:
           if s.startswith(table[:i]):
               break
           i -= 1
       # remove that beast and keep the edge
       s = s[i:]
       r.append(s[0:1])
   words = bz2.decompress("".join(r)).split()
The code is neither fast nor nice, but I hope it explains the intention of the level better (as understood by me :-)

Desperation

I missed the "not keyword?" clue and ending up executing:

import urllib2
auth_handler = urllib2.HTTPBasicAuthHandler()
opener = urllib2.build_opener(auth_handler)
for u in keywords:
   for p in keywords:
        try:
            auth_handler.add_password('the order matters', 'www.pythonchallenge.com', u, p)
            opener.open('http://www.pythonchallenge.com/pc/ring/bell.html')
            print u,p
            raise StopIteration
        except urllib2.HTTPError:
            pass
(Hundreds of HTTP requests, so don't try this just for fun!) Gareth Rees 09:01, 18 May 2007 (MDT)

In Perl with GD

#!/usr/bin/perl -w
use strict;
use GD;
use LWP::Simple;
use Compress::Bzip2 qw(decompress_init);

# load the image
my $url = 'http://butter:fly@www.pythonchallenge.com/pc/hex/zigzag.gif';
my $src = GD::Image->new(get($url));

# get the full palette (all colours are grey, so red component will do)
my @palette = map { ($src->rgb($_))[0] } 0..255;

# go through the image pixel by pixel. The shade of grey of a pixel
# usually predicts the index of the next pixel. Keep a collection of
# the pixel values for which this prediction is wrong, these form a
# BZ2 compressed stream. Also draw on the picture - correct prediction
# is white, wrong prediction is black.

my $white = $src->colorClosest(255, 255, 255);
my $black = $src->colorClosest(0, 0, 0);
my $expected = undef;
my $data = '';
for my $y (0 .. $src->height() - 1) {
    for my $x (0 .. $src->width() - 1) {
	my $idx = $src->getPixel($x, $y);
	if (defined $expected && $idx != $expected) {
	    $data .= chr $idx;
	    $src->setPixel($x, $y, $black);
	}
	else {
	    $src->setPixel($x, $y, $white);
	}
	$expected = $palette[$idx];
    }
}

# save the resulting b/w image
open(FH, ">out.gif") && print(FH $src->gif()) && close FH;

# decompress BZ2 data
my $stream = decompress_init();
my $out = $stream->add($data) . $stream->finish();

# weed out the python keywords from the result
my %keyword = map { $_ => 1 } qw(and del from not while as elif
global or with assert else if pass yield break except import print
class exec in raise continue finally is return def for lambda try);
my %seen;
for (split /\s+/, $out) {
    print "$_\n" unless $keyword{$_} || $seen{$_}++;
}
Kyz 05:45, 13 May 2010 (PDT)

_________________________________________________
We are shown a PNG shot of a waterfall lake, and the clues say 'many pairs ring-ring', 'RING-RING-RING' and 'say it out loud'. Apparently the "ring-..." business is a hint to look at the green pixels, although I can't hear "green" in that either ;-)

Themule: Try and say it continuously for 20 seconds as fast as you can... UncleTimmy I did ;-)

The PNG looks not quite right, and examining the green channel shows that it has lots of light and dark alternating across the image. It turns out that almost all pixel pairs differ by exactly 42 in their green values. More precisely, in the green band

abs(pixel(x, y) - pixel(x+1, y)) == 42
for all y and all even x, except for the first 24 even x at y=180.

Of course, the exceptions usually hide the data. Let's extract that message then:

>>> import urllib, Image
>>> from cStringIO import StringIO
>>> url = 'http://repeat:switch@www.pythonchallenge.com/pc/ring/bell.png'
>>> bell = Image.open(StringIO(urllib.urlopen(url).read()))
>>> green = bell.split()[1]
>>> def paired(data):
...     data = iter(data)
...     while True:
...         yield data.next(), data.next()
>>> message = ""
>>> for a, b in paired(green.getdata()):
...     diff = abs(a - b)
...     if diff != 42:
...         message += chr(diff)
>>> message
'whodunnit().split()[0] ?'
Well, who could be responsible for all the trouble we're in with this challenge? 'thesamet' claims he only makes the riddles, and 'bit4' only had the idea for level 28. But Python was developed by Guido van Rossum of course, and that's who did it. 'guido' is the key to the next level.

From Newfweiler:

The English As A Second Language teacher taught the class about the names of colors, and asked Ricky to make up a sentence using the words "green", "pink" and "yellow."

Ricky said, "The telephone says green green green, so I pink it up and say yellow."

And again in Perl + GD...

use GD;
use LWP::Simple;

getstore('http://repeat:switch@www.pythonchallenge.com/pc/ring/bell.png', 'bell.png');
my $src = GD::Image->newFromPng('bell.png', 1);

for my $y (0 .. $src->height() ) {
    for (my $x = 0; $x < $src->width(); $x += 2) {
        my $d = abs(($src->rgb($src->getPixel($x,   $y)))[1] -
                    ($src->rgb($src->getPixel($x+1, $y)))[1]);
        print chr $d if $d != 42;
    }
}
print "\n";
I had to resort to a Google search for "whodunnit().split()[0]" as I had no idea who Guido van Rossum was, plus I thought the natural answer to a puzzle based around 42 would be "Douglas" (e.g. Douglas Adams) Kyz 09:06, 14 May 2010 (PDT)
__________________________________________
The funny glass-and-magnifier-and-glasses picture is titled 'whoisit.jpg', so we need to guess who it is. Don't try too hard raking your brain on who in the Python community may wear glases, drink Tuborg beer and have an affinity for Tweety though.

The title is 'silence!' and the HTML source code is rather longer than the HTML to render the page. There is a lot of silent whitespace in the form of lines of varying length at the end of the HTML page; the lengths look suspiciously like ASCII codes. Let's see what we can make of it:

>>> url = 'http://repeat:switch@www.pythonchallenge.com/pc/ring/guido.html'
>>> lines = urllib.urlopen(url).read().splitlines()[12:]
>>> data = "".join(map(chr, [len(x) for x in lines]))
It's a bzipped data stream again!

>>> bz2.decompress(data)
"Isn't it clear? I am yankeedoodle!"
yankeedoodle is the key to level 30

Shell one liner

curl -s http://repeat:switch@www.pythonchallenge.com/pc/ring/guido.html | perl -ne 'print chr length $& if /^ *$/' | bzcat
Kyz 09:46, 14 May 2010 (PDT)
_____________________________________--
Grandfather

You are shown a rather explicitly shaped rock, and asked where this is. Some Googling reveals this is the Grandfather Rock on Koh Samui (there is also a Grandmother rock nearby), in Thailand. Clicking on the picture asks for the island name and country, and "kohsamui" + "thailand" takes you to stage two of the challenge.

Mandelbrot

We are shown a Mandelbrot image, and the title asks us if these are UFOs. In the source code we find some parameters, and a good fractal renderer will, when you plug in the coordinates and iteration count, show you the exact same set. However, the Mandelbrot set is plotted on the complex plane, and what the page source says is the "top" value should be the "bottom" value instead (UncleTimmy believes that's an error in the puzzle).

There's a good clue that we may need to generate the same image ourselves: the color palette doesn't use any index above 127 (e.g., use PIL's .getcolors() method), and the page source contains iterations="128". We didn't need to know the number of iterations unless we need to program it ourselves -- and, since it's a GIF (lossless) format, we expect that exact pixel values are important.

A Mandelbrot loop is easy to write, but you have to take care with coordinates. This rectangle is in the upper right quadrant of the complex plane (the real and imaginary components are both positive), and values along the imaginary axis increase upwards; graphics coordinates have y values increasing downwards, so we have to generate y's "in reverse" order to make the coordinate systems match as intended:

>>> import urllib, Image, cStringIO
>>> url = 'http://kohsamui:thailand@www.pythonchallenge.com/pc/rock/mandelbrot.gif'
>>> ufos = Image.open(cStringIO.StringIO(urllib.urlopen(url).read()))
>>> def mandelbrot(left=0.34, bottom=0.57, width=0.036, height=0.027,
...                max=128, size=(640, 480)):
...     xstep = width / size[0]
...     ystep = height / size[1]
...     for y in xrange(size[1] - 1, -1, -1):
...         for x in xrange(size[0]):
...             c = complex(left + x * xstep, bottom + y * ystep)
...             z = 0+0j
...             for i in xrange(max):
...                 z = z * z + c
...                 if abs(z) > 2:
...                     break
...             yield i
...
>>> mandel = ufos.copy() # We can reuse the type, size and palette
>>> mandel.putdata(list(mandelbrot()))
>>> mandel.show()
Yup, that looks the same, at first glance anyway. Let's compare the two for differences:

>>> differences = [(a - b) for a, b in zip(ufos.getdata(), mandel.getdata()) if a != b]
>>> len(differences)
1679
>>> print set(differences)
set([-16, 16])
Bingo! Differences now holds a rather odd number of diversions from the Mandelbrot set, with only -16 and +16 differences. With the <restrlink> we discover that it is the product of two primes:

>>> factor(len(differences))
[23, 73]
Would this be the hidden message?

Alien Message?

If we plot this out to a 23, 73 image it does hold an interesting image:

>>> plot = Image.new('L', (23, 73))
>>> plot.putdata([(i < 16) and 255 or 0 for i in differences])
>>> plot.resize((230, 730)).show()
Would this be a message from the stars? If it reminds you of the Voyager and Pioneer spacecrafts, you wouldn't be too far off. It is, in fact, the message sent by humanity to the stars through the Arecibo telescope. arecibo is the key to the next level. We found the message as it was sent to the stars by the telescope, as a stream of binary information meant for alien consumption.
_______________________________________________
Contents [hide]
1 By Hand
2 Careful backtracking
3 Excruciatingly subtle brute force
4 Readable yet fast?
5 Kader's solution :-)
By Hand

It is possible, with graph paper, but takes a long time. A 32x32 puzzle might take a few days for a novice. When solving by hand, use a system to mark filled and non-filled spaces. For instance, put an 'X' through known non-filled spaces, and fill in filled spaces. That way, blank squares are ones that you don't know about yet.

For practice, these puzzles are printed in GAMES magazine as Paint-By-Numbers puzzles, and published by Conceptis Puzzles as Pic-a-pix. There are free samples online at http://www.conceptispuzzles.com/products/picapix/index.htm. GAMES Magazine is great for flights, especially when you can't turn on your laptop, which is why it is sold in almost every airport magazine rack. Plus, it is a rich repository of logic-based puzzle which may come up in future challenges...

Careful backtracking

I am currently aware of two approaches to solving etch-a-s[ck]etch (AKA pic-a-pix) puzzles.

One approach calculates the constraints on the placement of each segment and iteratively makes them more restrictive based on the changes made in the previous iteration. (I hope I am describing this correctly). This approach is fast even for large puzzles, and is the one implemented in the Javascript code that you see running after you solve the riddle.

The other, more naive, approach is to try placing a segment in all possible positions and use recursion and backtracking to find the solution. This is the approach taken by the Python program below.

When faced with ambiguity, the first approach will quit leaving an island of undecided squares. The backtracking approach, however, will find a solution, or enumerate all solutions if forced to backtrack.

Note that some of the design decisions I made do not agree with the rules of good software engineering, like using global variables and avoiding objects. The reason for this is the desire to keep the code as readable and compact as possible. If you want to copy the code and include it in a larger program, you better change these things first.

#
# Solving an etch-a-sketch puzzle.
# bit4, June 2005.
#

import sys

# Puzzle representation:
#   rows = [[3,1],[4],[],...] -- The labels next to each row.
#   cols = [[1,2,1],[3],[],...] -- The labels next to each column.
# Terminology:
#   Square: the smallest element of the grid. A square can be painted
#          (filled, black, 1) or blank (empty, white, 0).
#   Segment: one consecutive block of painted squares. Each number in the puzzle
#          description represents one segment.
#   Row: a horizontal strip of squares spanning the full width of the grid.
#   Column: a vertical strip of squares spanning the full height of the grid.
#   Bar: a generic term for either a row or a column.
# Data structures used for solving:
#   col_maxs = the same structure as 'cols'; contains the maximal starting
#         row number possible for each vertical segment. Precalculated at
#         the start of the process.
#   row_maxs = the same structure as 'rows'; contains the maximal starting
#         column number possible for each horizontal segment. Precalculated
#         at the start of the process.
#   grid = contains the currently tested solution as a map of the board.
#         This is a list of lists of ints. 0 represents an empty square,
#         1 represents a filled square.
#   vseg_positions = the same structure as 'cols'; contains the currently tested
#         solution as the starting row number for each vertical segment.
#   row_constraints = contains constraints imposed by the row definitions
#         and the currently tested solution.
#         It has the same structure as grid, but contains 0 for "must be 0",
#         1 for "must be 1" and 2 for "don't care".
# The algorithm:
#  Treat all the vertical segments as one long list, starting at the topmost
#  segment of the left column, going down, then to the top of the 2nd column,
#  etc.
#  Start at the first segment and try each possible position for it in turn.
#  Every time a square is set to 1 or to 0, check it against the constraints
#  imposed by the row. If there is a contradiction, backtrack and try the
#  next position. Else (no contradiction), continue painting the segment.
#  When a segment is successfully placed in the grid, recursively find a
#  placement for the rest of the segments.
#  When the last segment has been placed, we found a solution.
#

MUST_BE_0, MUST_BE_1, MAY_BE_EITHER = 0, 1, 2 # Values for /row_constraints/

def load_etch(fname):
    """
    Load the puzzle txt file. Returns cols,rows.
    /cols/ and /rows/ are lists of lists of ints.
    """
    lines = open(fname).readlines()
    # get rid of newline chars and empty lines
    lines = filter(lambda line: line != "", [x.strip() for x in lines])
    # Find where the section boundaries are
    for i, line in enumerate(lines):
        if 'oriz' in line:
            horiz_start = i + 1
        if 'ertic' in line:
            vert_start = i + 1
    assert horiz_start < vert_start
    # Convert each one of the two sections to a list of lists of ints
    hlines = lines[horiz_start:vert_start-1]
    vlines = lines[vert_start:]
    rows = [map(int, line.split()) for line in hlines]
    cols = [map(int, line.split()) for line in vlines]
    return cols, rows
 
def make_grid(W, H):
    """Construct and return a grid, filled with zeros."""
    # Beware of shallow copy that would create duplicate references.
    return [[0] * W for row in range(H)] 

def calc_min_positions(bars):
    """
    Return a list of lists of ints filled with the minimal possible positions
    for the segments whose lengths are given in /bars/.
    """
    starts = []
    for bar in bars:
        s = [0]
        for n in xrange(len(bar) - 1):
            s.append(s[n] + bar[n] + 1)
        starts.append(s)
    return starts

def calc_max_positions(bars, min_positions, dim):
    """
    Return a list of lists of ints filled with the maximal possible positions
    for the given bars.
    /dim/ is the bar length.
    """
    max_starts = []
    for nbar in xrange(len(bars)):
        max_starts.append(min_positions[nbar][:])
        slack = dim - (min_positions[nbar][-1] + bars[nbar][-1])
        for nseg in xrange(len(bars[nbar])):
            max_starts[-1][nseg] += slack
    return max_starts

def calc_col_in_row_constraints(col):
    """
    Given that the columns to the left of /col/ contain some partial solution,
    calculate and fill column /col/ of /row_constraints/.
    """
    for row in xrange(H):
        # Count the segments currently in the row part that is left of column /col/
        # and get the length of the rightmost one.
        nsegs = 0
        rightmost_seg_len = 0
        prev_square = 0
        for c in xrange(col):
            if prev_square == 0 and grid[row][c] == 1:
                nsegs += 1
                rightmost_seg_len = 0
            prev_square = grid[row][c]
            rightmost_seg_len += grid[row][c] # Warning: dirty code
        if col == 0:
            in_segment = False
        else:
            in_segment = (grid[row][col-1] == 1)
        if in_segment:
            if rightmost_seg_len == rows[row][nsegs-1]:
                # We are immediately after the end of a segmnet
                row_constraints[row][col] = MUST_BE_0
            else:
                # We are inside a segment
                row_constraints[row][col] = MUST_BE_1
        else:
            if nsegs == len(row_maxs[row]):
                # All segments for this row are already in the grid.
                row_constraints[row][col] = MUST_BE_0
            else:
                if col == row_maxs[row][nsegs]:
                    # We cannot start the next segment more to the right than column /col/
                    row_constraints[row][col] = MUST_BE_1
                else:
                    # We still have the freedom to start the next segment either
                    # here or more to the right.
                    row_constraints[row][col] = MAY_BE_EITHER

def paint_segment(col, startrow, segmentlen):
    """
    Paint the squares of a vertical segment, starting at column /col/,
    row /startrow/, while checking for consistency with the row starts (the
    part of each row that spans from the left edge up to and including
    the just-painted square).
    return True if succeeded, False if this breaks some row constraint.
    """
    for row in xrange(startrow, startrow + segmentlen):
        if row_constraints[row][col] == MUST_BE_0:
            return False
        grid[row][col] = 1
    return True

def clear_bottom_of_col(col, row):
    """
    Fill the bottom part of column /col/, starting at row /row/ with 0s, verifying
    this does not violate any row countraint.
    return True if succeeded, False if failed because it violates some row constraint.
    """
    for r in xrange(row, H):
        if row_constraints[r][col] == MUST_BE_1:
            return False
        grid[r][col] = 0
    return True

def solve_from_segment(col, nseg):
    """
    try to find a solution for segment /nseg/ of column /col/ and recursively
    for all the segments below it and all the segments to the right of this column.
    Returns True if found a solution or False if failed.
    When returning True, /vseg_positions/ and /grid/ contain the found solution.
    When returning False, the head of /vseg_positions/ is intact and the
    tail (from segment /col/,/nseg/ onward) is garbage, and the same goes for /grid/
    """
    if nseg == 0:
        start_row = 0
    else:
        start_row = vseg_positions[col][nseg-1] + cols[col][nseg-1] + 1
    end_row = col_maxs[col][nseg] + 1
    for row in xrange(start_row, end_row):
        vseg_positions[col][nseg] = row # keep this in the global state to ease printing of the solution when it is found.
        # Fill the grid with the current segment while checking consistency with the rows.
        if row > 0:
            # Put a blank above the segment and check it for cosistency with its row.
            # Note that there is no need to fill the whole gap from the previous
            # segment down to the current row because the loop tries the rows in
            # ascending order.
            if row_constraints[row-1][col] == MUST_BE_1:
                return False
            grid[row-1][col] = 0
        # Try to paint the current segment at its corrent position.
        if paint_segment(col, row, cols[col][nseg]):
            # Suceeded in painting this segment.
            if nseg == len(cols[col]) - 1:
                # We are done with the current column.
                if col == len(cols)-1 and nseg == len(cols[col]) - 1:
                    # We've just succeeded with the last segment. A soultion was found!
                    return True
                # Complete the current column by filling below the last segment with blanks
                if not clear_bottom_of_col(col, row + cols[col][-1]):
                    continue
                # We are done with the current column. Initialize the next column.
                next_col, next_segment = col + 1, 0
                # Calculate the list of white/black/dontcare for the squares of the new
                # column, based on the current row starts.
                calc_col_in_row_constraints(next_col)
            else:
                next_col, next_segment = col, nseg + 1
            # Recursively find a solution starting with the next segment.
            # (we can optimize here by skipping all squares up to and including the
            # offending one, but that would complicate the code).
            if solve_from_segment(next_col, next_segment):
                return True
    # No more possible positions for column /col/, segment /nseg/. Backtracking.
    return False

def print_grid(grid):
    """Print the grid in a neat graphical way."""
    for row in grid:
        print "".join(['.#'[square] for square in row]) 
# ----------------------

# Load the puzzle definition
cols,rows = load_etch(sys.argv[1]) # To solve the level, pass 'up.txt' on the command line.

import time
start_time = time.clock()

# Create the data structures we will use for solving.
# These structures are global variables, as this is convenient and reasonable
# for a quick-and-dirty small program.
W,H = len(cols),len(rows)
grid = make_grid(W, H)
row_constraints = make_grid(W, H)
vseg_positions = calc_min_positions(cols)
col_maxs = calc_max_positions(cols, vseg_positions, H)
row_maxs = calc_max_positions(rows, calc_min_positions(rows), W)

# Calculate the list of white/black/dontcare for the squares of the
# first column, based on the rows info.
calc_col_in_row_constraints(0)
# Now go for the kill
if solve_from_segment(0,0):
    print 'Found a solution:'
    print_grid(grid)
else:
    print 'No soultion found.'

print 'Running time:', time.clock() - start_time, 'seconds (not including reading the data).'
Some statistics:

The program is 290 lines long, 116 of which are actual code lines.

On a 2.4GHz Pentium 4 the 32x32 up.txt puzzle takes 1.33 seconds. If you flip the image around the main diagonal by exchanging the rows and the columns in up.txt, the run time is 0.47 seconds.

Excruciatingly subtle brute force

UncleTimmy 00:58, 19 Jun 2005 (MDT)

My first stabs at this were a series of backtrackers, much like the one above. They eventually ran fast enough, but it gave me headaches as the cutoff strategies got subtler, and none of them scaled to larger puzzles (for example, none were able to solve randomly generated 100x100 puzzles in the time I was willing to wait).

Martijn (this puzzle's creator) has a very nice OO constraint-based program, which scales much better. I hope he posts it here. But I have to confess reasoning about that gave me headaches too: what exactly can and can't the collection of local propagation rules, spread across 4 constraint classes, deduce about a line? <restrlink>.

So brute force to the rescue? Given a line in some partially completed state, and a list of run lengths the line must satisfy, there's an obvious way to deduce everything possible about the line: generate the set of all completed lines consistent with its initial state and containing a legal arrangement of all the required runs. Then, for each square of unknown state in the original line, simply check whether every possible completion gives it the same value ("present" or "absent"). If it does, that must be the value in that square. But if not, then we have specific examples of completions giving it both values, so its state must remain unknown.

Couldn't be simpler or "smarter" -- and couldn't be more impractical. Especially for larger puzzles, the number of distinct ways to complete a single line can be truly enormous, more than even a 64-bit integer can express (see <restrlink> on this level's Talk page).

Still, it was so attractively simple-minded I couldn't let it go. The good news is that, after obsessing over it for days, I found an excruciatingly clever way to "get the effect" of generating all possible completions without actually generating more than an "insignificant" fraction of them. This is explained in code comments below, but that's the bad news: I got headaches again just trying to explain it, and the most important parts of this code aren't any easier to understand than any of the other approaches.

Oh well. It's fun to watch, anyway! For several reasons, it gets faster the more it solves, until at the end squares get filled so quickly it's a visual blur. If you want to fiddle the code, note that I left in some expensive sanity checks, but commented out with "##". If something seems to be going wrong, uncomment those and generate random smaller puzzles; the asserts should never trigger.


import Tkinter

UNKNOWN = "grey"
ABSENT  = "white"
PRESENT = "black"

ROW, COL = "row", "col"

def readpuzzle(fname):
    f = open(fname)
    for line in f:
        if "Horiz" in line:
            break

    def append(constraints):
        pieces = line.split()
        if pieces:
            constraints.append(map(int, pieces))
        
    hs = []
    for line in f:
        if "Vert" in line:
            break
        append(hs)
    vs = []
    for line in f:
        append(vs)

    # We should get the same # of occupied squares counting
    # by rows or by columns; this is a strong sanity check.
    assert sum(sum(x) for x in hs) == sum(sum(x) for x in vs)
    return hs, vs

class Solver(Tkinter.Tk):
    def __init__(self, hs, vs, pixelwidth=5):
        Tkinter.Tk.__init__(self)
        self.hs, self.vs = hs, vs
        self.pixelwidth = pixelwidth
        self.nrows, self.ncols = nrows, ncols = len(hs), len(vs)
        self.board = [[UNKNOWN] * ncols for i in range(nrows)]

        pwidth = pixelwidth * ncols
        pheight = pixelwidth * nrows
        image = Tkinter.PhotoImage(width=pwidth,
                                   height=pheight)
        self.image = image
        canvas = Tkinter.Canvas(self, width=pwidth+10,
                                      height=pheight+10)
        canvas.pack()
        canvas.create_image(5, 5, image=image, anchor=Tkinter.NW)
        image.put(UNKNOWN, (0, 0, pwidth, pheight))
        self.update()

    def setpixel(self, i, j, value):
        pw = self.pixelwidth
        px, py = j * pw, i * pw
        self.image.put(value, (px, py, px+pw, py+pw))
        self.update()
        ##raw_input("next")

    def solve(self):
        # `ordered` is a list of all lines.  `changed` is a set of
        # lines that need to be looked at again, because some square
        # in them got resolved due to examining some line in a
        # perpendicular direction.  In general, we prefer to pick the
        # next line from `changed`; `ordered` exists solely to make
        # sure we examine every line at least once.  Note that because
        # a call to dorow() or docol() deduces everything possible to
        # deduce about a line, it's a complete waste of time to call
        # one of those a second time on a line until some square in
        # that line gets resolved due to examining other lines.
        ordered =  [(ROW, i) for i in range(self.nrows)]
        ordered += [(COL, j) for j in range(self.ncols)]
        self.changed = set()
        unknown = self.nrows * self.ncols
        while unknown:
            source = self.changed or ordered
            if not source:
                break
            kind, index = source.pop()
            method = kind is ROW and self.dorow or self.docol
            resolved = method(index)
            unknown -= resolved
        # Verify.
        for i in range(self.nrows):
            resolved = self.dorow(i)
            assert not resolved
        for j in range(self.ncols):
            resolved = self.docol(j)
            assert not resolved
        return unknown

    class EarlyExit(Exception):
        pass

    # "Get the effect" of generating all possible ways of completing
    # `line` with the runs in `constraints`, consistent with `line`'s
    # current state.  Return a list of resolutions:  all (index,
    # value) pairs such that line[index] is UNKNOWN on entry and all
    # possible ways of completing `line` have line[index]==value where
    # value is PRESENT or ABSENT.  This list may, of course, be empty.
    def try_all(self, line, constraints):
        # Map index of UNKNOWN square to its resolved value (if any).
        # `None` means we don't know yet.  Ambiguous indices are
        # removed from the dict (i.e., if at least one completion
        # assigns PRESENT to an index and another assigns ABSENT).
        resolved = {}

        # lrcwp[i] is the length of the longest run starting at
        # line[i] consistent with PRESENT (a mix of PRESENT and
        # UNKNOWN squares).  Similarly, lrcwa[i] is the length of the
        # longest run consistent with ABSENT.
        extent = len(line)
        lrcwp = [None] * extent
        lrcwa = [None] * extent
        cwp = cwa = 0
        for i in xrange(extent - 1, -1, -1):
            value = line[i]
            if value is UNKNOWN:
                resolved[i] = None
                cwp += 1
                cwa += 1
            elif value is PRESENT:
                cwp += 1
                cwa = 0
            else:
                cwa += 1
                cwp = 0
            lrcwp[i] = cwp
            lrcwa[i] = cwa
        if not resolved:
            return []
        lrcwa.append(0)

        # Build a list of constraints.  The odd-numbered positions
        # contain the original constraints (runs of PRESENT squares),
        # and the even-numbered indices represent blanks between runs.

        # minlen[ci] is the minimum number of squares constraint `ci`
        # can occupy; that's also the max # for runs of PRESENT
        # squares.
        ncs = 2 * len(constraints) + 1
        minlen = [1] * ncs # 1 is correct for interior blanks
        minlen[1::2] = constraints
        minlen[0] = minlen[-1] = 0

        # LF[ci] is the Latest Finish position for constraint `ci`.
        # This is computed by fitting every constraint "as far to the
        # right" as possible.
        LF = [None] * ncs
        finish = extent
        for i in range(ncs-1, -1, -1):
            lr = i & 1 and lrcwp or lrcwa
            length = minlen[i]
            while (lr[finish - length] < length or
                   (i & 1 and
                    finish - length >= 1 and
                    line[finish - length - 1] is PRESENT)):
                finish -= 1
            LF[i] = finish
            finish -= length

        tag2outcome = {}
        # All squares in line[:i0] can be filled with the first `ci`
        # constraints.  `inner()` considers all ways of completing the
        # line, with constraint `ci` starting at index `i0`.  Vital
        # subtlety, speeding this by many orders of magnitude: the
        # precise way in which the first `ci` constraints are placed
        # in line[:i0] has no effect on the set of legitimate ways to
        # complete the line.  The set of possible completions (the set
        # of legitimate line[i0:] states) is exactly the same
        # regardless of what line[:i0] looks like. `tag2outcome`
        # records knowledge of outcomes:  if (i0, ci) is not a key, we
        # don't know the outcome yet.  Else the outcome is True or
        # False.  If False, there's no way to complete the line; if
        # True, there's at least one way (and possibly an enormous
        # number of ways).  `inner()` returns true iff there's at
        # least one way to complete the line.  While it's figuring
        # that out, it determines which of the indices in `resolved`
        # can be resolved, and deletes the others.  If it determines
        # that all indices in `resolved` remain ambiguous, it raises
        # EarlyExit.
        def inner(i0, ci):
            tag = i0, ci
            if tag in tag2outcome:
                # We've already considered all possible completions.
                return tag2outcome[tag]
            it_worked = False   # assume it can't be completed

            if ci & 1:
                # Odd -> it's a run.  Can we place it at i?
                value = PRESENT
                n = minlen[ci]
                i1 = i0 + n
                it_worked = lrcwp[i0] >= n and inner(i1, ci+1)
            else:   # ci is even -> this contains blanks
                value = ABSENT
                if ci < ncs - 1:
                    # These aren't the trailing blanks, and are
                    # trickier than those.  We have to consider all
                    # ways of placing one or more blanks here (zero or
                    # more if these are the leading blanks).  `i`
                    # steps over the possible starting positions for
                    # the next run.
                    for i in xrange(i0 + minlen[ci],
                                    min(i0 + lrcwa[i0], LF[ci]) + 1):
                        if inner(i, ci+1):
                            it_worked = True
                            i1 = i
                else:
                    # The trailing blanks are dead easy:  the rest of
                    # the line must be entirely blank.
                    if lrcwa[i0] == extent - i0:
                        it_worked = True
                        i1 = extent

            tag2outcome[tag] = it_worked
            if it_worked:
                for i in xrange(i0, i1):
                    if i in resolved:
                        current = resolved[i]
                        if current is None:
                            # First time a completion touched `i`.
                            resolved[i] = value
                        elif current is not value:
                            # No luck -- another completion gave `i`
                            # the other value; it's still ambiguous.
                            del resolved[i]
                            if not resolved:
                                raise self.EarlyExit

                if ci & 1 == 0:
                    # We can complete the line filling i0:i1 with
                    # blanks, but cannot succeed by filling i0:i2 with
                    # blanks for any i2 > i1.  Therefore we could also
                    # complete the line filling i0+1:i1 with blanks,
                    # i0+2:i1 with blanks, ... or just i1-1:i1 with
                    # blanks, but could not succeed in any of those
                    # cases by trying to fill beyond i1 either.  We
                    # already recorded (in the loop above) that we
                    # would put blanks in those positions, so there's
                    # no point doing any of that again.
                    for i in xrange(i0+1, i1):
                        tag2outcome[i, ci] = True

            return it_worked

        try:
            inner(0, 0)
        except self.EarlyExit:
            pass
        return resolved.items()
 
    # Resolve as many squares in row i as possible, and return the
    # number of squares resolved.
    def dorow(self, i):
        ##print "row", i#, self.hs[i]#, self.board[i]
        row = self.board[i]
        ##orig = row[:]
        resolved = self.try_all(row, self.hs[i])
        for j, value in resolved:
            row[j] = value
            self.setpixel(i, j, value)
            self.changed.add((COL, j))
        ##if resolved:
        ##    nr = self.try_all(row, self.hs[i])
        ##    assert not nr, (i, self.hs[i], orig, row, resolved, nr)
        return len(resolved)

    # Likewise, for column j.
    def docol(self, j):
        ##print "col", j
        board = self.board
        col = [board[i][j] for i in range(self.nrows)]
        ##orig = col[:]
        resolved = self.try_all(col, self.vs[j])
        for i, value in resolved:
            board[i][j] = value
            self.setpixel(i, j, value)
            self.changed.add((ROW, i))
        ##if resolved:
        ##    col = [board[i][j] for i in range(self.nrows)]
        ##    nr = self.try_all(col, self.vs[j])
        ##    assert not nr, (j, self.vs[j], orig, col, resolved, nr)
        return len(resolved)

if 0:  # change to 1 to generate a random puzzle instead
    nrows = 100
    ncols = 100
    from random import randrange
    from itertools import groupby
    board = [[0] * ncols for i in range(nrows)]
    for dummy in xrange(int(nrows * ncols * 1.3)):
        board[randrange(nrows)][randrange(ncols)] = 1
    def sig(xs):
        return [len(list(sub)) for key, sub in groupby(xs)
                               if key]
    hs = [sig(row) for row in board]
    vs = [sig(board[i][j] for i in range(nrows))
          for j in range(ncols)]
    ##print hs, vs
    s = Solver(hs, vs)
else:
    #s = Solver(*readpuzzle("warmup.txt"))
    s = Solver(*readpuzzle("up.txt"))
unknown = s.solve()
print "done", unknown
s.mainloop()
Readable yet fast?

Bit4 17 Jul 2005

Here is a 3rd stab at the problem, but this time trying to make it readable without sacrificing too much speed. I hope I've succeeded. The algorithm is the non-backtracking one, which is supposed to be faster than the backtracking variant, plus the lovely optimization by UncleTimmy as described above, plus a small modification to the order of processing the rows and columns. There are many places this code can be made faster, but all of marginal gain. And one more thing: I avoided using sets to make it run on Python 2.3 too.

Statistics: 154 actual code lines, plus lots of comments = 321 lines total.

Run times: warmup: 0.0053 sec, up.txt: 0.81 sec. Measured on a loaded (sorry) P4 2.4GHz. An arbitrary 55x75 puzzle I found somewhere took 61 seconds, but that doesn't mean much as different puzzles of the same size have largely varying run times. I haven't tried larger puzzles.

#
# Non-backtracking algorithm for solving pic-a-pix puzzles, with UncleTimmy's
# optimization.
# By bit4, July 2005.
#

# Puzzle representation:
#   row_seg_lens -- The labels next to each row as a list of lists.
#                   Example: [[3,1],[4],[2,7,1],...]
#   col_seg_lens -- The labels next to each column as a list of lists.
# The grid dimensions are the lengths of these two lists.
#
# Terminology:
#   Square: the smallest element of the grid. A square can be painted
#          (filled, black, 1) or blank (empty, white, 0) or unknown (None).
#   Segment: one consecutive block of painted squares. Each number in the puzzle
#          description represents one segment.
#   Row: a horizontal strip of squares spanning the full width of the grid.
#   Column: a vertical strip of squares spanning the full height of the grid.
#   Bar: a generic term for either a row or a column.
#
# The algorithm:
#  calculate all possible starting points for each segment, based solely on
#     the lengths of the other segments in the same bar.
#  Loop:
#     Pick a row or a column that has changed since it was last processed.
#     If no such col or row, then break the loop.
#     Delete segment placements that contradict the black/white squares.
#     Based on the new list of possible segment positions, figure out which
#         squares have only one possible coloring and paint them.
#  Print the grid.
#
# Finding segment arrangements in a give bar that contradict some 
# partial painting of squares is essentially a patter matching problem 
# with lots of wildcards. This means that it can take a very long time 
# if done carelessly. UncleTimmy devised a neat optimization for this, 
# that speeds things up enormously. See comments in the code.
#
# Another optimization that cuts teh run time by about half is to estimate
# how much work each bar requires and pick the easiest one in each iteration.
#
# Other than these algorithmic optimizations, the code is not written to be
# efficient, but rather to be readable and easy to understand.
#
# This algorithm may terminate with a partial solution if the puzzle 
# is under-constrained. A contradicting input is detected and raises 
# an exception.
#
# The code does not use sets so it will be able to run on Python 2.3.
#

import sys
import time

WHITE, BLACK = 0, 1                # Color values for painting squares.
CAN_BE_WHITE, CAN_BE_BLACK = 1, 2  # Bit-masks for representing possible colorings of squares.
VERTICAL, HORIZONTAL = 1, 2        # Bar orientations.

def load_etch_puzzle(fname):
    """
    Load the puzzle txt file. Returns a pair (col_seg_lens,row_seg_lens).
    /col_seg_lens/ and /row_seg_lens/ are lists of lists of ints.
    """
    lines = open(fname,'r').readlines()
    # get rid of newline chars and empty lines
    lines = filter(lambda line: line != "", [x.strip() for x in lines])
    # Find where the section boundaries are
    for i in xrange(len(lines)):
        if 'oriz' in lines[i]:
            horiz_start = i + 1
        if 'ertic' in lines[i]:
            vert_start = i + 1
    assert(horiz_start < vert_start)
    # Convert each one of the two sections to a list of lists of ints
    hlines = lines[horiz_start:vert_start-1]
    vlines = lines[vert_start:]
    row_seg_lens = [map(int, hlines[i].split()) for i in xrange(len(hlines))]
    col_seg_lens = [map(int, vlines[i].split()) for i in xrange(len(vlines))]
    return col_seg_lens,row_seg_lens

class Seg:
    # A single segment (one run of black squares)
    def __init__(self, size, places):
        self.placements = places # A list of all possible starting positions for this segment.
        self.size = size # How many squares make up this segment.
    def __str__(self): # for debugging
        return '<seg size=' + str(self.size) + ' p=' + str(self.placements) + '>'

class Bar:
    # A whole row or column. A bar contains several segments.
    def __init__(self, barnum, size, seg_sizes, bar_orientation):
        self.size = size
        self.barnum = barnum
        self.orientation = bar_orientation
        self.is_dirty = True # True iff we need to process this bar again.
        self.done = False # Will become True when all segments in this bar fall into place.
        self.bar = [None] * size # What we know about the color of the squares in this bar (None/WHITE/BLACK).
        self.bar = [WHITE] + self.bar + [WHITE] # Add sentinels to make the code shorter.
        # Calculate all the possible starting points for each segment:
        seg_placements = calc_initial_bar_constraints(size, seg_sizes)
        self.segments = [Seg(seg_size,seg_places) for seg_size,seg_places in zip(seg_sizes,seg_placements)]
        # Add sentinels on both ends to make the code simpler:
        self.segments = [Seg(1,[-2])] + self.segments + [Seg(0,[size + 1])]
    def estimate_processing_effort(self):
        """
        Return some value that can be used as a sort key and that will have
        a small value for bars that can be processed relatively quickly.
        The value I chose to calculate here is the current number of possible
        configurations of segments in this bar.
        """
        return reduce(lambda x,y: x*y, [len(seg.placements) for seg in self.segments], 1)
    def __repr__(self): # for debugging
        return '<bar-' + ' VH'[self.orientation] + str(self.barnum) + ' ' + barpic(self.bar) + ' ' + ' '.join([str(seg) for seg in self.segments[1:-1]]) + '>'

def calc_initial_bar_constraints(bar_size, seg_lens):
    """
    Return a list of lists describing all possible starting points of all
    the segments in the given bar.
    e.g., (10, [3,4]) --> [[0,1,2],[4,5,6]], meaning that the segment of
    len 3 can start at 0, 1 or 2, and the segment of len 4 can start at
    4, 5 or 6.
    """
    nsegs = len(seg_lens)
    # Fill /placements/ with the smallest possible starting point per segment.
    placements = [0]
    for n in xrange(1, nsegs):
        placements.append(placements[-1] + seg_lens[n-1] + 1)
    # Add other possible placements for each segment.
    slack = bar_size - (sum(seg_lens) + nsegs - 1)
    constraints = [range(placements[segnum],placements[segnum]+slack+1) for segnum in xrange(nsegs)]
    return constraints

def paint(bar, crossing_bars, pos, color):
    """
    Paint the given position in the bar. Returns 1 if painted, 0 if was
    already painted with this color, raises an exception if already painted
    with a different color. The intersecting bar is marked as dirty if we
    actually painted a new square.
    """
    if bar.bar[1+pos] == None:
        bar.bar[1+pos] = color
        crossing_bars[pos].bar[1+bar.barnum] = color
        crossing_bars[pos].is_dirty = True # cause re-processing of the affected intersecting bar
        return 1
    if bar.bar[1+pos] != color:
        raise Exception,"black-white contradiction at position %d of bar #%d" % (pos, bar.barnum)
    # This square was already painted with this color.
    return 0

def enum_good_placements(bar, positions, possible_colors, possible_placements, tails_cache):
    """
    Find all segment placements that do not contradict the currently painted squares for
    the given bar. Returns True if at least one full configuration is possible, False if
    all configurations contradict the currently painted squares.

    /positions/ is the recursion accumulator for the positions of the segments.
    Note that /positions/ starts with a sentinel of -2.

    /possible_colors/ is a list of ints representing the squares of the bar. Each number
    is the bitwise OR of values from [CAN_BE_WHITE, CAN_BE_BLACK]. This function updates
    this list with what it can deduce.

    /possible_placements/ is a list of dictionaries: possible_placements[nseg]
    has key /pos/ if /pos/ is a possible placement for segment number /nseg/. This function
    updates the dictionaries in this list with what it can deduce.

    That this function is the bottleneck of the algorithm. for example, a row of len 70
    with only 4 small segments in it requires testing an enormous number of configurations.
    To avoid a large percentage of this work we use UncleTimmy's observation that when given
    a partial solution that ends with segment i in position j, the outcome of trying to
    complete the solution does not depend on how the segments before segment i are arranged.
    So we keep a dictionary with an entry (nseg,pos):True to tell us that we've successfully
    generated all tails starting at segment /nseg/ positioned at square number /pos/, or
    (nseg,pos):False to tell us that we've tried and failed to complete a solution with this
    same starting state. This dictionary is /tails_cache/, which starts empty and is being
    filled here.
    """
    def update_knowledge(bar, positions, possible_colors, possible_placements):
        """
        Given that /positions/ contains a possible placement of the first N segments of /bar/,
        update /possible_colors/ and /possible_placements/ with what /positions/ tells us.
        """
        for nseg0,pos0 in enumerate(positions[1:]):
            possible_placements[nseg0][pos0] = 1
            perv_seg_end = positions[1+nseg0-1] + bar.segments[1+nseg0-1].size
            for i in xrange(max(0,perv_seg_end),pos0):
                possible_colors[i] |= CAN_BE_WHITE
            for i in xrange(pos0, min(bar.size, pos0 + bar.segments[1+nseg0].size)):
                possible_colors[i] |= CAN_BE_BLACK

    if len(positions) == len(bar.segments)-1:
        # We've reached the bottom of the recursion: /positions/ is full.
        after_last_seg = positions[-1] + bar.segments[-2].size
        if BLACK in bar.bar[1+after_last_seg:]:
            # There is a black square after the last segment, so /positions/ contradicts the painted squares.
            return False
        # /positions/ contains a possible full positioning of the segments.
        # Update the possible_colors list and the possible_placemenats dictionaries.
        update_knowledge(bar, positions + [bar.size], possible_colors, possible_placements)
        return True

    # Recursively try to complete all possible solutions that start with /positions/.
    completion_is_possible = False
    nseg = len(positions) - 1
    for pos in bar.segments[1+nseg].placements:
        if pos <= positions[-1] + bar.segments[1+nseg-1].size:
            # This position overlaps the previous segment. Skip it.
            continue
        after_prev_seg,seg_end = positions[nseg] + bar.segments[nseg].size, pos + bar.segments[1+nseg].size
        if BLACK not in bar.bar[1+after_prev_seg:1+pos] and WHITE not in bar.bar[1+pos:1+seg_end]:
            if tails_cache.has_key((nseg,pos)):
                # We've already tried the rest with a different arrangement of the segments
                # preceding nseg. No need to do it again.
                if not tails_cache[(nseg,pos)]:
                    # When we tried to complete /positions/ in the past from the same
                    # starting point as we are now, we had failed. Skip this position.
                    continue

                # When we completed /positions/ in the past we had succeeded and we have
                # already updated the output variables. Any info that is new now is in
                # the head of /positions/, so update the output based only on that part.
                update_knowledge(bar, positions + [pos], possible_colors, possible_placements)
                completion_is_possible = True
                continue

            positions.append(pos)
            can_complete = enum_good_placements(bar, positions, possible_colors, possible_placements, tails_cache)
            del positions[-1]
            tails_cache[(nseg,pos)] = can_complete
            if can_complete:
                completion_is_possible = True
    return completion_is_possible

def process_one_bar(bar, crossing_bars):
    """
    Narrow down the list of possible placements of segments in the given bar, based
    on the painted squares, then find and paint the squares that can be painted black
    or white based on the currently known constraints on the placement of segments.
    No information from other bars is used here.
    Raises an exception if finds a contradiction (that is, if we try to paint a square
    that is already painted with the opposite color).
    """
    segments = bar.segments
    nsegs = len(segments)

    # Filter the possible segment placements based on the painted squares.
    good_placements = [{} for n in xrange(len(bar.segments))]
    possible_colors = [0] * bar.size
    tails_cache = {}
    enum_good_placements(bar, [-2], possible_colors, good_placements, tails_cache)
    for nseg in xrange(len(bar.segments)-2):
        seg = bar.segments[nseg+1]
        new_placements = filter(lambda pos: good_placements[nseg].has_key(pos), seg.placements)
        if new_placements != seg.placements:
            seg.placements = new_placements

    # Paint new sure squares.
    for pos,color in enumerate(possible_colors):
        if color == CAN_BE_BLACK:
            paint(bar, crossing_bars, pos, BLACK)
        elif color == CAN_BE_WHITE:
            paint(bar, crossing_bars, pos, WHITE)

    bar.is_dirty = False
    return

def pick_bar_to_process(rows, cols):
    """Return a dirty bar that is likely to be fast to process."""
    dirty_pairs = [(bar.estimate_processing_effort(),bar) for bar in rows+cols if bar.is_dirty]
    if dirty_pairs == []:
        return None
    work_estimate,bar = min(dirty_pairs)
    return bar

def barpic(squares_list):
    """Return an ASCII-art representation of the given bar, for debugging and for printing the output."""
    display_chars = {None: '?', WHITE: '-', BLACK: '#'}
    return .join([display_chars[s] for s in squares_list])

def print_grid(rows):
    """Print the grid."""
    for row in rows:
        print barpic(row.bar[1:-1])

def put_initial_paint(bars, crossing_bars):
    """Paint the obvious black squares before we start, to shorten the start-up time."""
    for bar in bars:
        for seg in bar.segments[1:-1]:
            for i in xrange(seg.placements[-1], seg.placements[0] + seg.size):
                paint(bar, crossing_bars, i, BLACK)

def main():
    col_seg_lens, row_seg_lens = load_etch_puzzle(sys.argv[1])
    start_time = time.clock()
    W, H = len(col_seg_lens), len(row_seg_lens)
    cols = [Bar(ncol, H, col_seg_lens[ncol], VERTICAL) for ncol in xrange(W)]
    rows = [Bar(nrow, W, row_seg_lens[nrow], HORIZONTAL) for nrow in xrange(H)]
    # Note that every square in the grid is represented twice: once in a column and again in a row.
    # This allows us to flip the grid by simply swapping the cols and rows variables.
    for row in rows:
        row.is_dirty = False
    for col in cols:
        col.is_dirty = False
    put_initial_paint(cols, rows) # This marks some rows as dirty.
    put_initial_paint(rows, cols) # This marks some columns as dirty.
    while True:
        # Pick a bar out of the dirty ones and process it. Try to pick one
        # that is most likely to be fast to process.
        bar = pick_bar_to_process(rows, cols)
        if bar == None:
            break
        if bar.orientation == HORIZONTAL:
            process_one_bar(bar, cols)
        else:
            process_one_bar(bar, rows)
    running_time = time.clock() - start_time

    print 'Result:'
    print_grid(rows)
    print 'Running time:', running_time, 'seconds (not including I/O).'

main()


Kader's solution :-)

aallamaa 5 oct 2008

Here is my solution, it could be coded in a more elegant fashion, and even made using a single integer with each bit matching a line or column instead of a list but here it is

def genv(v,l):
  r=[]
  j=0
  if v:
   if len(v)==1:
    j=1
   for i in range(l+2-len(v)-sum(v)):
    ri=[0]*i+[1]*v[0]+[0]*(1-j)
    if j:
     rr=[[0]*(l-len(ri))]
    else:
     rr=genv(v[1:],l-len(ri))
    r+=[ri+vv for vv in rr]
   return r
  else:
   return [[0]*l]
def genm(v,l):
 mr=[-1]*l
 for i in range(l):
  a=1
  b=0
  for m in v:
   a&=m[i]
   b|=m[i]
  if a==1:
   mr[i]=1
  if b==0:
   mr[i]=0
 return mr

hl="""3 2
8
10
3 1 1
5 2 1
5 2 1
4 1 1
15
19
6 14
6 1 12
6 1 10
7 2 1 8
6 1 1 2 1 1 1 1
5 1 4 1
5 4 1 4 1 1 1
5 1 1 8
5 2 1 8
6 1 2 1 3
6 3 2 1
6 1 5
1 6 3
2 7 2
3 3 10 4
9 12 1
22 1
21 4
1 17 1
2 8 5 1
2 2 4
5 2 1 1
5"""
vl="""5
5
5
3 1
3 1
5
5
6
5 6
9 5
11 5 1
13 6 1
14 6 1
7 12 1
6 1 11 1
3 1 1 1 9 1
3 4 10
8 1 1 2 8 1
10 1 1 1 7 1
10 4 1 1 7 1
3 2 5 2 1 2 6 2
3 2 4 2 1 1 4 1
2 6 3 1 1 1 1 1
12 3 1 2 1 1 1
3 2 7 3 1 2 1 2
2 6 3 1 1 1 1
12 3 1 5
6 3 1
6 4 1
5 4
4 1 1
5"""
vg=[genv([int(z) for z in a.split()],32) for a in vl.split("\n")]
hg=[genv([int(z) for z in a.split()],32) for a in hl.split("\n")]
m=[[-1]*len(vg)]*len(hg)
hgl=vgl=0
while (hgl!=32):
 vgl=sum([len(x) for x in vg])
 hgl=sum([len(x) for x in hg])
 print "vgl %d\t hgl %d" % (vgl,hgl)
 for i in range(32):
  m=genm(vg[i],32)
  for j in range(32):
   if m[j]!=-1:
    hg[j]=[a for a in hg[j] if a[i]==m[j]]
 for i in range(32):
  m=genm(hg[i],32)
  for j in range(32):
   if m[j]!=-1:
    vg[j]=[a for a in vg[j] if a[i]==m[j]]
for l in hg:
 print "".join([str(a) for a in l[0]]).replace("0"," ")
_____________________________________________
Some manipulation of the URL gets you to beer2.png, a square greyscale image showing a light X in the middle of some darker noise. The image is darker at the top and bottom and lighter in the middle.

A textual hint is given:

  If you are blinded by the light,
  remove its power, with its might.
  Then from the ashes, fair and square,
  another truth at you will glare.
This hint is 138 characters long (with linefeeds), the same as the width and height of beer2.png. Maybe it's just a coincidence...

The page title provides another hint:

  33 bottles of beer on the wall
The light/dark bands don't seem to provide any clue at this point.

>>> import Image
>>> puzzle_image_filename = 'beer2.png'
>>> im = Image.open(puzzle_image_filename)
>>> im.size
(138, 138)
>>> im.mode
'L'
The image has mode 'L' (greylevels).

Since the pixel values exhibit no clear patterns, we try to look at the histogram:

>>> im.histogram()
[0, 1532, 232, 0, 0, 0, 0, 963, 189, 0, 0, 0, 0, 724, 329, 0, 0, 0, 0, 549, 243, 0, 0, 0,
 0, 144, 424, 0, 0, 0, 0, 119, 328, 0, 0, 0, 0, 126, 339, 0, 0, 0, 0, 126, 357, 0, 0, 0,
 0, 107, 225, 0, 0, 0, 0, 79, 609, 0, 0, 0, 0, 181, 356, 0, 0, 0, 0, 70, 298, 0, 0, 0,
 0, 23, 164, 0, 0, 0, 0, 26, 354, 0, 0, 0, 0, 47, 341, 0, 0, 0, 0, 139, 257, 0, 0, 0,
 0, 104, 505, 0, 0, 0, 0, 192, 224, 0, 0, 0, 0, 114, 310, 0, 0, 0, 0, 32, 183, 0, 0, 0,
 0, 238, 198, 0, 0, 0, 0, 117, 327, 0, 0, 0, 0, 110, 342, 0, 0, 0, 0, 118, 342, 0, 0, 0,
 0, 145, 323, 0, 0, 0, 0, 152, 324, 0, 0, 0, 0, 161, 323, 0, 0, 0, 0, 175, 317, 0, 0, 0,
 0, 183, 317, 0, 0, 0, 0, 171, 337, 0, 0, 0, 0, 198, 318, 0, 0, 0, 0, 241, 283, 0, 0, 0,
 0, 1348, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0]
Now we see an interesting pattern:

Many pixel values are not used at all, and those that are used are clearly arranged in pairs. The histogram is also nearly flat. It is also easy to see that the number of pairs is 33 - the same number in the page title hint.

A quick check shows that the highest value in use is the one that forms the X sign:

>>> data = list(im.getdata())
>>> largest_used_pixval = max(data)
>>> for i in xrange(len(data)):
...     if data[i] != largest_used_pixval:
...         data[i] = 0
...
>>> out = Image.new('L', im.size)
>>> out.putdata(data)
>>> out.show() # This displays a clear X with no noise around it.
Following the textual hint and struggling for a long while we finally notice that if we remove the highest pair ("remove its power, with its might"), we are left with a total number of pixels that is a perfect square ("fair and square"):

>>> histogram = im.histogram()
>>> sum(filter(lambda n: n != 0, histogram)[:-2])
17424
>>> 132*132
17424
This suggests that by removing the two highest pixel values and rearranging the remaining pixels in a square, we will get a new image in which, hopefully, we will see something new:

>>> data = Image.open(puzzle_image_filename).getdata()
>>> largest_used_pixval = max(data)
>>> data = filter(lambda p: p < largest_used_pixval-1, list(data))
>>> len(data) # Sanity check
17424
Again, we have 17424, which means we did it correctly.

>>> out = Image.new('L', (132, 132))
>>> out.putdata(data)
>>> out.show()
Hey! this looks exactly like the original image!

But no: it is smaller. The original was 138x138 and this one is 132x132.

The 33 beer bottles hint suggests we do it again and again, in a loop, until we've removed all pairs.

So here is the complete code:

   def intsqrt(n):
       """
       Return the root of an int or raise an exception if the param
       is not a square (inefficient but easily verifiable code)
       """
       for i in xrange(n):
           if i*i == n:
               return i
       raise ValueError("Not a square")
   
   import Image, sys
   puzzle_image_filename = 'beer2.png'
   data = list(Image.open(puzzle_image_filename).getdata())
   while True:
       largest_used_pixval = max(data)
       data = filter(lambda n: n < largest_used_pixval-1, data)
       if not data:
           break
       dimension = intsqrt(len(data))
       im = Image.new('L', (dimension, dimension))
       # Since the images become fainter and harder to see with each iteration,
       # we enhance the contrast before displaying the image:
       largest_used_pixval = max(data)
       data2 = [(n, 255)[n == largest_used_pixval] for n in data]
       im.putdata(data2)
       im.show()
       # Pause until I hit enter. I don't too many windows open at once.
       raw_input('Press enter to continue...')
Sure enough, after several X signs, another letter appears, then another... The loop terminates when len(data) becomes 0. The letters spell some meaningless garbage ("xxxxxxxxxxxxvinegarwinemoldinoslo"), but some of them have square frames around them. The framed letters spell 'gremlins'.

And here is the full translation of the rhyme:

If you are blinded by the light,
     -- If the brightest pixels (the light) prevent you from
        seeing anything else [By the way, they do so not
        because they are bright, but because they move the
        other pixels to random places],
remove its power, with its might.
     -- then you should delete (remove) the brightest (power)
        and the next brightest (might) pixels.
Then from the ashes, fair and square,
     -- Then the seemingly random noise (the ashes), can be put
        in a square (square) in which the brightest (fair) pixels,
another truth at you will glare.
     -- will look (glare) like another letter (truth).
     Don't be too hasty, though: only letters inside square frames
     are truly fair.
Minor variant

UncleTimmy: This was fun! The following differs only in minor details, but some may be illuminating. The grey levels used in the original image are of the form 6*i+1 and 6*i+2 for i in range(33), and that allows a bit of simplification. The box you're running on almost certainly implements IEEE-754 sqrt, which is 100% reliable for numbers in this range (meaning sqrt(n) is exactly correct if n is an exact square, for all integer n in 0 .. 2**53).

import Image
from math import sqrt
im = Image.open("beer2.png")
# 138x138; 66 unique shades of grey.
# They come in pairs:  1,2
#                      7,8
#                     13,14
#                      ...
#                   6i+1,6i+2 for i in range(33)
#                      ...
#                    193,194
d = im.getdata()
for cutoff in range(6*32+1, -1, -6):
    d = [p for p in d if p < cutoff]
    n = len(d)
    if n == 0:
        break
    sq = int(sqrt(n))
    assert sq**2 == n
    im2 = Image.new('L', (sq, sq))
    brightest = cutoff - 5
    # I found this easiest to read as black letter on white background.
    im2.putdata([p < brightest for p in d], scale=255)
    im2.show()
    raw_input("hit ENTER")
Another variant, with frame detection

borospeti: Minor differences from the previous solutions, with the addition of detecting the frame around the letters. Depending on the window manager, sorting the XV windows by size may be needed.

import urllib,Image,cStringIO,math

url = 'http://kohsamui:thailand@www.pythonchallenge.com/pc/rock/beer2.png'
data = list(Image.open(cStringIO.StringIO(urllib.urlopen(url).read())).getdata())

grays = list(set(data))
grays.sort()

def hasframe(data):
    try:
        c = data.index(255)
    except ValueError:
        return False
    for x in data[c:c+20]:
        if(x!=255):
            return False
    return True
        
for i in grays[::-2]:
    data = map(lambda x:(x,255)[x==i-6],filter(lambda x:x<i-1,data))
    if(hasframe(data)):
        size = int(math.sqrt(len(data)))
        beer = Image.new("L",(size,size))
        beer.putdata(data)
        beer.show()

